MLton gc73dc79-dirty (built Mon May 27 16:34:55 EDT 2013 on Tucker-Portable-Arch)
  created this file on Thu Jun 13 23:25:33 2013.
Do not edit this file.
Flag settings: 
   align: 8
   atMLtons: (C-SSE, @MLton, --)
   chunk: chunk per function
   closureConvertGlobalize: true
   closureConvertShrink: true
   codegen: amd64
   contifyIntoMain: false
   debug: false
   defaultChar: char8
   defaultWideChar: widechar32
   defaultInt: int32
   defaultReal: real64
   defaultWord: word32
   diag passes: []
   drop passes: []
   elaborate allowConstant (default): false
   elaborate allowConstant (enabled): true
   elaborate allowFFI (default): true
   elaborate allowFFI (enabled): true
   elaborate allowPrim (default): false
   elaborate allowPrim (enabled): true
   elaborate allowOverload (default): false
   elaborate allowOverload (enabled): true
   elaborate allowRebindEquals (default): false
   elaborate allowRebindEquals (enabled): true
   elaborate deadCode (default): false
   elaborate deadCode (enabled): true
   elaborate forceUsed (default): false
   elaborate forceUsed (enabled): true
   elaborate ffiStr (default): 
   elaborate ffiStr (enabled): true
   elaborate nonexhaustiveExnMatch (default): default
   elaborate nonexhaustiveExnMatch (enabled): true
   elaborate nonexhaustiveMatch (default): warn
   elaborate nonexhaustiveMatch (enabled): true
   elaborate redundantMatch (default): warn
   elaborate redundantMatch (enabled): true
   elaborate resolveScope (default): strdec
   elaborate resolveScope (enabled): true
   elaborate sequenceNonUnit (default): ignore
   elaborate sequenceNonUnit (enabled): true
   elaborate warnUnused (default): false
   elaborate warnUnused (enabled): true
   elaborate only: false
   emit main: true
   export header: None
   exn history: false
   generated output format: executable
   gc check: Limit
   indentation: 3
   inlineIntoMain: true
   inlineLeafA: {loops = true, repeat = true, size = Some 20}
   inlineLeafB: {loops = true, repeat = true, size = Some 40}
   inlineNonRec: {small = 60, product = 320}
   input file: C-SSE.xml
   keep CoreML: false
   keep def use: true
   keep dot: true
   keep Machine: true
   keep passes: []
   keep RSSA: true
   keep SSA: true
   keep SSA2: true
   keep SXML: true
   keep XML: true
   extra_: false
   lib dir: /home/tucker/usr/lib/mlton
   lib target dir: /home/tucker/usr/lib/mlton/targets/self
   loop passes: 1
   mark cards: true
   max function size: 10000
   mlb path vars: [{var = MLTON_ROOT, path = $(LIB_MLTON_DIR)/sml}, {var = SML_LIB, path = $(LIB_MLTON_DIR)/sml}]
   native commented: 0
   native live stack: false
   native optimize: 1
   native move hoist: true
   native copy prop: true
   native copy prop cutoff: 1000
   native cutoff: 100
   native live transfer: 8
   native shuffle: true
   native ieee fp: false
   native split: Some 20000
   optimizationPasses: [<ssa2::default>, <ssa::default>, <sxml::default>, <xml::default>]
   polyvariance: Some {hofo = true, rounds = 2, small = 30, product = 300}
   prefer abs paths: false
   prof passes: []
   profile: None
   profile branch: false
   profile C: []
   profile IL: ProfileSource
   profile include/exclude: [(Seq [Star [.], Or [Seq [Seq [[$], [(], [S], [M], [L], [_], [L], [I], [B], [)]]]], Star [.]], false)]
   profile raise: false
   profile stack: false
   profile val: false
   show basis: Some C-SSE.basis
   show def-use: Some C-SSE.def_use
   show types: true
   target: self
   target arch: AMD64
   target OS: Linux
   type check: false
   verbosity: Silent
   warn unrecognized annotation: true
   warn deprecated features: true
   zone cut depth: 100


Datatypes:
SMLofNJ.SysInfo.os_kind = BEOS
			  | MACOS
			  | OS2
			  | UNIX
			  | WIN32
MLtonWorld.status = Clone
		    | Original
'a MLtonFinalizable.t = T of (unit -> unit) list ref
			     * ('a -> unit) list ref
			     * 'a ref
MLtonProfile.Data.t = T of bool ref * bool ref * MLton.Pointer.t
MLtonItimer.t = Prof
		| Real
		| Virtual
UnixSock.unix = UNIX
INetSock.inet = INET
Socket.shutdown_mode = NO_RECVS
		       | NO_SENDS
		       | NO_RECVS_OR_SENDS
Socket.active = ACTIVE
Socket.passive = PASSIVE
Socket.stream = MODE
Socket.dgram = DGRAM
Socket.sock_addr = SA of Word8.word vector
NetServDB.entry = T of Word8.word vector list
		       * Word8.word vector
		       * word
		       * Word8.word vector
NetProtDB.entry = T of Word8.word vector list * Word8.word vector * word
NetHostDB.entry = T of word
		       * Word8.word vector list
		       * Word8.word vector list
		       * Word8.word vector
Timer.SysUsr.t = T of Time.time * Time.time
OS_IO.poll_info = PollInfo of word * (bool * bool * bool)
OS_IO.poll_desc = PollDesc of word * (bool * bool * bool)
OS_IO.iodesc_kind = K of Word8.word vector
('stdin, 'stdout, 'stderr) MLtonProcess.t = T of word
						 * Unix.exit_status option ref
						 * 'stderr MLtonProcess.Child.childt ref
						 * 'stdin MLtonProcess.Child.childt ref
						 * 'stdout MLtonProcess.Child.childt ref
MLtonProcess.Param.t = File of Word8.word vector
		       | FileDesc of word
		       | Pipe
		       | Self
'use MLtonProcess.Child.childt = FileDesc of word
				 | Stream of 'use * ('use -> unit)
				 | Term
MLtonSignal.Handler.t = Default
			| Handler of unit MLtonThread.t -> unit MLtonThread.t
			| Ignore
			| InvalidSignal
MLtonSignal.Mask.t = AllBut of word list
		     | Some of word list
MLtonThread.state = Normal
		    | InHandler
'a MLtonThread.t = T of 'a MLtonThread.thread ref
'a MLtonThread.thread = Dead
			| Interrupted of thread
			| New of 'a -> unit
			| Paused of ((unit -> 'a) -> unit) * thread
MLtonThread.AtomicState.t = NonAtomic
			    | Atomic of word
OS_FileSys.file_id = FID of Word64.word * Word64.word
TextIO.instream = In of TextPrimIO.reader
			* Word8.word array
			* word ref
			* word ref
			* TextPrimIO.reader
			* ImperativeIOExtra.state ref
ImperativeIOExtra.state = Closed
			  | Open of bool
			  | Stream of StreamIOExtra.instream
ImperativeIOExtra.Outstream.t = T of StreamIOExtra.outstream ref
StreamIOExtra.Close.t = T of (unit -> unit)
			     * Word8.word vector
			     * StreamIOExtra.state ref ref
StreamIOExtra.instream = In of StreamIOExtra.buf
			       * (TextPrimIO.reader
				  * TextPrimIO.reader
				  * StreamIOExtra.state ref ref)
			       * word
StreamIOExtra.buf = Buf of Word64.word option
			   * Word8.word vector
			   * StreamIOExtra.state ref
StreamIOExtra.state = Link of StreamIOExtra.buf
		      | Eos of StreamIOExtra.buf
		      | End
		      | Truncated
		      | Closed
StreamIOExtra.out_pos = OutPos of StreamIOExtra.outstream * Word64.word
StreamIOExtra.outstream = Out of TextPrimIO.writer
				 * StreamIOExtra.bufferMode ref
				 * StreamIOExtra.state ref
				 * TextPrimIO.writer
StreamIOExtra.state = Active
		      | Terminated
		      | Closed
StreamIOExtra.bufferMode = NO_BUF
			   | LINE_BUF of StreamIOExtra.buf
			   | BLOCK_BUF of StreamIOExtra.buf
StreamIOExtra.buf = Buf of Word8.word array * word ref
BinIO.instream = In of BinPrimIO.reader
		       * Word8.word array
		       * word ref
		       * word ref
		       * BinPrimIO.reader
		       * ImperativeIOExtra.state ref
ImperativeIOExtra.state = Closed
			  | Open of bool
			  | Stream of StreamIOExtra.instream
ImperativeIOExtra.Outstream.t = T of StreamIOExtra.outstream ref
StreamIOExtra.Close.t = T of (unit -> unit)
			     * Word8.word vector
			     * StreamIOExtra.state ref ref
StreamIOExtra.instream = In of StreamIOExtra.buf
			       * (BinPrimIO.reader
				  * BinPrimIO.reader
				  * StreamIOExtra.state ref ref)
			       * word
StreamIOExtra.buf = Buf of Word64.word option
			   * Word8.word vector
			   * StreamIOExtra.state ref
StreamIOExtra.state = Link of StreamIOExtra.buf
		      | Eos of StreamIOExtra.buf
		      | End
		      | Truncated
		      | Closed
StreamIOExtra.out_pos = OutPos of StreamIOExtra.outstream * Word64.word
StreamIOExtra.outstream = Out of BinPrimIO.writer
				 * StreamIOExtra.bufferMode ref
				 * StreamIOExtra.state ref
				 * BinPrimIO.writer
StreamIOExtra.state = Active
		      | Terminated
		      | Closed
StreamIOExtra.bufferMode = NO_BUF
			   | LINE_BUF of StreamIOExtra.buf
			   | BLOCK_BUF of StreamIOExtra.buf
StreamIOExtra.buf = Buf of Word8.word array * word ref
PosixProcess.killpid_arg = K_PROC of word
			   | K_SAME_GROUP
			   | K_GROUP of word
Unix.exit_status = W_EXITED
		   | W_EXITSTATUS of Word8.word
		   | W_SIGNALED of word
		   | W_STOPPED of word
PosixProcess.waitpid_arg = W_ANY_CHILD
			   | W_CHILD of word
			   | W_SAME_GROUP
			   | W_GROUP of word
PosixIO.lock_type = F_RDLCK
		    | F_WRLCK
		    | F_UNLCK
PosixIO.whence = SEEK_SET
		 | SEEK_CUR
		 | SEEK_END
PosixFileSys.access_mode = A_READ
			   | A_WRITE
			   | A_EXEC
PosixFileSys.ST.stat = T of Time.time
			    * Time.time
			    * Word64.word
			    * word
			    * Word64.word
			    * word
			    * Time.time
			    * word
			    * Word64.word
			    * word
PosixFileSys.open_mode = O_RDONLY
			 | O_WRONLY
			 | O_RDWR
PosixFileSys.dirstream = DS of Word64.word option ref
TextPrimIO.writer = WR of (unit -> unit) option
			  * (unit -> bool) option
			  * word
			  * (unit -> unit)
			  * (unit -> Word64.word) option
			  * (unit -> Word64.word) option
			  * word option
			  * Word8.word vector
			  * (Word64.word -> unit) option
			  * (unit -> Word64.word) option
			  * (Word8.word ArraySlice.slice -> word) option
			  * (Word8.word ArraySlice.slice -> word option) option
			  * (Word8.word VectorSlice.slice -> word) option
			  * (Word8.word VectorSlice.slice -> word option) option
TextPrimIO.reader = RD of (unit -> word option)
			  * (unit -> unit) option
			  * (unit -> bool) option
			  * word
			  * (unit -> unit)
			  * (unit -> Word64.word) option
			  * (unit -> Word64.word) option
			  * word option
			  * Word8.word vector
			  * (Word8.word ArraySlice.slice -> word) option
			  * (Word8.word ArraySlice.slice -> word option) option
			  * (word -> Word8.word vector) option
			  * (word -> Word8.word vector option) option
			  * (Word64.word -> unit) option
			  * (unit -> Word64.word) option
BinPrimIO.writer = WR of (unit -> unit) option
			 * (unit -> bool) option
			 * word
			 * (unit -> unit)
			 * (unit -> Word64.word) option
			 * (unit -> Word64.word) option
			 * word option
			 * Word8.word vector
			 * (Word64.word -> unit) option
			 * (unit -> Word64.word) option
			 * (Word8.word ArraySlice.slice -> word) option
			 * (Word8.word ArraySlice.slice -> word option) option
			 * (Word8.word VectorSlice.slice -> word) option
			 * (Word8.word VectorSlice.slice -> word option) option
BinPrimIO.reader = RD of (unit -> word option)
			 * (unit -> unit) option
			 * (unit -> bool) option
			 * word
			 * (unit -> unit)
			 * (unit -> Word64.word) option
			 * (unit -> Word64.word) option
			 * word option
			 * Word8.word vector
			 * (Word8.word ArraySlice.slice -> word) option
			 * (Word8.word ArraySlice.slice -> word option) option
			 * (word -> Word8.word vector) option
			 * (word -> Word8.word vector option) option
			 * (Word64.word -> unit) option
			 * (unit -> Word64.word) option
IO.buffer_mode = NO_BUF
		 | LINE_BUF
		 | BLOCK_BUF
Date.t = T of word
	      * word
	      * bool option
	      * word
	      * Date.month
	      * word option
	      * word
	      * Date.weekday
	      * word
	      * word
Date.month = Jan
	     | Feb
	     | Mar
	     | Apr
	     | May
	     | Jun
	     | Jul
	     | Aug
	     | Sep
	     | Oct
	     | Nov
	     | Dec
Date.weekday = Mon
	       | Tue
	       | Wed
	       | Thu
	       | Fri
	       | Sat
	       | Sun
Time.time = T of IntInf.int
Real.mode = Fix
	    | Gen
	    | Sci
Real.mode = Fix
	    | Gen
	    | Sci
IEEEReal.rounding_mode = TO_NEAREST
			 | TO_NEGINF
			 | TO_POSINF
			 | TO_ZERO
IEEEReal.float_class = INF
		       | NAN
		       | NORMAL
		       | SUBNORMAL
		       | ZERO
IEEEReal.real_order = LESS
		      | EQUAL
		      | GREATER
		      | UNORDERED
StringCvt.realfmt = SCI of word option
		    | FIX of word option
		    | GEN of word option
		    | EXACT
StringCvt.radix = BIN
		  | OCT
		  | DEC
		  | HEX
Word64Array2.traversal = RowMajor
			 | ColMajor
'a ArraySlice.slice = T of Word64.word * 'a array * Word64.word
'a VectorSlice.slice = T of Word64.word * 'a vector * Word64.word
'a One.t = T of (unit -> 'a) * 'a * bool ref
'a Primitive.IntInf.ans = Big of bool * bool * 'a
			  | Small of Word64.word
Primitive.IntInf.rep = Big of Word64.word vector
		       | Small of Word64.word
'a DynamicWind.try.t = A of 'a
		       | E of exn
Primitive.MLton.Platform.OS.t = AIX
				| Cygwin
				| Darwin
				| FreeBSD
				| Hurd
				| HPUX
				| Linux
				| MinGW
				| NetBSD
				| OpenBSD
				| Solaris
Primitive.MLton.Platform.Format.t = Archive
				    | Executable
				    | LibArchive
				    | Library
Primitive.MLton.Platform.Arch.t = Alpha
				  | AMD64
				  | ARM
				  | ARM64
				  | HPPA
				  | IA64
				  | m68k
				  | MIPS
				  | PowerPC
				  | PowerPC64
				  | S390
				  | Sparc
				  | X86
Primitive.MLton.Codegen.t = amd64
			    | C
			    | x86
Primitive.MLton.CallStack.t = T of word array
Primitive.MLton.Align.t = Align4
			  | Align8
'a option = NONE
	    | SOME of 'a
order = LESS
	| EQUAL
	| GREATER
'a_0 list = nil
	    | :: of 'a_0 * 'a_0 list
bool = false
       | true


Overflow: None


Body:
let
   exception Bind
   exception Match
   exception Overflow
   val rec 
      not: bool -> bool = 
	 fn x_0: bool => 
	 let
	    val x_1: bool = 
	       case x_0 of
	       true => 
		  let
		     val x_3: bool = 
			false
		  in
		     x_3
		  end
	       false => 
		  let
		     val x_2: bool = 
			true
		  in
		     x_2
		  end
	 in
	    x_1
	 end
   val name: exn -> Word8.word vector = 
      fn x_4: exn => 
      let
	 val x_5: Word8.word vector = 
	    Exn_name (x_4)
      in
	 x_5
      end
   exception Div
   exception Domain
   exception Fail8 of Word8.word vector
   exception Fail16 of Word16.word vector
   exception Fail32 of word vector
   exception Overflow
   exception Size
   exception Subscript
   val ('b, 'a) wrapOverflow: ('a -> 'b) -> 'a -> 'b = 
      let
	 val x_6: ('a -> 'b) -> 'a -> 'b = 
	    fn x_7: 'a -> 'b => 
	    let
	       val x_8: 'a -> 'b = 
		  fn x_9: 'a => 
		  let
		     val x_10: 'b = 
			let
			   val x_11: 'b = 
			      x_7 x_9
			in
			   x_11
			end
			handle x_12 => let
					  val x_13: 'b = 
					     case x_12 of
					     Overflow => 
						let
						   val x_14: exn = 
						      Overflow
						   val x_15: 'b = 
						      raise x_14
						in
						   x_15
						end
					       _ => let
						       val x_16: 'b = 
							  raise x_12
						    in
						       x_16
						    end
				       in
					  x_13
				       end
		  in
		     x_10
		  end
	    in
	       x_8
	    end
      in
	 x_6
      end
   val 'a deref: 'a ref -> 'a = 
      let
	 val x_17: 'a ref -> 'a = 
	    fn x_18: 'a ref => 
	    let
	       val x_19: 'a = 
		  Ref_deref['a] (x_18)
	    in
	       x_19
	    end
      in
	 x_17
      end
   val 'a assign: 'a ref * 'a -> unit = 
      let
	 val x_20: 'a ref * 'a -> unit = 
	    fn x_21: 'a ref * 'a => 
	    let
	       val x_22: 'a = 
		  #1 x_21
	       val x_23: 'a ref = 
		  #0 x_21
	       val x_24: unit = 
		  Ref_assign['a] (x_23, x_22)
	    in
	       x_24
	    end
      in
	 x_20
      end
   val setHandler: (exn -> unit) -> unit = 
      fn x_25: exn -> unit => 
      let
	 val x_26: unit = 
	    TopLevel_setHandler (x_25)
      in
	 x_26
      end
   val setSuffix: (unit -> unit) -> unit = 
      fn x_27: unit -> unit => 
      let
	 val x_28: unit = 
	    TopLevel_setSuffix (x_27)
      in
	 x_28
      end
   val ''a =: ''a * ''a -> bool = 
      let
	 val x_29: ''a * ''a -> bool = 
	    fn x_30: ''a * ''a => 
	    let
	       val x_31: ''a = 
		  #1 x_30
	       val x_32: ''a = 
		  #0 x_30
	       val x_33: bool = 
		  MLton_equal[''a] (x_32, x_31)
	    in
	       x_33
	    end
      in
	 x_29
      end
   val ''a_2 <>: ''a_2 * ''a_2 -> bool = 
      let
	 val x_34: ''a_2 * ''a_2 -> bool = 
	    fn x_35: ''a_2 * ''a_2 => 
	    let
	       val y: ''a_2 = 
		  #1 x_35
	       val x: ''a_2 = 
		  #0 x_35
	       val x_36: ''a_2 * ''a_2 = 
		  (x, y)
	       val x_37: bool = 
		  = (''a_2) x_36
	       val x_38: bool = 
		  not x_37
	    in
	       x_38
	    end
      in
	 x_34
      end
   val idFromInt8ToWord8: Word8.word -> Word8.word = 
      fn x_39: Word8.word => 
      let
      in
	 x_39
      end
   val idFromInt16ToWord16: Word16.word -> Word16.word = 
      fn x_40: Word16.word => 
      let
      in
	 x_40
      end
   val idFromInt32ToWord32: word -> word = 
      fn x_41: word => 
      let
      in
	 x_41
      end
   val idFromInt64ToWord64: Word64.word -> Word64.word = 
      fn x_42: Word64.word => 
      let
      in
	 x_42
      end
   val idFromWord8ToInt8: Word8.word -> Word8.word = 
      fn x_43: Word8.word => 
      let
      in
	 x_43
      end
   val idFromWord16ToInt16: Word16.word -> Word16.word = 
      fn x_44: Word16.word => 
      let
      in
	 x_44
      end
   val idFromWord32ToInt32: word -> word = 
      fn x_45: word => 
      let
      in
	 x_45
      end
   val idFromWord64ToInt64: Word64.word -> Word64.word = 
      fn x_46: Word64.word => 
      let
      in
	 x_46
      end
   val zextdFromInt8ToInt16: Word8.word -> Word16.word = 
      fn x_47: Word8.word => 
      let
	 val x_48: Word16.word = 
	    WordU8_extdToWord16 (x_47)
      in
	 x_48
      end
   val zextdFromInt8ToInt32: Word8.word -> word = 
      fn x_49: Word8.word => 
      let
	 val x_50: word = 
	    WordU8_extdToWord32 (x_49)
      in
	 x_50
      end
   val zextdFromInt8ToInt64: Word8.word -> Word64.word = 
      fn x_51: Word8.word => 
      let
	 val x_52: Word64.word = 
	    WordU8_extdToWord64 (x_51)
      in
	 x_52
      end
   val zextdFromInt8ToWord16: Word8.word -> Word16.word = 
      fn x_53: Word8.word => 
      let
	 val x_54: Word16.word = 
	    WordU8_extdToWord16 (x_53)
      in
	 x_54
      end
   val zextdFromInt8ToWord32: Word8.word -> word = 
      fn x_55: Word8.word => 
      let
	 val x_56: word = 
	    WordU8_extdToWord32 (x_55)
      in
	 x_56
      end
   val zextdFromInt8ToWord64: Word8.word -> Word64.word = 
      fn x_57: Word8.word => 
      let
	 val x_58: Word64.word = 
	    WordU8_extdToWord64 (x_57)
      in
	 x_58
      end
   val zextdFromInt16ToInt8: Word16.word -> Word8.word = 
      fn x_59: Word16.word => 
      let
	 val x_60: Word8.word = 
	    WordU16_extdToWord8 (x_59)
      in
	 x_60
      end
   val zextdFromInt16ToInt32: Word16.word -> word = 
      fn x_61: Word16.word => 
      let
	 val x_62: word = 
	    WordU16_extdToWord32 (x_61)
      in
	 x_62
      end
   val zextdFromInt16ToInt64: Word16.word -> Word64.word = 
      fn x_63: Word16.word => 
      let
	 val x_64: Word64.word = 
	    WordU16_extdToWord64 (x_63)
      in
	 x_64
      end
   val zextdFromInt16ToWord8: Word16.word -> Word8.word = 
      fn x_65: Word16.word => 
      let
	 val x_66: Word8.word = 
	    WordU16_extdToWord8 (x_65)
      in
	 x_66
      end
   val zextdFromInt16ToWord32: Word16.word -> word = 
      fn x_67: Word16.word => 
      let
	 val x_68: word = 
	    WordU16_extdToWord32 (x_67)
      in
	 x_68
      end
   val zextdFromInt16ToWord64: Word16.word -> Word64.word = 
      fn x_69: Word16.word => 
      let
	 val x_70: Word64.word = 
	    WordU16_extdToWord64 (x_69)
      in
	 x_70
      end
   val zextdFromInt32ToInt8: word -> Word8.word = 
      fn x_71: word => 
      let
	 val x_72: Word8.word = 
	    WordU32_extdToWord8 (x_71)
      in
	 x_72
      end
   val zextdFromInt32ToInt16: word -> Word16.word = 
      fn x_73: word => 
      let
	 val x_74: Word16.word = 
	    WordU32_extdToWord16 (x_73)
      in
	 x_74
      end
   val zextdFromInt32ToInt32: word -> word = 
      fn x_75: word => 
      let
      in
	 x_75
      end
   val zextdFromInt32ToInt64: word -> Word64.word = 
      fn x_76: word => 
      let
	 val x_77: Word64.word = 
	    WordU32_extdToWord64 (x_76)
      in
	 x_77
      end
   val zextdFromInt32ToWord8: word -> Word8.word = 
      fn x_78: word => 
      let
	 val x_79: Word8.word = 
	    WordU32_extdToWord8 (x_78)
      in
	 x_79
      end
   val zextdFromInt32ToWord16: word -> Word16.word = 
      fn x_80: word => 
      let
	 val x_81: Word16.word = 
	    WordU32_extdToWord16 (x_80)
      in
	 x_81
      end
   val zextdFromInt32ToWord32: word -> word = 
      fn x_82: word => 
      let
      in
	 x_82
      end
   val zextdFromInt32ToWord64: word -> Word64.word = 
      fn x_83: word => 
      let
	 val x_84: Word64.word = 
	    WordU32_extdToWord64 (x_83)
      in
	 x_84
      end
   val zextdFromInt64ToInt8: Word64.word -> Word8.word = 
      fn x_85: Word64.word => 
      let
	 val x_86: Word8.word = 
	    WordU64_extdToWord8 (x_85)
      in
	 x_86
      end
   val zextdFromInt64ToInt16: Word64.word -> Word16.word = 
      fn x_87: Word64.word => 
      let
	 val x_88: Word16.word = 
	    WordU64_extdToWord16 (x_87)
      in
	 x_88
      end
   val zextdFromInt64ToInt32: Word64.word -> word = 
      fn x_89: Word64.word => 
      let
	 val x_90: word = 
	    WordU64_extdToWord32 (x_89)
      in
	 x_90
      end
   val zextdFromInt64ToWord8: Word64.word -> Word8.word = 
      fn x_91: Word64.word => 
      let
	 val x_92: Word8.word = 
	    WordU64_extdToWord8 (x_91)
      in
	 x_92
      end
   val zextdFromInt64ToWord16: Word64.word -> Word16.word = 
      fn x_93: Word64.word => 
      let
	 val x_94: Word16.word = 
	    WordU64_extdToWord16 (x_93)
      in
	 x_94
      end
   val zextdFromInt64ToWord32: Word64.word -> word = 
      fn x_95: Word64.word => 
      let
	 val x_96: word = 
	    WordU64_extdToWord32 (x_95)
      in
	 x_96
      end
   val zextdFromInt64ToWord64: Word64.word -> Word64.word = 
      fn x_97: Word64.word => 
      let
      in
	 x_97
      end
   val zextdFromWord8ToInt16: Word8.word -> Word16.word = 
      fn x_98: Word8.word => 
      let
	 val x_99: Word16.word = 
	    WordU8_extdToWord16 (x_98)
      in
	 x_99
      end
   val zextdFromWord8ToInt32: Word8.word -> word = 
      fn x_100: Word8.word => 
      let
	 val x_101: word = 
	    WordU8_extdToWord32 (x_100)
      in
	 x_101
      end
   val zextdFromWord8ToInt64: Word8.word -> Word64.word = 
      fn x_102: Word8.word => 
      let
	 val x_103: Word64.word = 
	    WordU8_extdToWord64 (x_102)
      in
	 x_103
      end
   val zextdFromWord8ToWord16: Word8.word -> Word16.word = 
      fn x_104: Word8.word => 
      let
	 val x_105: Word16.word = 
	    WordU8_extdToWord16 (x_104)
      in
	 x_105
      end
   val zextdFromWord8ToWord32: Word8.word -> word = 
      fn x_106: Word8.word => 
      let
	 val x_107: word = 
	    WordU8_extdToWord32 (x_106)
      in
	 x_107
      end
   val zextdFromWord8ToWord64: Word8.word -> Word64.word = 
      fn x_108: Word8.word => 
      let
	 val x_109: Word64.word = 
	    WordU8_extdToWord64 (x_108)
      in
	 x_109
      end
   val zextdFromWord16ToInt8: Word16.word -> Word8.word = 
      fn x_110: Word16.word => 
      let
	 val x_111: Word8.word = 
	    WordU16_extdToWord8 (x_110)
      in
	 x_111
      end
   val zextdFromWord16ToInt32: Word16.word -> word = 
      fn x_112: Word16.word => 
      let
	 val x_113: word = 
	    WordU16_extdToWord32 (x_112)
      in
	 x_113
      end
   val zextdFromWord16ToInt64: Word16.word -> Word64.word = 
      fn x_114: Word16.word => 
      let
	 val x_115: Word64.word = 
	    WordU16_extdToWord64 (x_114)
      in
	 x_115
      end
   val zextdFromWord16ToWord8: Word16.word -> Word8.word = 
      fn x_116: Word16.word => 
      let
	 val x_117: Word8.word = 
	    WordU16_extdToWord8 (x_116)
      in
	 x_117
      end
   val zextdFromWord16ToWord32: Word16.word -> word = 
      fn x_118: Word16.word => 
      let
	 val x_119: word = 
	    WordU16_extdToWord32 (x_118)
      in
	 x_119
      end
   val zextdFromWord16ToWord64: Word16.word -> Word64.word = 
      fn x_120: Word16.word => 
      let
	 val x_121: Word64.word = 
	    WordU16_extdToWord64 (x_120)
      in
	 x_121
      end
   val zextdFromWord32ToInt8: word -> Word8.word = 
      fn x_122: word => 
      let
	 val x_123: Word8.word = 
	    WordU32_extdToWord8 (x_122)
      in
	 x_123
      end
   val zextdFromWord32ToInt16: word -> Word16.word = 
      fn x_124: word => 
      let
	 val x_125: Word16.word = 
	    WordU32_extdToWord16 (x_124)
      in
	 x_125
      end
   val zextdFromWord32ToInt32: word -> word = 
      fn x_126: word => 
      let
      in
	 x_126
      end
   val zextdFromWord32ToInt64: word -> Word64.word = 
      fn x_127: word => 
      let
	 val x_128: Word64.word = 
	    WordU32_extdToWord64 (x_127)
      in
	 x_128
      end
   val zextdFromWord32ToWord8: word -> Word8.word = 
      fn x_129: word => 
      let
	 val x_130: Word8.word = 
	    WordU32_extdToWord8 (x_129)
      in
	 x_130
      end
   val zextdFromWord32ToWord16: word -> Word16.word = 
      fn x_131: word => 
      let
	 val x_132: Word16.word = 
	    WordU32_extdToWord16 (x_131)
      in
	 x_132
      end
   val zextdFromWord32ToWord32: word -> word = 
      fn x_133: word => 
      let
      in
	 x_133
      end
   val zextdFromWord32ToWord64: word -> Word64.word = 
      fn x_134: word => 
      let
	 val x_135: Word64.word = 
	    WordU32_extdToWord64 (x_134)
      in
	 x_135
      end
   val zextdFromWord64ToInt8: Word64.word -> Word8.word = 
      fn x_136: Word64.word => 
      let
	 val x_137: Word8.word = 
	    WordU64_extdToWord8 (x_136)
      in
	 x_137
      end
   val zextdFromWord64ToInt16: Word64.word -> Word16.word = 
      fn x_138: Word64.word => 
      let
	 val x_139: Word16.word = 
	    WordU64_extdToWord16 (x_138)
      in
	 x_139
      end
   val zextdFromWord64ToInt32: Word64.word -> word = 
      fn x_140: Word64.word => 
      let
	 val x_141: word = 
	    WordU64_extdToWord32 (x_140)
      in
	 x_141
      end
   val zextdFromWord64ToInt64: Word64.word -> Word64.word = 
      fn x_142: Word64.word => 
      let
      in
	 x_142
      end
   val zextdFromWord64ToWord8: Word64.word -> Word8.word = 
      fn x_143: Word64.word => 
      let
	 val x_144: Word8.word = 
	    WordU64_extdToWord8 (x_143)
      in
	 x_144
      end
   val zextdFromWord64ToWord16: Word64.word -> Word16.word = 
      fn x_145: Word64.word => 
      let
	 val x_146: Word16.word = 
	    WordU64_extdToWord16 (x_145)
      in
	 x_146
      end
   val zextdFromWord64ToWord32: Word64.word -> word = 
      fn x_147: Word64.word => 
      let
	 val x_148: word = 
	    WordU64_extdToWord32 (x_147)
      in
	 x_148
      end
   val zextdFromWord64ToWord64: Word64.word -> Word64.word = 
      fn x_149: Word64.word => 
      let
      in
	 x_149
      end
   val sextdFromInt8ToInt16: Word8.word -> Word16.word = 
      fn x_150: Word8.word => 
      let
	 val x_151: Word16.word = 
	    WordS8_extdToWord16 (x_150)
      in
	 x_151
      end
   val sextdFromInt8ToInt32: Word8.word -> word = 
      fn x_152: Word8.word => 
      let
	 val x_153: word = 
	    WordS8_extdToWord32 (x_152)
      in
	 x_153
      end
   val sextdFromInt8ToInt64: Word8.word -> Word64.word = 
      fn x_154: Word8.word => 
      let
	 val x_155: Word64.word = 
	    WordS8_extdToWord64 (x_154)
      in
	 x_155
      end
   val sextdFromInt8ToWord16: Word8.word -> Word16.word = 
      fn x_156: Word8.word => 
      let
	 val x_157: Word16.word = 
	    WordS8_extdToWord16 (x_156)
      in
	 x_157
      end
   val sextdFromInt8ToWord32: Word8.word -> word = 
      fn x_158: Word8.word => 
      let
	 val x_159: word = 
	    WordS8_extdToWord32 (x_158)
      in
	 x_159
      end
   val sextdFromInt8ToWord64: Word8.word -> Word64.word = 
      fn x_160: Word8.word => 
      let
	 val x_161: Word64.word = 
	    WordS8_extdToWord64 (x_160)
      in
	 x_161
      end
   val sextdFromInt16ToInt8: Word16.word -> Word8.word = 
      fn x_162: Word16.word => 
      let
	 val x_163: Word8.word = 
	    WordS16_extdToWord8 (x_162)
      in
	 x_163
      end
   val sextdFromInt16ToInt32: Word16.word -> word = 
      fn x_164: Word16.word => 
      let
	 val x_165: word = 
	    WordS16_extdToWord32 (x_164)
      in
	 x_165
      end
   val sextdFromInt16ToInt64: Word16.word -> Word64.word = 
      fn x_166: Word16.word => 
      let
	 val x_167: Word64.word = 
	    WordS16_extdToWord64 (x_166)
      in
	 x_167
      end
   val sextdFromInt16ToWord8: Word16.word -> Word8.word = 
      fn x_168: Word16.word => 
      let
	 val x_169: Word8.word = 
	    WordS16_extdToWord8 (x_168)
      in
	 x_169
      end
   val sextdFromInt16ToWord32: Word16.word -> word = 
      fn x_170: Word16.word => 
      let
	 val x_171: word = 
	    WordS16_extdToWord32 (x_170)
      in
	 x_171
      end
   val sextdFromInt16ToWord64: Word16.word -> Word64.word = 
      fn x_172: Word16.word => 
      let
	 val x_173: Word64.word = 
	    WordS16_extdToWord64 (x_172)
      in
	 x_173
      end
   val sextdFromInt32ToInt8: word -> Word8.word = 
      fn x_174: word => 
      let
	 val x_175: Word8.word = 
	    WordS32_extdToWord8 (x_174)
      in
	 x_175
      end
   val sextdFromInt32ToInt16: word -> Word16.word = 
      fn x_176: word => 
      let
	 val x_177: Word16.word = 
	    WordS32_extdToWord16 (x_176)
      in
	 x_177
      end
   val sextdFromInt32ToInt32: word -> word = 
      fn x_178: word => 
      let
      in
	 x_178
      end
   val sextdFromInt32ToInt64: word -> Word64.word = 
      fn x_179: word => 
      let
	 val x_180: Word64.word = 
	    WordS32_extdToWord64 (x_179)
      in
	 x_180
      end
   val sextdFromInt32ToWord8: word -> Word8.word = 
      fn x_181: word => 
      let
	 val x_182: Word8.word = 
	    WordS32_extdToWord8 (x_181)
      in
	 x_182
      end
   val sextdFromInt32ToWord16: word -> Word16.word = 
      fn x_183: word => 
      let
	 val x_184: Word16.word = 
	    WordS32_extdToWord16 (x_183)
      in
	 x_184
      end
   val sextdFromInt32ToWord32: word -> word = 
      fn x_185: word => 
      let
      in
	 x_185
      end
   val sextdFromInt32ToWord64: word -> Word64.word = 
      fn x_186: word => 
      let
	 val x_187: Word64.word = 
	    WordS32_extdToWord64 (x_186)
      in
	 x_187
      end
   val sextdFromInt64ToInt8: Word64.word -> Word8.word = 
      fn x_188: Word64.word => 
      let
	 val x_189: Word8.word = 
	    WordS64_extdToWord8 (x_188)
      in
	 x_189
      end
   val sextdFromInt64ToInt16: Word64.word -> Word16.word = 
      fn x_190: Word64.word => 
      let
	 val x_191: Word16.word = 
	    WordS64_extdToWord16 (x_190)
      in
	 x_191
      end
   val sextdFromInt64ToInt32: Word64.word -> word = 
      fn x_192: Word64.word => 
      let
	 val x_193: word = 
	    WordS64_extdToWord32 (x_192)
      in
	 x_193
      end
   val sextdFromInt64ToInt64: Word64.word -> Word64.word = 
      fn x_194: Word64.word => 
      let
      in
	 x_194
      end
   val sextdFromInt64ToWord8: Word64.word -> Word8.word = 
      fn x_195: Word64.word => 
      let
	 val x_196: Word8.word = 
	    WordS64_extdToWord8 (x_195)
      in
	 x_196
      end
   val sextdFromInt64ToWord16: Word64.word -> Word16.word = 
      fn x_197: Word64.word => 
      let
	 val x_198: Word16.word = 
	    WordS64_extdToWord16 (x_197)
      in
	 x_198
      end
   val sextdFromInt64ToWord32: Word64.word -> word = 
      fn x_199: Word64.word => 
      let
	 val x_200: word = 
	    WordS64_extdToWord32 (x_199)
      in
	 x_200
      end
   val sextdFromWord8ToInt16: Word8.word -> Word16.word = 
      fn x_201: Word8.word => 
      let
	 val x_202: Word16.word = 
	    WordS8_extdToWord16 (x_201)
      in
	 x_202
      end
   val sextdFromWord8ToInt32: Word8.word -> word = 
      fn x_203: Word8.word => 
      let
	 val x_204: word = 
	    WordS8_extdToWord32 (x_203)
      in
	 x_204
      end
   val sextdFromWord8ToInt64: Word8.word -> Word64.word = 
      fn x_205: Word8.word => 
      let
	 val x_206: Word64.word = 
	    WordS8_extdToWord64 (x_205)
      in
	 x_206
      end
   val sextdFromWord8ToWord16: Word8.word -> Word16.word = 
      fn x_207: Word8.word => 
      let
	 val x_208: Word16.word = 
	    WordS8_extdToWord16 (x_207)
      in
	 x_208
      end
   val sextdFromWord8ToWord32: Word8.word -> word = 
      fn x_209: Word8.word => 
      let
	 val x_210: word = 
	    WordS8_extdToWord32 (x_209)
      in
	 x_210
      end
   val sextdFromWord8ToWord64: Word8.word -> Word64.word = 
      fn x_211: Word8.word => 
      let
	 val x_212: Word64.word = 
	    WordS8_extdToWord64 (x_211)
      in
	 x_212
      end
   val sextdFromWord16ToInt8: Word16.word -> Word8.word = 
      fn x_213: Word16.word => 
      let
	 val x_214: Word8.word = 
	    WordS16_extdToWord8 (x_213)
      in
	 x_214
      end
   val sextdFromWord16ToInt32: Word16.word -> word = 
      fn x_215: Word16.word => 
      let
	 val x_216: word = 
	    WordS16_extdToWord32 (x_215)
      in
	 x_216
      end
   val sextdFromWord16ToInt64: Word16.word -> Word64.word = 
      fn x_217: Word16.word => 
      let
	 val x_218: Word64.word = 
	    WordS16_extdToWord64 (x_217)
      in
	 x_218
      end
   val sextdFromWord16ToWord8: Word16.word -> Word8.word = 
      fn x_219: Word16.word => 
      let
	 val x_220: Word8.word = 
	    WordS16_extdToWord8 (x_219)
      in
	 x_220
      end
   val sextdFromWord16ToWord32: Word16.word -> word = 
      fn x_221: Word16.word => 
      let
	 val x_222: word = 
	    WordS16_extdToWord32 (x_221)
      in
	 x_222
      end
   val sextdFromWord16ToWord64: Word16.word -> Word64.word = 
      fn x_223: Word16.word => 
      let
	 val x_224: Word64.word = 
	    WordS16_extdToWord64 (x_223)
      in
	 x_224
      end
   val sextdFromWord32ToInt8: word -> Word8.word = 
      fn x_225: word => 
      let
	 val x_226: Word8.word = 
	    WordS32_extdToWord8 (x_225)
      in
	 x_226
      end
   val sextdFromWord32ToInt16: word -> Word16.word = 
      fn x_227: word => 
      let
	 val x_228: Word16.word = 
	    WordS32_extdToWord16 (x_227)
      in
	 x_228
      end
   val sextdFromWord32ToInt64: word -> Word64.word = 
      fn x_229: word => 
      let
	 val x_230: Word64.word = 
	    WordS32_extdToWord64 (x_229)
      in
	 x_230
      end
   val sextdFromWord32ToWord8: word -> Word8.word = 
      fn x_231: word => 
      let
	 val x_232: Word8.word = 
	    WordS32_extdToWord8 (x_231)
      in
	 x_232
      end
   val sextdFromWord32ToWord16: word -> Word16.word = 
      fn x_233: word => 
      let
	 val x_234: Word16.word = 
	    WordS32_extdToWord16 (x_233)
      in
	 x_234
      end
   val sextdFromWord32ToWord64: word -> Word64.word = 
      fn x_235: word => 
      let
	 val x_236: Word64.word = 
	    WordS32_extdToWord64 (x_235)
      in
	 x_236
      end
   val sextdFromWord64ToInt8: Word64.word -> Word8.word = 
      fn x_237: Word64.word => 
      let
	 val x_238: Word8.word = 
	    WordS64_extdToWord8 (x_237)
      in
	 x_238
      end
   val sextdFromWord64ToInt16: Word64.word -> Word16.word = 
      fn x_239: Word64.word => 
      let
	 val x_240: Word16.word = 
	    WordS64_extdToWord16 (x_239)
      in
	 x_240
      end
   val sextdFromWord64ToInt32: Word64.word -> word = 
      fn x_241: Word64.word => 
      let
	 val x_242: word = 
	    WordS64_extdToWord32 (x_241)
      in
	 x_242
      end
   val sextdFromWord64ToWord8: Word64.word -> Word8.word = 
      fn x_243: Word64.word => 
      let
	 val x_244: Word8.word = 
	    WordS64_extdToWord8 (x_243)
      in
	 x_244
      end
   val sextdFromWord64ToWord16: Word64.word -> Word16.word = 
      fn x_245: Word64.word => 
      let
	 val x_246: Word16.word = 
	    WordS64_extdToWord16 (x_245)
      in
	 x_246
      end
   val sextdFromWord64ToWord32: Word64.word -> word = 
      fn x_247: Word64.word => 
      let
	 val x_248: word = 
	    WordS64_extdToWord32 (x_247)
      in
	 x_248
      end
   val sextdFromWord64ToWord64: Word64.word -> Word64.word = 
      fn x_249: Word64.word => 
      let
      in
	 x_249
      end
   val sizeInBits: word = 
      0x1
   val sizeInBits: word = 
      0x2
   val sizeInBits: word = 
      0x3
   val sizeInBits: word = 
      0x4
   val sizeInBits: word = 
      0x5
   val sizeInBits: word = 
      0x6
   val sizeInBits: word = 
      0x7
   val sizeInBits: word = 
      0x8
   val sizeInBitsWord: word = 
      zextdFromInt32ToWord32 sizeInBits
   val <<?: Word8.word * word -> Word8.word = 
      fn x_250: Word8.word * word => 
      let
	 val x_251: word = 
	    #1 x_250
	 val x_252: Word8.word = 
	    #0 x_250
	 val x_253: Word8.word = 
	    Word8_lshift (x_252, x_251)
      in
	 x_253
      end
   val notb: Word8.word -> Word8.word = 
      fn x_254: Word8.word => 
      let
	 val x_255: Word8.word = 
	    Word8_notb (x_254)
      in
	 x_255
      end
   val orb: Word8.word * Word8.word -> Word8.word = 
      fn x_256: Word8.word * Word8.word => 
      let
	 val x_257: Word8.word = 
	    #1 x_256
	 val x_258: Word8.word = 
	    #0 x_256
	 val x_259: Word8.word = 
	    Word8_orb (x_258, x_257)
      in
	 x_259
      end
   val >>?: Word8.word * word -> Word8.word = 
      fn x_260: Word8.word * word => 
      let
	 val x_261: word = 
	    #1 x_260
	 val x_262: Word8.word = 
	    #0 x_260
	 val x_263: Word8.word = 
	    WordU8_rshift (x_262, x_261)
      in
	 x_263
      end
   val sizeInBits: word = 
      0x9
   val sizeInBits: word = 
      0xA
   val sizeInBits: word = 
      0xB
   val sizeInBits: word = 
      0xC
   val sizeInBits: word = 
      0xD
   val sizeInBits: word = 
      0xE
   val sizeInBits: word = 
      0xF
   val sizeInBits: word = 
      0x10
   val sizeInBitsWord: word = 
      zextdFromInt32ToWord32 sizeInBits
   val <<?: Word16.word * word -> Word16.word = 
      fn x_264: Word16.word * word => 
      let
	 val x_265: word = 
	    #1 x_264
	 val x_266: Word16.word = 
	    #0 x_264
	 val x_267: Word16.word = 
	    Word16_lshift (x_266, x_265)
      in
	 x_267
      end
   val notb: Word16.word -> Word16.word = 
      fn x_268: Word16.word => 
      let
	 val x_269: Word16.word = 
	    Word16_notb (x_268)
      in
	 x_269
      end
   val orb: Word16.word * Word16.word -> Word16.word = 
      fn x_270: Word16.word * Word16.word => 
      let
	 val x_271: Word16.word = 
	    #1 x_270
	 val x_272: Word16.word = 
	    #0 x_270
	 val x_273: Word16.word = 
	    Word16_orb (x_272, x_271)
      in
	 x_273
      end
   val >>?: Word16.word * word -> Word16.word = 
      fn x_274: Word16.word * word => 
      let
	 val x_275: word = 
	    #1 x_274
	 val x_276: Word16.word = 
	    #0 x_274
	 val x_277: Word16.word = 
	    WordU16_rshift (x_276, x_275)
      in
	 x_277
      end
   val sizeInBits: word = 
      0x11
   val sizeInBits: word = 
      0x12
   val sizeInBits: word = 
      0x13
   val sizeInBits: word = 
      0x14
   val sizeInBits: word = 
      0x15
   val sizeInBits: word = 
      0x16
   val sizeInBits: word = 
      0x17
   val sizeInBits: word = 
      0x18
   val sizeInBits: word = 
      0x19
   val sizeInBits: word = 
      0x1A
   val sizeInBits: word = 
      0x1B
   val sizeInBits: word = 
      0x1C
   val sizeInBits: word = 
      0x1D
   val sizeInBits: word = 
      0x1E
   val sizeInBits: word = 
      0x1F
   val sizeInBits: word = 
      0x20
   val sizeInBitsWord: word = 
      zextdFromInt32ToWord32 sizeInBits
   val andb: word * word -> word = 
      fn x_278: word * word => 
      let
	 val x_279: word = 
	    #1 x_278
	 val x_280: word = 
	    #0 x_278
	 val x_281: word = 
	    Word32_andb (x_280, x_279)
      in
	 x_281
      end
   val <<?: word * word -> word = 
      fn x_282: word * word => 
      let
	 val x_283: word = 
	    #1 x_282
	 val x_284: word = 
	    #0 x_282
	 val x_285: word = 
	    Word32_lshift (x_284, x_283)
      in
	 x_285
      end
   val notb: word -> word = 
      fn x_286: word => 
      let
	 val x_287: word = 
	    Word32_notb (x_286)
      in
	 x_287
      end
   val orb: word * word -> word = 
      fn x_288: word * word => 
      let
	 val x_289: word = 
	    #1 x_288
	 val x_290: word = 
	    #0 x_288
	 val x_291: word = 
	    Word32_orb (x_290, x_289)
      in
	 x_291
      end
   val >>?: word * word -> word = 
      fn x_292: word * word => 
      let
	 val x_293: word = 
	    #1 x_292
	 val x_294: word = 
	    #0 x_292
	 val x_295: word = 
	    WordU32_rshift (x_294, x_293)
      in
	 x_295
      end
   val -: word * word -> word = 
      fn x_296: word * word => 
      let
	 val x_297: word = 
	    #1 x_296
	 val x_298: word = 
	    #0 x_296
	 val x_299: word = 
	    Word32_sub (x_298, x_297)
      in
	 x_299
      end
   val xorb: word * word -> word = 
      fn x_300: word * word => 
      let
	 val x_301: word = 
	    #1 x_300
	 val x_302: word = 
	    #0 x_300
	 val x_303: word = 
	    Word32_xorb (x_302, x_301)
      in
	 x_303
      end
   val <: word * word -> bool = 
      fn x_304: word * word => 
      let
	 val x_305: word = 
	    #1 x_304
	 val x_306: word = 
	    #0 x_304
	 val x_307: bool = 
	    WordU32_lt (x_306, x_305)
      in
	 x_307
      end
   val rec 
      >=: word * word -> bool = 
	 fn x_308: word * word => 
	 let
	    val b: word = 
	       #1 x_308
	    val a: word = 
	       #0 x_308
	    val x_309: word * word = 
	       (a, b)
	    val x_310: bool = 
	       < x_309
	    val x_311: bool = 
	       not x_310
	 in
	    x_311
	 end
   val sizeInBits: word = 
      0x40
   val sizeInBitsWord: word = 
      zextdFromInt32ToWord32 sizeInBits
   val +: Word64.word * Word64.word -> Word64.word = 
      fn x_312: Word64.word * Word64.word => 
      let
	 val x_313: Word64.word = 
	    #1 x_312
	 val x_314: Word64.word = 
	    #0 x_312
	 val x_315: Word64.word = 
	    Word64_add (x_314, x_313)
      in
	 x_315
      end
   val andb: Word64.word * Word64.word -> Word64.word = 
      fn x_316: Word64.word * Word64.word => 
      let
	 val x_317: Word64.word = 
	    #1 x_316
	 val x_318: Word64.word = 
	    #0 x_316
	 val x_319: Word64.word = 
	    Word64_andb (x_318, x_317)
      in
	 x_319
      end
   val <<?: Word64.word * word -> Word64.word = 
      fn x_320: Word64.word * word => 
      let
	 val x_321: word = 
	    #1 x_320
	 val x_322: Word64.word = 
	    #0 x_320
	 val x_323: Word64.word = 
	    Word64_lshift (x_322, x_321)
      in
	 x_323
      end
   val *: Word64.word * Word64.word -> Word64.word = 
      fn x_324: Word64.word * Word64.word => 
      let
	 val x_325: Word64.word = 
	    #1 x_324
	 val x_326: Word64.word = 
	    #0 x_324
	 val x_327: Word64.word = 
	    WordU64_mul (x_326, x_325)
      in
	 x_327
      end
   val ~: Word64.word -> Word64.word = 
      fn x_328: Word64.word => 
      let
	 val x_329: Word64.word = 
	    Word64_neg (x_328)
      in
	 x_329
      end
   val notb: Word64.word -> Word64.word = 
      fn x_330: Word64.word => 
      let
	 val x_331: Word64.word = 
	    Word64_notb (x_330)
      in
	 x_331
      end
   val orb: Word64.word * Word64.word -> Word64.word = 
      fn x_332: Word64.word * Word64.word => 
      let
	 val x_333: Word64.word = 
	    #1 x_332
	 val x_334: Word64.word = 
	    #0 x_332
	 val x_335: Word64.word = 
	    Word64_orb (x_334, x_333)
      in
	 x_335
      end
   val ~>>?: Word64.word * word -> Word64.word = 
      fn x_336: Word64.word * word => 
      let
	 val x_337: word = 
	    #1 x_336
	 val x_338: Word64.word = 
	    #0 x_336
	 val x_339: Word64.word = 
	    WordS64_rshift (x_338, x_337)
      in
	 x_339
      end
   val >>?: Word64.word * word -> Word64.word = 
      fn x_340: Word64.word * word => 
      let
	 val x_341: word = 
	    #1 x_340
	 val x_342: Word64.word = 
	    #0 x_340
	 val x_343: Word64.word = 
	    WordU64_rshift (x_342, x_341)
      in
	 x_343
      end
   val -: Word64.word * Word64.word -> Word64.word = 
      fn x_344: Word64.word * Word64.word => 
      let
	 val x_345: Word64.word = 
	    #1 x_344
	 val x_346: Word64.word = 
	    #0 x_344
	 val x_347: Word64.word = 
	    Word64_sub (x_346, x_345)
      in
	 x_347
      end
   val sizeInBits: word = 
      0x1
   val sizeInBits: word = 
      0x2
   val sizeInBits: word = 
      0x3
   val sizeInBits: word = 
      0x4
   val sizeInBits: word = 
      0x5
   val sizeInBits: word = 
      0x6
   val sizeInBits: word = 
      0x7
   val sizeInBits: word = 
      0x8
   val sizeInBitsWord: word = 
      zextdFromInt32ToWord32 sizeInBits
   val precision: word option = 
      SOME[word] sizeInBits
   val sizeInBits: word = 
      0x9
   val sizeInBits: word = 
      0xA
   val sizeInBits: word = 
      0xB
   val sizeInBits: word = 
      0xC
   val sizeInBits: word = 
      0xD
   val sizeInBits: word = 
      0xE
   val sizeInBits: word = 
      0xF
   val sizeInBits: word = 
      0x10
   val sizeInBitsWord: word = 
      zextdFromInt32ToWord32 sizeInBits
   val precision: word option = 
      SOME[word] sizeInBits
   val sizeInBits: word = 
      0x11
   val sizeInBits: word = 
      0x12
   val sizeInBits: word = 
      0x13
   val sizeInBits: word = 
      0x14
   val sizeInBits: word = 
      0x15
   val sizeInBits: word = 
      0x16
   val sizeInBits: word = 
      0x17
   val sizeInBits: word = 
      0x18
   val sizeInBits: word = 
      0x19
   val sizeInBits: word = 
      0x1A
   val sizeInBits: word = 
      0x1B
   val sizeInBits: word = 
      0x1C
   val sizeInBits: word = 
      0x1D
   val sizeInBits: word = 
      0x1E
   val sizeInBits: word = 
      0x1F
   val sizeInBits: word = 
      0x20
   val sizeInBitsWord: word = 
      zextdFromInt32ToWord32 sizeInBits
   val precision: word option = 
      SOME[word] sizeInBits
   val x_348: word * word -> word = 
      fn x_349: word * word => 
      let
	 val x_350: word = 
	    #1 x_349
	 val x_351: word = 
	    #0 x_349
	 val x_352: word = 
	    WordS32_addCheck (x_351, x_350)
      in
	 x_352
      end
   val +!: word * word -> word = 
      wrapOverflow (word, word * word) x_348
   val +?: word * word -> word = 
      fn x_353: word * word => 
      let
	 val x_354: word = 
	    #1 x_353
	 val x_355: word = 
	    #0 x_353
	 val x_356: word = 
	    Word32_add (x_355, x_354)
      in
	 x_356
      end
   val x_357: word * word -> word = 
      fn x_358: word * word => 
      let
	 val x_359: word = 
	    #1 x_358
	 val x_360: word = 
	    #0 x_358
	 val x_361: word = 
	    WordS32_mulCheck (x_360, x_359)
      in
	 x_361
      end
   val *!: word * word -> word = 
      wrapOverflow (word, word * word) x_357
   val x_362: word -> word = 
      fn x_363: word => 
      let
	 val x_364: word = 
	    Word32_negCheck (x_363)
      in
	 x_364
      end
   val ~!: word -> word = 
      wrapOverflow (word, word) x_362
   val ~?: word -> word = 
      fn x_365: word => 
      let
	 val x_366: word = 
	    Word32_neg (x_365)
      in
	 x_366
      end
   val x_367: word * word -> word = 
      fn x_368: word * word => 
      let
	 val x_369: word = 
	    #1 x_368
	 val x_370: word = 
	    #0 x_368
	 val x_371: word = 
	    WordS32_subCheck (x_370, x_369)
      in
	 x_371
      end
   val -!: word * word -> word = 
      wrapOverflow (word, word * word) x_367
   val -?: word * word -> word = 
      fn x_372: word * word => 
      let
	 val x_373: word = 
	    #1 x_372
	 val x_374: word = 
	    #0 x_372
	 val x_375: word = 
	    Word32_sub (x_374, x_373)
      in
	 x_375
      end
   val remUnsafe: word * word -> word = 
      fn x_376: word * word => 
      let
	 val x_377: word = 
	    #1 x_376
	 val x_378: word = 
	    #0 x_376
	 val x_379: word = 
	    WordS32_rem (x_378, x_377)
      in
	 x_379
      end
   val <: word * word -> bool = 
      fn x_380: word * word => 
      let
	 val x_381: word = 
	    #1 x_380
	 val x_382: word = 
	    #0 x_380
	 val x_383: bool = 
	    WordS32_lt (x_382, x_381)
      in
	 x_383
      end
   val rec 
      <=: word * word -> bool = 
	 fn x_384: word * word => 
	 let
	    val b: word = 
	       #1 x_384
	    val a: word = 
	       #0 x_384
	    val x_385: word * word = 
	       (b, a)
	    val x_386: bool = 
	       < x_385
	    val x_387: bool = 
	       not x_386
	 in
	    x_387
	 end
   val rec 
      >: word * word -> bool = 
	 fn x_388: word * word => 
	 let
	    val b: word = 
	       #1 x_388
	    val a: word = 
	       #0 x_388
	    val x_389: word * word = 
	       (b, a)
	    val x_390: bool = 
	       < x_389
	 in
	    x_390
	 end
   val rec 
      >=: word * word -> bool = 
	 fn x_391: word * word => 
	 let
	    val b: word = 
	       #1 x_391
	    val a: word = 
	       #0 x_391
	    val x_392: word * word = 
	       (b, a)
	    val x_393: bool = 
	       <= x_392
	 in
	    x_393
	 end
   val sizeInBits: word = 
      0x40
   val sizeInBitsWord: word = 
      zextdFromInt32ToWord32 sizeInBits
   val precision: word option = 
      SOME[word] sizeInBits
   val x_394: Word64.word * Word64.word -> Word64.word = 
      fn x_395: Word64.word * Word64.word => 
      let
	 val x_396: Word64.word = 
	    #1 x_395
	 val x_397: Word64.word = 
	    #0 x_395
	 val x_398: Word64.word = 
	    WordS64_addCheck (x_397, x_396)
      in
	 x_398
      end
   val +!: Word64.word * Word64.word -> Word64.word = 
      wrapOverflow (Word64.word, Word64.word * Word64.word) x_394
   val +?: Word64.word * Word64.word -> Word64.word = 
      fn x_399: Word64.word * Word64.word => 
      let
	 val x_400: Word64.word = 
	    #1 x_399
	 val x_401: Word64.word = 
	    #0 x_399
	 val x_402: Word64.word = 
	    Word64_add (x_401, x_400)
      in
	 x_402
      end
   val x_403: Word64.word * Word64.word -> Word64.word = 
      fn x_404: Word64.word * Word64.word => 
      let
	 val x_405: Word64.word = 
	    #1 x_404
	 val x_406: Word64.word = 
	    #0 x_404
	 val x_407: Word64.word = 
	    WordS64_mulCheck (x_406, x_405)
      in
	 x_407
      end
   val *!: Word64.word * Word64.word -> Word64.word = 
      wrapOverflow (Word64.word, Word64.word * Word64.word) x_403
   val x_408: Word64.word -> Word64.word = 
      fn x_409: Word64.word => 
      let
	 val x_410: Word64.word = 
	    Word64_negCheck (x_409)
      in
	 x_410
      end
   val ~!: Word64.word -> Word64.word = 
      wrapOverflow (Word64.word, Word64.word) x_408
   val ~?: Word64.word -> Word64.word = 
      fn x_411: Word64.word => 
      let
	 val x_412: Word64.word = 
	    Word64_neg (x_411)
      in
	 x_412
      end
   val x_413: Word64.word * Word64.word -> Word64.word = 
      fn x_414: Word64.word * Word64.word => 
      let
	 val x_415: Word64.word = 
	    #1 x_414
	 val x_416: Word64.word = 
	    #0 x_414
	 val x_417: Word64.word = 
	    WordS64_subCheck (x_416, x_415)
      in
	 x_417
      end
   val -!: Word64.word * Word64.word -> Word64.word = 
      wrapOverflow (Word64.word, Word64.word * Word64.word) x_413
   val -?: Word64.word * Word64.word -> Word64.word = 
      fn x_418: Word64.word * Word64.word => 
      let
	 val x_419: Word64.word = 
	    #1 x_418
	 val x_420: Word64.word = 
	    #0 x_418
	 val x_421: Word64.word = 
	    Word64_sub (x_420, x_419)
      in
	 x_421
      end
   val <: Word64.word * Word64.word -> bool = 
      fn x_422: Word64.word * Word64.word => 
      let
	 val x_423: Word64.word = 
	    #1 x_422
	 val x_424: Word64.word = 
	    #0 x_422
	 val x_425: bool = 
	    WordS64_lt (x_424, x_423)
      in
	 x_425
      end
   val rec 
      <=: Word64.word * Word64.word -> bool = 
	 fn x_426: Word64.word * Word64.word => 
	 let
	    val b: Word64.word = 
	       #1 x_426
	    val a: Word64.word = 
	       #0 x_426
	    val x_427: Word64.word * Word64.word = 
	       (b, a)
	    val x_428: bool = 
	       < x_427
	    val x_429: bool = 
	       not x_428
	 in
	    x_429
	 end
   val rec 
      >: Word64.word * Word64.word -> bool = 
	 fn x_430: Word64.word * Word64.word => 
	 let
	    val b: Word64.word = 
	       #1 x_430
	    val a: Word64.word = 
	       #0 x_430
	    val x_431: Word64.word * Word64.word = 
	       (b, a)
	    val x_432: bool = 
	       < x_431
	 in
	    x_432
	 end
   val rec 
      >=: Word64.word * Word64.word -> bool = 
	 fn x_433: Word64.word * Word64.word => 
	 let
	    val b: Word64.word = 
	       #1 x_433
	    val a: Word64.word = 
	       #0 x_433
	    val x_434: Word64.word * Word64.word = 
	       (b, a)
	    val x_435: bool = 
	       <= x_434
	 in
	    x_435
	 end
   val rec 
      max: Word64.word * Word64.word -> Word64.word = 
	 fn x_436: Word64.word * Word64.word => 
	 let
	    val y: Word64.word = 
	       #1 x_436
	    val x: Word64.word = 
	       #0 x_436
	    val x_437: Word64.word * Word64.word = 
	       (x, y)
	    val x_438: bool = 
	       < x_437
	    val x_439: Word64.word = 
	       case x_438 of
	       true => 
		  let
		  in
		     y
		  end
	       false => 
		  let
		  in
		     x
		  end
	 in
	    x_439
	 end
   val 'a arrayUnsafe: Word64.word -> 'a array = 
      let
	 val x_440: Word64.word -> 'a array = 
	    fn x_441: Word64.word => 
	    let
	       val x_442: 'a array = 
		  Array_array['a] (x_441)
	    in
	       x_442
	    end
      in
	 x_440
      end
   val 'a array0Const: unit -> 'a array = 
      let
	 val x_443: unit -> 'a array = 
	    fn x_444: unit => 
	    let
	       val x_445: 'a array = 
		  Array_array0Const['a] ()
	    in
	       x_445
	    end
      in
	 x_443
      end
   val 'a length: 'a array -> Word64.word = 
      let
	 val x_446: 'a array -> Word64.word = 
	    fn x_447: 'a array => 
	    let
	       val x_448: Word64.word = 
		  Array_length['a] (x_447)
	    in
	       x_448
	    end
      in
	 x_446
      end
   val 'a subUnsafe: 'a array * Word64.word -> 'a = 
      let
	 val x_449: 'a array * Word64.word -> 'a = 
	    fn x_450: 'a array * Word64.word => 
	    let
	       val x_451: Word64.word = 
		  #1 x_450
	       val x_452: 'a array = 
		  #0 x_450
	       val x_453: 'a = 
		  Array_sub['a] (x_452, x_451)
	    in
	       x_453
	    end
      in
	 x_449
      end
   val 'a updateUnsafe: 'a array * Word64.word * 'a -> unit = 
      let
	 val x_454: 'a array * Word64.word * 'a -> unit = 
	    fn x_455: 'a array * Word64.word * 'a => 
	    let
	       val x_456: 'a = 
		  #2 x_455
	       val x_457: Word64.word = 
		  #1 x_455
	       val x_458: 'a array = 
		  #0 x_455
	       val x_459: unit = 
		  Array_update['a] (x_458, x_457, x_456)
	    in
	       x_459
	    end
      in
	 x_454
      end
   val 'a fromArrayUnsafe: 'a array -> 'a vector = 
      let
	 val x_460: 'a array -> 'a vector = 
	    fn x_461: 'a array => 
	    let
	       val x_462: 'a vector = 
		  Array_toVector['a] (x_461)
	    in
	       x_462
	    end
      in
	 x_460
      end
   val 'a length: 'a vector -> Word64.word = 
      let
	 val x_463: 'a vector -> Word64.word = 
	    fn x_464: 'a vector => 
	    let
	       val x_465: Word64.word = 
		  Vector_length['a] (x_464)
	    in
	       x_465
	    end
      in
	 x_463
      end
   val 'a subUnsafe: 'a vector * Word64.word -> 'a = 
      let
	 val x_466: 'a vector * Word64.word -> 'a = 
	    fn x_467: 'a vector * Word64.word => 
	    let
	       val x_468: Word64.word = 
		  #1 x_467
	       val x_469: 'a vector = 
		  #0 x_467
	       val x_470: 'a = 
		  Vector_sub['a] (x_469, x_468)
	    in
	       x_470
	    end
      in
	 x_466
      end
   val rec 
      fromString: Word8.word vector -> Word8.word vector = 
	 fn x_471: Word8.word vector => 
	 let
	    val x_472: Word8.word = 
	       0x0
	    val x_473: Word64.word = 
	       length (Word8.word) x_471
	    val x_474: Word64.word = 
	       0x1
	    val x_475: Word64.word * Word64.word = 
	       (x_473, x_474)
	    val x_476: Word64.word = 
	       -! x_475
	    val x_477: Word8.word vector * Word64.word = 
	       (x_471, x_476)
	    val x_478: Word8.word = 
	       subUnsafe (Word8.word) x_477
	    val x_479: Word8.word * Word8.word = 
	       (x_472, x_478)
	    val x_480: bool = 
	       = (Word8.word) x_479
	    val x_481: Word8.word vector = 
	       case x_480 of
	       true => 
		  let
		  in
		     x_471
		  end
	       false => 
		  let
		     val x_482: Word8.word vector = 
			"NullString.fromString"
		     val x_483: exn = 
			Fail8 x_482
		     val x_484: Word8.word vector = 
			raise x_483
		  in
		     x_484
		  end
	 in
	    x_481
	 end
   val +: IntInf.int * IntInf.int * Word64.word -> IntInf.int = 
      fn x_485: IntInf.int * IntInf.int * Word64.word => 
      let
	 val x_486: Word64.word = 
	    #2 x_485
	 val x_487: IntInf.int = 
	    #1 x_485
	 val x_488: IntInf.int = 
	    #0 x_485
	 val x_489: IntInf.int = 
	    IntInf_add (x_488, x_487, x_486)
      in
	 x_489
      end
   val fromWord: Word64.word -> IntInf.int = 
      fn x_490: Word64.word => 
      let
	 val x_491: IntInf.int = 
	    Word_toIntInf (x_490)
      in
	 x_491
      end
   val *: IntInf.int * IntInf.int * Word64.word -> IntInf.int = 
      fn x_492: IntInf.int * IntInf.int * Word64.word => 
      let
	 val x_493: Word64.word = 
	    #2 x_492
	 val x_494: IntInf.int = 
	    #1 x_492
	 val x_495: IntInf.int = 
	    #0 x_492
	 val x_496: IntInf.int = 
	    IntInf_mul (x_495, x_494, x_493)
      in
	 x_496
      end
   val toVector: IntInf.int -> Word64.word vector = 
      fn x_497: IntInf.int => 
      let
	 val x_498: Word64.word vector = 
	    IntInf_toVector (x_497)
      in
	 x_498
      end
   val toWord: IntInf.int -> Word64.word = 
      fn x_499: IntInf.int => 
      let
	 val x_500: Word64.word = 
	    IntInf_toWord (x_499)
      in
	 x_500
      end
   val idToWord8: Word8.word -> Word8.word = 
      fn x_501: Word8.word => 
      let
      in
	 x_501
      end
   val idFromWord8: Word8.word -> Word8.word = 
      fn x_502: Word8.word => 
      let
      in
	 x_502
      end
   val rec 
      <=: Word8.word * Word8.word -> bool = 
	 fn x_503: Word8.word * Word8.word => 
	 let
	    val b: Word8.word = 
	       #1 x_503
	    val a: Word8.word = 
	       #0 x_503
	    val x_504: bool = 
	       WordU8_lt (b, a)
	    val x_505: bool = 
	       not x_504
	 in
	    x_505
	 end
   val idToWord16: Word16.word -> Word16.word = 
      fn x_506: Word16.word => 
      let
      in
	 x_506
      end
   val idFromWord16: Word16.word -> Word16.word = 
      fn x_507: Word16.word => 
      let
      in
	 x_507
      end
   val idToWord32: word -> word = 
      fn x_508: word => 
      let
      in
	 x_508
      end
   val idFromWord32: word -> word = 
      fn x_509: word => 
      let
      in
	 x_509
      end
   val realSize: word = 
      0x20
   val exponentBias: word = 
      0x7F
   val precision: word = 
      0x18
   val acos: Real32.real -> Real32.real = 
      fn x_510: Real32.real => 
      let
	 val x_511: Real32.real = 
	    Real32_Math_acos (x_510)
      in
	 x_511
      end
   val asin: Real32.real -> Real32.real = 
      fn x_512: Real32.real => 
      let
	 val x_513: Real32.real = 
	    Real32_Math_asin (x_512)
      in
	 x_513
      end
   val atan: Real32.real -> Real32.real = 
      fn x_514: Real32.real => 
      let
	 val x_515: Real32.real = 
	    Real32_Math_atan (x_514)
      in
	 x_515
      end
   val atan2: Real32.real * Real32.real -> Real32.real = 
      fn x_516: Real32.real * Real32.real => 
      let
	 val x_517: Real32.real = 
	    #1 x_516
	 val x_518: Real32.real = 
	    #0 x_516
	 val x_519: Real32.real = 
	    Real32_Math_atan2 (x_518, x_517)
      in
	 x_519
      end
   val cos: Real32.real -> Real32.real = 
      fn x_520: Real32.real => 
      let
	 val x_521: Real32.real = 
	    Real32_Math_cos (x_520)
      in
	 x_521
      end
   val cosh: Real32.real -> Real32.real = 
      fn x_522: Real32.real => 
      let
	 val x_523: Real32.real = 
	    Real32_Math_cosh (x_522)
      in
	 x_523
      end
   val x_524: MLton.Pointer.t = 
      Real32_Math_e ()
   val x_525: Word64.word = 
      0x0
   val x_526: Real32.real = 
      CPointer_getReal32 (x_524, x_525)
   val exp: Real32.real -> Real32.real = 
      fn x_527: Real32.real => 
      let
	 val x_528: Real32.real = 
	    Real32_Math_exp (x_527)
      in
	 x_528
      end
   val ln: Real32.real -> Real32.real = 
      fn x_529: Real32.real => 
      let
	 val x_530: Real32.real = 
	    Real32_Math_ln (x_529)
      in
	 x_530
      end
   val log10: Real32.real -> Real32.real = 
      fn x_531: Real32.real => 
      let
	 val x_532: Real32.real = 
	    Real32_Math_log10 (x_531)
      in
	 x_532
      end
   val x_533: MLton.Pointer.t = 
      Real32_Math_pi ()
   val x_534: Word64.word = 
      0x0
   val x_535: Real32.real = 
      CPointer_getReal32 (x_533, x_534)
   val pow: Real32.real * Real32.real -> Real32.real = 
      fn x_536: Real32.real * Real32.real => 
      let
	 val x_537: Real32.real = 
	    #1 x_536
	 val x_538: Real32.real = 
	    #0 x_536
	 val x_539: Real32.real = 
	    Real32_Math_pow (x_538, x_537)
      in
	 x_539
      end
   val sin: Real32.real -> Real32.real = 
      fn x_540: Real32.real => 
      let
	 val x_541: Real32.real = 
	    Real32_Math_sin (x_540)
      in
	 x_541
      end
   val sinh: Real32.real -> Real32.real = 
      fn x_542: Real32.real => 
      let
	 val x_543: Real32.real = 
	    Real32_Math_sinh (x_542)
      in
	 x_543
      end
   val sqrt: Real32.real -> Real32.real = 
      fn x_544: Real32.real => 
      let
	 val x_545: Real32.real = 
	    Real32_Math_sqrt (x_544)
      in
	 x_545
      end
   val tan: Real32.real -> Real32.real = 
      fn x_546: Real32.real => 
      let
	 val x_547: Real32.real = 
	    Real32_Math_tan (x_546)
      in
	 x_547
      end
   val tanh: Real32.real -> Real32.real = 
      fn x_548: Real32.real => 
      let
	 val x_549: Real32.real = 
	    Real32_Math_tanh (x_548)
      in
	 x_549
      end
   val *: Real32.real * Real32.real -> Real32.real = 
      fn x_550: Real32.real * Real32.real => 
      let
	 val x_551: Real32.real = 
	    #1 x_550
	 val x_552: Real32.real = 
	    #0 x_550
	 val x_553: Real32.real = 
	    Real32_mul (x_552, x_551)
      in
	 x_553
      end
   val *+: Real32.real * Real32.real * Real32.real -> Real32.real = 
      fn x_554: Real32.real * Real32.real * Real32.real => 
      let
	 val x_555: Real32.real = 
	    #2 x_554
	 val x_556: Real32.real = 
	    #1 x_554
	 val x_557: Real32.real = 
	    #0 x_554
	 val x_558: Real32.real = 
	    Real32_muladd (x_557, x_556, x_555)
      in
	 x_558
      end
   val *-: Real32.real * Real32.real * Real32.real -> Real32.real = 
      fn x_559: Real32.real * Real32.real * Real32.real => 
      let
	 val x_560: Real32.real = 
	    #2 x_559
	 val x_561: Real32.real = 
	    #1 x_559
	 val x_562: Real32.real = 
	    #0 x_559
	 val x_563: Real32.real = 
	    Real32_mulsub (x_562, x_561, x_560)
      in
	 x_563
      end
   val +: Real32.real * Real32.real -> Real32.real = 
      fn x_564: Real32.real * Real32.real => 
      let
	 val x_565: Real32.real = 
	    #1 x_564
	 val x_566: Real32.real = 
	    #0 x_564
	 val x_567: Real32.real = 
	    Real32_add (x_566, x_565)
      in
	 x_567
      end
   val -: Real32.real * Real32.real -> Real32.real = 
      fn x_568: Real32.real * Real32.real => 
      let
	 val x_569: Real32.real = 
	    #1 x_568
	 val x_570: Real32.real = 
	    #0 x_568
	 val x_571: Real32.real = 
	    Real32_sub (x_570, x_569)
      in
	 x_571
      end
   val /: Real32.real * Real32.real -> Real32.real = 
      fn x_572: Real32.real * Real32.real => 
      let
	 val x_573: Real32.real = 
	    #1 x_572
	 val x_574: Real32.real = 
	    #0 x_572
	 val x_575: Real32.real = 
	    Real32_div (x_574, x_573)
      in
	 x_575
      end
   val ~: Real32.real -> Real32.real = 
      fn x_576: Real32.real => 
      let
	 val x_577: Real32.real = 
	    Real32_neg (x_576)
      in
	 x_577
      end
   val <: Real32.real * Real32.real -> bool = 
      fn x_578: Real32.real * Real32.real => 
      let
	 val x_579: Real32.real = 
	    #1 x_578
	 val x_580: Real32.real = 
	    #0 x_578
	 val x_581: bool = 
	    Real32_lt (x_580, x_579)
      in
	 x_581
      end
   val <=: Real32.real * Real32.real -> bool = 
      fn x_582: Real32.real * Real32.real => 
      let
	 val x_583: Real32.real = 
	    #1 x_582
	 val x_584: Real32.real = 
	    #0 x_582
	 val x_585: bool = 
	    Real32_le (x_584, x_583)
      in
	 x_585
      end
   val ==: Real32.real * Real32.real -> bool = 
      fn x_586: Real32.real * Real32.real => 
      let
	 val x_587: Real32.real = 
	    #1 x_586
	 val x_588: Real32.real = 
	    #0 x_586
	 val x_589: bool = 
	    Real32_equal (x_588, x_587)
      in
	 x_589
      end
   val abs: Real32.real -> Real32.real = 
      fn x_590: Real32.real => 
      let
	 val x_591: Real32.real = 
	    Real32_abs (x_590)
      in
	 x_591
      end
   val frexp: Real32.real * word ref -> Real32.real = 
      fn x_592: Real32.real * word ref => 
      let
	 val x_593: word ref = 
	    #1 x_592
	 val x_594: Real32.real = 
	    #0 x_592
	 val x_595: Real32.real = 
	    Real32_frexp (x_594, x_593)
      in
	 x_595
      end
   val gdtoa: Real32.real * word * word * word * word ref -> Word64.word = 
      fn x_596: Real32.real * word * word * word * word ref => 
      let
	 val x_597: word ref = 
	    #4 x_596
	 val x_598: word = 
	    #3 x_596
	 val x_599: word = 
	    #2 x_596
	 val x_600: word = 
	    #1 x_596
	 val x_601: Real32.real = 
	    #0 x_596
	 val x_602: Word64.word = 
	    Real32_gdtoa (x_601, x_600, x_599, x_598, x_597)
      in
	 x_602
      end
   val ldexp: Real32.real * word -> Real32.real = 
      fn x_603: Real32.real * word => 
      let
	 val x_604: word = 
	    #1 x_603
	 val x_605: Real32.real = 
	    #0 x_603
	 val x_606: Real32.real = 
	    Real32_ldexp (x_605, x_604)
      in
	 x_606
      end
   val modf: Real32.real * Real32.real ref -> Real32.real = 
      fn x_607: Real32.real * Real32.real ref => 
      let
	 val x_608: Real32.real ref = 
	    #1 x_607
	 val x_609: Real32.real = 
	    #0 x_607
	 val x_610: Real32.real = 
	    Real32_modf (x_609, x_608)
      in
	 x_610
      end
   val round: Real32.real -> Real32.real = 
      fn x_611: Real32.real => 
      let
	 val x_612: Real32.real = 
	    Real32_round (x_611)
      in
	 x_612
      end
   val strto: Word8.word vector * word -> Real32.real = 
      fn x_613: Word8.word vector * word => 
      let
	 val x_614: word = 
	    #1 x_613
	 val x_615: Word8.word vector = 
	    #0 x_613
	 val x_616: Real32.real = 
	    Real32_strto (x_615, x_614)
      in
	 x_616
      end
   val fromInt8Unsafe: Word8.word -> Real32.real = 
      fn x_617: Word8.word => 
      let
	 val x_618: Real32.real = 
	    WordS8_rndToReal32 (x_617)
      in
	 x_618
      end
   val fromInt16Unsafe: Word16.word -> Real32.real = 
      fn x_619: Word16.word => 
      let
	 val x_620: Real32.real = 
	    WordS16_rndToReal32 (x_619)
      in
	 x_620
      end
   val fromInt32Unsafe: word -> Real32.real = 
      fn x_621: word => 
      let
	 val x_622: Real32.real = 
	    WordS32_rndToReal32 (x_621)
      in
	 x_622
      end
   val fromInt64Unsafe: Word64.word -> Real32.real = 
      fn x_623: Word64.word => 
      let
	 val x_624: Real32.real = 
	    WordS64_rndToReal32 (x_623)
      in
	 x_624
      end
   val fromReal32Unsafe: Real32.real -> Real32.real = 
      fn x_625: Real32.real => 
      let
      in
	 x_625
      end
   val fromWord8Unsafe: Word8.word -> Real32.real = 
      fn x_626: Word8.word => 
      let
	 val x_627: Real32.real = 
	    WordU8_rndToReal32 (x_626)
      in
	 x_627
      end
   val fromWord16Unsafe: Word16.word -> Real32.real = 
      fn x_628: Word16.word => 
      let
	 val x_629: Real32.real = 
	    WordU16_rndToReal32 (x_628)
      in
	 x_629
      end
   val fromWord32Unsafe: word -> Real32.real = 
      fn x_630: word => 
      let
	 val x_631: Real32.real = 
	    WordU32_rndToReal32 (x_630)
      in
	 x_631
      end
   val fromWord64Unsafe: Word64.word -> Real32.real = 
      fn x_632: Word64.word => 
      let
	 val x_633: Real32.real = 
	    WordU64_rndToReal32 (x_632)
      in
	 x_633
      end
   val toInt8Unsafe: Real32.real -> Word8.word = 
      fn x_634: Real32.real => 
      let
	 val x_635: Word8.word = 
	    Real32_rndToWordS8 (x_634)
      in
	 x_635
      end
   val toInt16Unsafe: Real32.real -> Word16.word = 
      fn x_636: Real32.real => 
      let
	 val x_637: Word16.word = 
	    Real32_rndToWordS16 (x_636)
      in
	 x_637
      end
   val toInt32Unsafe: Real32.real -> word = 
      fn x_638: Real32.real => 
      let
	 val x_639: word = 
	    Real32_rndToWordS32 (x_638)
      in
	 x_639
      end
   val toInt64Unsafe: Real32.real -> Word64.word = 
      fn x_640: Real32.real => 
      let
	 val x_641: Word64.word = 
	    Real32_rndToWordS64 (x_640)
      in
	 x_641
      end
   val toReal32Unsafe: Real32.real -> Real32.real = 
      fn x_642: Real32.real => 
      let
      in
	 x_642
      end
   val toWord8Unsafe: Real32.real -> Word8.word = 
      fn x_643: Real32.real => 
      let
	 val x_644: Word8.word = 
	    Real32_rndToWordU8 (x_643)
      in
	 x_644
      end
   val toWord16Unsafe: Real32.real -> Word16.word = 
      fn x_645: Real32.real => 
      let
	 val x_646: Word16.word = 
	    Real32_rndToWordU16 (x_645)
      in
	 x_646
      end
   val toWord32Unsafe: Real32.real -> word = 
      fn x_647: Real32.real => 
      let
	 val x_648: word = 
	    Real32_rndToWordU32 (x_647)
      in
	 x_648
      end
   val toWord64Unsafe: Real32.real -> Word64.word = 
      fn x_649: Real32.real => 
      let
	 val x_650: Word64.word = 
	    Real32_rndToWordU64 (x_649)
      in
	 x_650
      end
   val rec 
      >: Real32.real * Real32.real -> bool = 
	 fn x_651: Real32.real * Real32.real => 
	 let
	    val b: Real32.real = 
	       #1 x_651
	    val a: Real32.real = 
	       #0 x_651
	    val x_652: Real32.real * Real32.real = 
	       (b, a)
	    val x_653: bool = 
	       < x_652
	 in
	    x_653
	 end
   val rec 
      >=: Real32.real * Real32.real -> bool = 
	 fn x_654: Real32.real * Real32.real => 
	 let
	    val b: Real32.real = 
	       #1 x_654
	    val a: Real32.real = 
	       #0 x_654
	    val x_655: Real32.real * Real32.real = 
	       (b, a)
	    val x_656: bool = 
	       <= x_655
	 in
	    x_656
	 end
   val realSize: word = 
      0x40
   val exponentBias: word = 
      0x3FF
   val precision: word = 
      0x35
   val acos: real -> real = 
      fn x_657: real => 
      let
	 val x_658: real = 
	    Real64_Math_acos (x_657)
      in
	 x_658
      end
   val asin: real -> real = 
      fn x_659: real => 
      let
	 val x_660: real = 
	    Real64_Math_asin (x_659)
      in
	 x_660
      end
   val atan: real -> real = 
      fn x_661: real => 
      let
	 val x_662: real = 
	    Real64_Math_atan (x_661)
      in
	 x_662
      end
   val atan2: real * real -> real = 
      fn x_663: real * real => 
      let
	 val x_664: real = 
	    #1 x_663
	 val x_665: real = 
	    #0 x_663
	 val x_666: real = 
	    Real64_Math_atan2 (x_665, x_664)
      in
	 x_666
      end
   val cos: real -> real = 
      fn x_667: real => 
      let
	 val x_668: real = 
	    Real64_Math_cos (x_667)
      in
	 x_668
      end
   val cosh: real -> real = 
      fn x_669: real => 
      let
	 val x_670: real = 
	    Real64_Math_cosh (x_669)
      in
	 x_670
      end
   val x_671: MLton.Pointer.t = 
      Real64_Math_e ()
   val x_672: Word64.word = 
      0x0
   val x_673: real = 
      CPointer_getReal64 (x_671, x_672)
   val exp: real -> real = 
      fn x_674: real => 
      let
	 val x_675: real = 
	    Real64_Math_exp (x_674)
      in
	 x_675
      end
   val ln: real -> real = 
      fn x_676: real => 
      let
	 val x_677: real = 
	    Real64_Math_ln (x_676)
      in
	 x_677
      end
   val log10: real -> real = 
      fn x_678: real => 
      let
	 val x_679: real = 
	    Real64_Math_log10 (x_678)
      in
	 x_679
      end
   val x_680: MLton.Pointer.t = 
      Real64_Math_pi ()
   val x_681: Word64.word = 
      0x0
   val x_682: real = 
      CPointer_getReal64 (x_680, x_681)
   val pow: real * real -> real = 
      fn x_683: real * real => 
      let
	 val x_684: real = 
	    #1 x_683
	 val x_685: real = 
	    #0 x_683
	 val x_686: real = 
	    Real64_Math_pow (x_685, x_684)
      in
	 x_686
      end
   val sin: real -> real = 
      fn x_687: real => 
      let
	 val x_688: real = 
	    Real64_Math_sin (x_687)
      in
	 x_688
      end
   val sinh: real -> real = 
      fn x_689: real => 
      let
	 val x_690: real = 
	    Real64_Math_sinh (x_689)
      in
	 x_690
      end
   val sqrt: real -> real = 
      fn x_691: real => 
      let
	 val x_692: real = 
	    Real64_Math_sqrt (x_691)
      in
	 x_692
      end
   val tan: real -> real = 
      fn x_693: real => 
      let
	 val x_694: real = 
	    Real64_Math_tan (x_693)
      in
	 x_694
      end
   val tanh: real -> real = 
      fn x_695: real => 
      let
	 val x_696: real = 
	    Real64_Math_tanh (x_695)
      in
	 x_696
      end
   val *: real * real -> real = 
      fn x_697: real * real => 
      let
	 val x_698: real = 
	    #1 x_697
	 val x_699: real = 
	    #0 x_697
	 val x_700: real = 
	    Real64_mul (x_699, x_698)
      in
	 x_700
      end
   val *+: real * real * real -> real = 
      fn x_701: real * real * real => 
      let
	 val x_702: real = 
	    #2 x_701
	 val x_703: real = 
	    #1 x_701
	 val x_704: real = 
	    #0 x_701
	 val x_705: real = 
	    Real64_muladd (x_704, x_703, x_702)
      in
	 x_705
      end
   val *-: real * real * real -> real = 
      fn x_706: real * real * real => 
      let
	 val x_707: real = 
	    #2 x_706
	 val x_708: real = 
	    #1 x_706
	 val x_709: real = 
	    #0 x_706
	 val x_710: real = 
	    Real64_mulsub (x_709, x_708, x_707)
      in
	 x_710
      end
   val +: real * real -> real = 
      fn x_711: real * real => 
      let
	 val x_712: real = 
	    #1 x_711
	 val x_713: real = 
	    #0 x_711
	 val x_714: real = 
	    Real64_add (x_713, x_712)
      in
	 x_714
      end
   val -: real * real -> real = 
      fn x_715: real * real => 
      let
	 val x_716: real = 
	    #1 x_715
	 val x_717: real = 
	    #0 x_715
	 val x_718: real = 
	    Real64_sub (x_717, x_716)
      in
	 x_718
      end
   val /: real * real -> real = 
      fn x_719: real * real => 
      let
	 val x_720: real = 
	    #1 x_719
	 val x_721: real = 
	    #0 x_719
	 val x_722: real = 
	    Real64_div (x_721, x_720)
      in
	 x_722
      end
   val ~: real -> real = 
      fn x_723: real => 
      let
	 val x_724: real = 
	    Real64_neg (x_723)
      in
	 x_724
      end
   val <: real * real -> bool = 
      fn x_725: real * real => 
      let
	 val x_726: real = 
	    #1 x_725
	 val x_727: real = 
	    #0 x_725
	 val x_728: bool = 
	    Real64_lt (x_727, x_726)
      in
	 x_728
      end
   val <=: real * real -> bool = 
      fn x_729: real * real => 
      let
	 val x_730: real = 
	    #1 x_729
	 val x_731: real = 
	    #0 x_729
	 val x_732: bool = 
	    Real64_le (x_731, x_730)
      in
	 x_732
      end
   val ==: real * real -> bool = 
      fn x_733: real * real => 
      let
	 val x_734: real = 
	    #1 x_733
	 val x_735: real = 
	    #0 x_733
	 val x_736: bool = 
	    Real64_equal (x_735, x_734)
      in
	 x_736
      end
   val abs: real -> real = 
      fn x_737: real => 
      let
	 val x_738: real = 
	    Real64_abs (x_737)
      in
	 x_738
      end
   val frexp: real * word ref -> real = 
      fn x_739: real * word ref => 
      let
	 val x_740: word ref = 
	    #1 x_739
	 val x_741: real = 
	    #0 x_739
	 val x_742: real = 
	    Real64_frexp (x_741, x_740)
      in
	 x_742
      end
   val gdtoa: real * word * word * word * word ref -> Word64.word = 
      fn x_743: real * word * word * word * word ref => 
      let
	 val x_744: word ref = 
	    #4 x_743
	 val x_745: word = 
	    #3 x_743
	 val x_746: word = 
	    #2 x_743
	 val x_747: word = 
	    #1 x_743
	 val x_748: real = 
	    #0 x_743
	 val x_749: Word64.word = 
	    Real64_gdtoa (x_748, x_747, x_746, x_745, x_744)
      in
	 x_749
      end
   val ldexp: real * word -> real = 
      fn x_750: real * word => 
      let
	 val x_751: word = 
	    #1 x_750
	 val x_752: real = 
	    #0 x_750
	 val x_753: real = 
	    Real64_ldexp (x_752, x_751)
      in
	 x_753
      end
   val modf: real * real ref -> real = 
      fn x_754: real * real ref => 
      let
	 val x_755: real ref = 
	    #1 x_754
	 val x_756: real = 
	    #0 x_754
	 val x_757: real = 
	    Real64_modf (x_756, x_755)
      in
	 x_757
      end
   val round: real -> real = 
      fn x_758: real => 
      let
	 val x_759: real = 
	    Real64_round (x_758)
      in
	 x_759
      end
   val strto: Word8.word vector * word -> real = 
      fn x_760: Word8.word vector * word => 
      let
	 val x_761: word = 
	    #1 x_760
	 val x_762: Word8.word vector = 
	    #0 x_760
	 val x_763: real = 
	    Real64_strto (x_762, x_761)
      in
	 x_763
      end
   val fromInt8Unsafe: Word8.word -> real = 
      fn x_764: Word8.word => 
      let
	 val x_765: real = 
	    WordS8_rndToReal64 (x_764)
      in
	 x_765
      end
   val fromInt16Unsafe: Word16.word -> real = 
      fn x_766: Word16.word => 
      let
	 val x_767: real = 
	    WordS16_rndToReal64 (x_766)
      in
	 x_767
      end
   val fromInt32Unsafe: word -> real = 
      fn x_768: word => 
      let
	 val x_769: real = 
	    WordS32_rndToReal64 (x_768)
      in
	 x_769
      end
   val fromInt64Unsafe: Word64.word -> real = 
      fn x_770: Word64.word => 
      let
	 val x_771: real = 
	    WordS64_rndToReal64 (x_770)
      in
	 x_771
      end
   val fromReal32Unsafe: Real32.real -> real = 
      fn x_772: Real32.real => 
      let
	 val x_773: real = 
	    Real32_rndToReal64 (x_772)
      in
	 x_773
      end
   val fromWord8Unsafe: Word8.word -> real = 
      fn x_774: Word8.word => 
      let
	 val x_775: real = 
	    WordU8_rndToReal64 (x_774)
      in
	 x_775
      end
   val fromWord16Unsafe: Word16.word -> real = 
      fn x_776: Word16.word => 
      let
	 val x_777: real = 
	    WordU16_rndToReal64 (x_776)
      in
	 x_777
      end
   val fromWord32Unsafe: word -> real = 
      fn x_778: word => 
      let
	 val x_779: real = 
	    WordU32_rndToReal64 (x_778)
      in
	 x_779
      end
   val fromWord64Unsafe: Word64.word -> real = 
      fn x_780: Word64.word => 
      let
	 val x_781: real = 
	    WordU64_rndToReal64 (x_780)
      in
	 x_781
      end
   val toInt8Unsafe: real -> Word8.word = 
      fn x_782: real => 
      let
	 val x_783: Word8.word = 
	    Real64_rndToWordS8 (x_782)
      in
	 x_783
      end
   val toInt16Unsafe: real -> Word16.word = 
      fn x_784: real => 
      let
	 val x_785: Word16.word = 
	    Real64_rndToWordS16 (x_784)
      in
	 x_785
      end
   val toInt32Unsafe: real -> word = 
      fn x_786: real => 
      let
	 val x_787: word = 
	    Real64_rndToWordS32 (x_786)
      in
	 x_787
      end
   val toInt64Unsafe: real -> Word64.word = 
      fn x_788: real => 
      let
	 val x_789: Word64.word = 
	    Real64_rndToWordS64 (x_788)
      in
	 x_789
      end
   val toReal32Unsafe: real -> Real32.real = 
      fn x_790: real => 
      let
	 val x_791: Real32.real = 
	    Real64_rndToReal32 (x_790)
      in
	 x_791
      end
   val toWord8Unsafe: real -> Word8.word = 
      fn x_792: real => 
      let
	 val x_793: Word8.word = 
	    Real64_rndToWordU8 (x_792)
      in
	 x_793
      end
   val toWord16Unsafe: real -> Word16.word = 
      fn x_794: real => 
      let
	 val x_795: Word16.word = 
	    Real64_rndToWordU16 (x_794)
      in
	 x_795
      end
   val toWord32Unsafe: real -> word = 
      fn x_796: real => 
      let
	 val x_797: word = 
	    Real64_rndToWordU32 (x_796)
      in
	 x_797
      end
   val toWord64Unsafe: real -> Word64.word = 
      fn x_798: real => 
      let
	 val x_799: Word64.word = 
	    Real64_rndToWordU64 (x_798)
      in
	 x_799
      end
   val rec 
      >: real * real -> bool = 
	 fn x_800: real * real => 
	 let
	    val b: real = 
	       #1 x_800
	    val a: real = 
	       #0 x_800
	    val x_801: real * real = 
	       (b, a)
	    val x_802: bool = 
	       < x_801
	 in
	    x_802
	 end
   val rec 
      >=: real * real -> bool = 
	 fn x_803: real * real => 
	 let
	    val b: real = 
	       #1 x_803
	    val a: real = 
	       #0 x_803
	    val x_804: real * real = 
	       (b, a)
	    val x_805: bool = 
	       <= x_804
	 in
	    x_805
	 end
   val subArr: Word8.word array * Word64.word -> word = 
      fn x_806: Word8.word array * Word64.word => 
      let
	 val x_807: Word64.word = 
	    #1 x_806
	 val x_808: Word8.word array = 
	    #0 x_806
	 val x_809: word = 
	    Word8Array_subWord32 (x_808, x_807)
      in
	 x_809
      end
   val subVec: Word8.word vector * Word64.word -> word = 
      fn x_810: Word8.word vector * Word64.word => 
      let
	 val x_811: Word64.word = 
	    #1 x_810
	 val x_812: Word8.word vector = 
	    #0 x_810
	 val x_813: word = 
	    Word8Vector_subWord32 (x_812, x_811)
      in
	 x_813
      end
   val castFromWord: word -> Real32.real = 
      fn x_814: word => 
      let
	 val x_815: Real32.real = 
	    Word32_castToReal32 (x_814)
      in
	 x_815
      end
   val castToWord: Real32.real -> word = 
      fn x_816: Real32.real => 
      let
	 val x_817: word = 
	    Real32_castToWord32 (x_816)
      in
	 x_817
      end
   val castFromWord: Word64.word -> real = 
      fn x_818: Word64.word => 
      let
	 val x_819: real = 
	    Word64_castToReal64 (x_818)
      in
	 x_819
      end
   val castToWord: real -> Word64.word = 
      fn x_820: real => 
      let
	 val x_821: Word64.word = 
	    Real64_castToWord64 (x_820)
      in
	 x_821
      end
   val halt: word -> unit = 
      fn x_822: word => 
      let
	 val x_823: unit = 
	    MLton_halt (x_822)
      in
	 x_823
      end
   val x_824: MLton.Pointer.t = 
      gcStateAddress ()
   val x_825: Word64.word = 
      0x0
   val x_826: MLton.Pointer.t = 
      CPointer_getCPointer (x_824, x_825)
   val 'a extra: exn -> 'a = 
      let
	 val x_827: exn -> 'a = 
	    fn x_828: exn => 
	    let
	       val x_829: 'a = 
		  Exn_extra['a] (x_828)
	    in
	       x_829
	    end
      in
	 x_827
      end
   val 'a setExtendExtra: ('a -> 'a) -> unit = 
      let
	 val x_830: ('a -> 'a) -> unit = 
	    fn x_831: 'a -> 'a => 
	    let
	       val x_832: unit = 
		  Exn_setExtendExtra['a] (x_831)
	    in
	       x_832
	    end
      in
	 x_830
      end
   val fromWord: Word64.word -> MLton.Pointer.t = 
      fn x_833: Word64.word => 
      let
	 val x_834: MLton.Pointer.t = 
	    CPointer_fromWord (x_833)
      in
	 x_834
      end
   val x_835: Word64.word = 
      0x0
   val null: MLton.Pointer.t = 
      fromWord x_835
   val getInt32: MLton.Pointer.t * Word64.word -> word = 
      fn x_836: MLton.Pointer.t * Word64.word => 
      let
	 val x_837: Word64.word = 
	    #1 x_836
	 val x_838: MLton.Pointer.t = 
	    #0 x_836
	 val x_839: word = 
	    CPointer_getWord32 (x_838, x_837)
      in
	 x_839
      end
   val getReal32: MLton.Pointer.t * Word64.word -> Real32.real = 
      fn x_840: MLton.Pointer.t * Word64.word => 
      let
	 val x_841: Word64.word = 
	    #1 x_840
	 val x_842: MLton.Pointer.t = 
	    #0 x_840
	 val x_843: Real32.real = 
	    CPointer_getReal32 (x_842, x_841)
      in
	 x_843
      end
   val getWord32: MLton.Pointer.t * Word64.word -> word = 
      fn x_844: MLton.Pointer.t * Word64.word => 
      let
	 val x_845: Word64.word = 
	    #1 x_844
	 val x_846: MLton.Pointer.t = 
	    #0 x_844
	 val x_847: word = 
	    CPointer_getWord32 (x_846, x_845)
      in
	 x_847
      end
   val isOn: bool = 
      false
   val rec 
      atomicEnd: unit -> unit = 
	 fn x_848: unit => 
	 let
	    val x_849: word = 
	       Thread_atomicState ()
	    val x_850: word = 
	       0x0
	    val x_851: word * word = 
	       (x_849, x_850)
	    val x_852: bool = 
	       = (word) x_851
	    val x_853: unit = 
	       case x_852 of
	       true => 
		  let
		     val x_855: Word8.word vector = 
			"Thread.atomicEnd"
		     val x_856: exn = 
			Fail8 x_855
		     val x_857: unit = 
			raise x_856
		  in
		     x_857
		  end
	       false => 
		  let
		     val x_854: unit = 
			Thread_atomicEnd ()
		  in
		     x_854
		  end
	 in
	    x_853
	 end
   val getRoundingMode: unit -> word = 
      fn x_858: unit => 
      let
	 val x_859: word = 
	    IEEEReal_getRoundingMode ()
      in
	 x_859
      end
   val FE_DOWNWARD: word = 
      0x400
   val FE_NOSUPPORT: word = 
      0xFFFFFFFF
   val FE_TONEAREST: word = 
      0x0
   val FE_TOWARDZERO: word = 
      0xC00
   val FE_UPWARD: word = 
      0x800
   val bug: Word8.word vector -> unit = 
      fn x_860: Word8.word vector => 
      let
	 val x_861: unit = 
	    MLton_bug (x_860)
      in
	 x_861
      end
   val htons: Word16.word -> Word16.word = 
      fn x_862: Word16.word => 
      let
	 val x_863: Word16.word = 
	    Net_htons (x_862)
      in
	 x_863
      end
   val ntohs: Word16.word -> Word16.word = 
      fn x_864: Word16.word => 
      let
	 val x_865: Word16.word = 
	    Net_ntohs (x_864)
      in
	 x_865
      end
   val E2BIG: word = 
      0x7
   val EACCES: word = 
      0xD
   val EADDRINUSE: word = 
      0x62
   val EADDRNOTAVAIL: word = 
      0x63
   val EAFNOSUPPORT: word = 
      0x61
   val EAGAIN: word = 
      0xB
   val EALREADY: word = 
      0x72
   val EBADF: word = 
      0x9
   val EBADMSG: word = 
      0x4A
   val EBUSY: word = 
      0x10
   val ECANCELED: word = 
      0x7D
   val ECHILD: word = 
      0xA
   val ECONNABORTED: word = 
      0x67
   val ECONNREFUSED: word = 
      0x6F
   val ECONNRESET: word = 
      0x68
   val EDEADLK: word = 
      0x23
   val EDESTADDRREQ: word = 
      0x59
   val EDOM: word = 
      0x21
   val EDQUOT: word = 
      0x7A
   val EEXIST: word = 
      0x11
   val EFAULT: word = 
      0xE
   val EFBIG: word = 
      0x1B
   val EHOSTUNREACH: word = 
      0x71
   val EIDRM: word = 
      0x2B
   val EILSEQ: word = 
      0x54
   val EINPROGRESS: word = 
      0x73
   val EINTR: word = 
      0x4
   val EINVAL: word = 
      0x16
   val EIO: word = 
      0x5
   val EISCONN: word = 
      0x6A
   val EISDIR: word = 
      0x15
   val ELOOP: word = 
      0x28
   val EMFILE: word = 
      0x18
   val EMLINK: word = 
      0x1F
   val EMSGSIZE: word = 
      0x5A
   val EMULTIHOP: word = 
      0x48
   val ENAMETOOLONG: word = 
      0x24
   val ENETDOWN: word = 
      0x64
   val ENETRESET: word = 
      0x66
   val ENETUNREACH: word = 
      0x65
   val ENFILE: word = 
      0x17
   val ENOBUFS: word = 
      0x69
   val ENODATA: word = 
      0x3D
   val ENODEV: word = 
      0x13
   val ENOENT: word = 
      0x2
   val ENOEXEC: word = 
      0x8
   val ENOLCK: word = 
      0x25
   val ENOLINK: word = 
      0x43
   val ENOMEM: word = 
      0xC
   val ENOMSG: word = 
      0x2A
   val ENOPROTOOPT: word = 
      0x5C
   val ENOSPC: word = 
      0x1C
   val ENOSR: word = 
      0x3F
   val ENOSTR: word = 
      0x3C
   val ENOSYS: word = 
      0x26
   val ENOTCONN: word = 
      0x6B
   val ENOTDIR: word = 
      0x14
   val ENOTEMPTY: word = 
      0x27
   val ENOTSOCK: word = 
      0x58
   val ENOTSUP: word = 
      0x5F
   val ENOTTY: word = 
      0x19
   val ENXIO: word = 
      0x6
   val EOPNOTSUPP: word = 
      0x5F
   val EOVERFLOW: word = 
      0x4B
   val EPERM: word = 
      0x1
   val EPIPE: word = 
      0x20
   val EPROTO: word = 
      0x47
   val EPROTONOSUPPORT: word = 
      0x5D
   val EPROTOTYPE: word = 
      0x5B
   val ERANGE: word = 
      0x22
   val EROFS: word = 
      0x1E
   val ESPIPE: word = 
      0x1D
   val ESRCH: word = 
      0x3
   val ESTALE: word = 
      0x74
   val ETIME: word = 
      0x3E
   val ETIMEDOUT: word = 
      0x6E
   val ETXTBSY: word = 
      0x1A
   val EWOULDBLOCK: word = 
      0xB
   val EXDEV: word = 
      0x12
   val abs: Real32.real -> Real32.real = 
      fn x_866: Real32.real => 
      let
	 val x_867: Real32.real = 
	    Real32_abs (x_866)
      in
	 x_867
      end
   val add: Real32.real * Real32.real -> Real32.real = 
      fn x_868: Real32.real * Real32.real => 
      let
	 val x_869: Real32.real = 
	    #1 x_868
	 val x_870: Real32.real = 
	    #0 x_868
	 val x_871: Real32.real = 
	    Real32_add (x_870, x_869)
      in
	 x_871
      end
   val div: Real32.real * Real32.real -> Real32.real = 
      fn x_872: Real32.real * Real32.real => 
      let
	 val x_873: Real32.real = 
	    #1 x_872
	 val x_874: Real32.real = 
	    #0 x_872
	 val x_875: Real32.real = 
	    Real32_div (x_874, x_873)
      in
	 x_875
      end
   val equal: Real32.real * Real32.real -> bool = 
      fn x_876: Real32.real * Real32.real => 
      let
	 val x_877: Real32.real = 
	    #1 x_876
	 val x_878: Real32.real = 
	    #0 x_876
	 val x_879: bool = 
	    Real32_equal (x_878, x_877)
      in
	 x_879
      end
   val frexp: Real32.real * word ref -> Real32.real = 
      fn x_880: Real32.real * word ref => 
      let
	 val x_881: word ref = 
	    #1 x_880
	 val x_882: Real32.real = 
	    #0 x_880
	 val x_883: Real32.real = 
	    Real32_frexp (x_882, x_881)
      in
	 x_883
      end
   val gdtoa: Real32.real * word * word * word * word ref -> Word64.word = 
      fn x_884: Real32.real * word * word * word * word ref => 
      let
	 val x_885: word ref = 
	    #4 x_884
	 val x_886: word = 
	    #3 x_884
	 val x_887: word = 
	    #2 x_884
	 val x_888: word = 
	    #1 x_884
	 val x_889: Real32.real = 
	    #0 x_884
	 val x_890: Word64.word = 
	    Real32_gdtoa (x_889, x_888, x_887, x_886, x_885)
      in
	 x_890
      end
   val ldexp: Real32.real * word -> Real32.real = 
      fn x_891: Real32.real * word => 
      let
	 val x_892: word = 
	    #1 x_891
	 val x_893: Real32.real = 
	    #0 x_891
	 val x_894: Real32.real = 
	    Real32_ldexp (x_893, x_892)
      in
	 x_894
      end
   val le: Real32.real * Real32.real -> bool = 
      fn x_895: Real32.real * Real32.real => 
      let
	 val x_896: Real32.real = 
	    #1 x_895
	 val x_897: Real32.real = 
	    #0 x_895
	 val x_898: bool = 
	    Real32_le (x_897, x_896)
      in
	 x_898
      end
   val lt: Real32.real * Real32.real -> bool = 
      fn x_899: Real32.real * Real32.real => 
      let
	 val x_900: Real32.real = 
	    #1 x_899
	 val x_901: Real32.real = 
	    #0 x_899
	 val x_902: bool = 
	    Real32_lt (x_901, x_900)
      in
	 x_902
      end
   val acos: Real32.real -> Real32.real = 
      fn x_903: Real32.real => 
      let
	 val x_904: Real32.real = 
	    Real32_Math_acos (x_903)
      in
	 x_904
      end
   val asin: Real32.real -> Real32.real = 
      fn x_905: Real32.real => 
      let
	 val x_906: Real32.real = 
	    Real32_Math_asin (x_905)
      in
	 x_906
      end
   val atan: Real32.real -> Real32.real = 
      fn x_907: Real32.real => 
      let
	 val x_908: Real32.real = 
	    Real32_Math_atan (x_907)
      in
	 x_908
      end
   val atan2: Real32.real * Real32.real -> Real32.real = 
      fn x_909: Real32.real * Real32.real => 
      let
	 val x_910: Real32.real = 
	    #1 x_909
	 val x_911: Real32.real = 
	    #0 x_909
	 val x_912: Real32.real = 
	    Real32_Math_atan2 (x_911, x_910)
      in
	 x_912
      end
   val cos: Real32.real -> Real32.real = 
      fn x_913: Real32.real => 
      let
	 val x_914: Real32.real = 
	    Real32_Math_cos (x_913)
      in
	 x_914
      end
   val cosh: Real32.real -> Real32.real = 
      fn x_915: Real32.real => 
      let
	 val x_916: Real32.real = 
	    Real32_Math_cosh (x_915)
      in
	 x_916
      end
   val x_917: unit -> Real32.real = 
      fn x_918: unit => 
      let
	 val x_919: MLton.Pointer.t = 
	    Real32_Math_e ()
	 val x_920: Word64.word = 
	    0x0
	 val x_921: Real32.real = 
	    CPointer_getReal32 (x_919, x_920)
      in
	 x_921
      end
   val exp: Real32.real -> Real32.real = 
      fn x_922: Real32.real => 
      let
	 val x_923: Real32.real = 
	    Real32_Math_exp (x_922)
      in
	 x_923
      end
   val ln: Real32.real -> Real32.real = 
      fn x_924: Real32.real => 
      let
	 val x_925: Real32.real = 
	    Real32_Math_ln (x_924)
      in
	 x_925
      end
   val log10: Real32.real -> Real32.real = 
      fn x_926: Real32.real => 
      let
	 val x_927: Real32.real = 
	    Real32_Math_log10 (x_926)
      in
	 x_927
      end
   val x_928: unit -> Real32.real = 
      fn x_929: unit => 
      let
	 val x_930: MLton.Pointer.t = 
	    Real32_Math_pi ()
	 val x_931: Word64.word = 
	    0x0
	 val x_932: Real32.real = 
	    CPointer_getReal32 (x_930, x_931)
      in
	 x_932
      end
   val pow: Real32.real * Real32.real -> Real32.real = 
      fn x_933: Real32.real * Real32.real => 
      let
	 val x_934: Real32.real = 
	    #1 x_933
	 val x_935: Real32.real = 
	    #0 x_933
	 val x_936: Real32.real = 
	    Real32_Math_pow (x_935, x_934)
      in
	 x_936
      end
   val sin: Real32.real -> Real32.real = 
      fn x_937: Real32.real => 
      let
	 val x_938: Real32.real = 
	    Real32_Math_sin (x_937)
      in
	 x_938
      end
   val sinh: Real32.real -> Real32.real = 
      fn x_939: Real32.real => 
      let
	 val x_940: Real32.real = 
	    Real32_Math_sinh (x_939)
      in
	 x_940
      end
   val sqrt: Real32.real -> Real32.real = 
      fn x_941: Real32.real => 
      let
	 val x_942: Real32.real = 
	    Real32_Math_sqrt (x_941)
      in
	 x_942
      end
   val tan: Real32.real -> Real32.real = 
      fn x_943: Real32.real => 
      let
	 val x_944: Real32.real = 
	    Real32_Math_tan (x_943)
      in
	 x_944
      end
   val tanh: Real32.real -> Real32.real = 
      fn x_945: Real32.real => 
      let
	 val x_946: Real32.real = 
	    Real32_Math_tanh (x_945)
      in
	 x_946
      end
   val modf: Real32.real * Real32.real ref -> Real32.real = 
      fn x_947: Real32.real * Real32.real ref => 
      let
	 val x_948: Real32.real ref = 
	    #1 x_947
	 val x_949: Real32.real = 
	    #0 x_947
	 val x_950: Real32.real = 
	    Real32_modf (x_949, x_948)
      in
	 x_950
      end
   val mul: Real32.real * Real32.real -> Real32.real = 
      fn x_951: Real32.real * Real32.real => 
      let
	 val x_952: Real32.real = 
	    #1 x_951
	 val x_953: Real32.real = 
	    #0 x_951
	 val x_954: Real32.real = 
	    Real32_mul (x_953, x_952)
      in
	 x_954
      end
   val muladd: Real32.real * Real32.real * Real32.real -> Real32.real = 
      fn x_955: Real32.real * Real32.real * Real32.real => 
      let
	 val x_956: Real32.real = 
	    #2 x_955
	 val x_957: Real32.real = 
	    #1 x_955
	 val x_958: Real32.real = 
	    #0 x_955
	 val x_959: Real32.real = 
	    Real32_muladd (x_958, x_957, x_956)
      in
	 x_959
      end
   val mulsub: Real32.real * Real32.real * Real32.real -> Real32.real = 
      fn x_960: Real32.real * Real32.real * Real32.real => 
      let
	 val x_961: Real32.real = 
	    #2 x_960
	 val x_962: Real32.real = 
	    #1 x_960
	 val x_963: Real32.real = 
	    #0 x_960
	 val x_964: Real32.real = 
	    Real32_mulsub (x_963, x_962, x_961)
      in
	 x_964
      end
   val neg: Real32.real -> Real32.real = 
      fn x_965: Real32.real => 
      let
	 val x_966: Real32.real = 
	    Real32_neg (x_965)
      in
	 x_966
      end
   val round: Real32.real -> Real32.real = 
      fn x_967: Real32.real => 
      let
	 val x_968: Real32.real = 
	    Real32_round (x_967)
      in
	 x_968
      end
   val strto: Word8.word vector * word -> Real32.real = 
      fn x_969: Word8.word vector * word => 
      let
	 val x_970: word = 
	    #1 x_969
	 val x_971: Word8.word vector = 
	    #0 x_969
	 val x_972: Real32.real = 
	    Real32_strto (x_971, x_970)
      in
	 x_972
      end
   val sub: Real32.real * Real32.real -> Real32.real = 
      fn x_973: Real32.real * Real32.real => 
      let
	 val x_974: Real32.real = 
	    #1 x_973
	 val x_975: Real32.real = 
	    #0 x_973
	 val x_976: Real32.real = 
	    Real32_sub (x_975, x_974)
      in
	 x_976
      end
   val abs: real -> real = 
      fn x_977: real => 
      let
	 val x_978: real = 
	    Real64_abs (x_977)
      in
	 x_978
      end
   val add: real * real -> real = 
      fn x_979: real * real => 
      let
	 val x_980: real = 
	    #1 x_979
	 val x_981: real = 
	    #0 x_979
	 val x_982: real = 
	    Real64_add (x_981, x_980)
      in
	 x_982
      end
   val div: real * real -> real = 
      fn x_983: real * real => 
      let
	 val x_984: real = 
	    #1 x_983
	 val x_985: real = 
	    #0 x_983
	 val x_986: real = 
	    Real64_div (x_985, x_984)
      in
	 x_986
      end
   val equal: real * real -> bool = 
      fn x_987: real * real => 
      let
	 val x_988: real = 
	    #1 x_987
	 val x_989: real = 
	    #0 x_987
	 val x_990: bool = 
	    Real64_equal (x_989, x_988)
      in
	 x_990
      end
   val frexp: real * word ref -> real = 
      fn x_991: real * word ref => 
      let
	 val x_992: word ref = 
	    #1 x_991
	 val x_993: real = 
	    #0 x_991
	 val x_994: real = 
	    Real64_frexp (x_993, x_992)
      in
	 x_994
      end
   val gdtoa: real * word * word * word * word ref -> Word64.word = 
      fn x_995: real * word * word * word * word ref => 
      let
	 val x_996: word ref = 
	    #4 x_995
	 val x_997: word = 
	    #3 x_995
	 val x_998: word = 
	    #2 x_995
	 val x_999: word = 
	    #1 x_995
	 val x_1000: real = 
	    #0 x_995
	 val x_1001: Word64.word = 
	    Real64_gdtoa (x_1000, x_999, x_998, x_997, x_996)
      in
	 x_1001
      end
   val ldexp: real * word -> real = 
      fn x_1002: real * word => 
      let
	 val x_1003: word = 
	    #1 x_1002
	 val x_1004: real = 
	    #0 x_1002
	 val x_1005: real = 
	    Real64_ldexp (x_1004, x_1003)
      in
	 x_1005
      end
   val le: real * real -> bool = 
      fn x_1006: real * real => 
      let
	 val x_1007: real = 
	    #1 x_1006
	 val x_1008: real = 
	    #0 x_1006
	 val x_1009: bool = 
	    Real64_le (x_1008, x_1007)
      in
	 x_1009
      end
   val lt: real * real -> bool = 
      fn x_1010: real * real => 
      let
	 val x_1011: real = 
	    #1 x_1010
	 val x_1012: real = 
	    #0 x_1010
	 val x_1013: bool = 
	    Real64_lt (x_1012, x_1011)
      in
	 x_1013
      end
   val acos: real -> real = 
      fn x_1014: real => 
      let
	 val x_1015: real = 
	    Real64_Math_acos (x_1014)
      in
	 x_1015
      end
   val asin: real -> real = 
      fn x_1016: real => 
      let
	 val x_1017: real = 
	    Real64_Math_asin (x_1016)
      in
	 x_1017
      end
   val atan: real -> real = 
      fn x_1018: real => 
      let
	 val x_1019: real = 
	    Real64_Math_atan (x_1018)
      in
	 x_1019
      end
   val atan2: real * real -> real = 
      fn x_1020: real * real => 
      let
	 val x_1021: real = 
	    #1 x_1020
	 val x_1022: real = 
	    #0 x_1020
	 val x_1023: real = 
	    Real64_Math_atan2 (x_1022, x_1021)
      in
	 x_1023
      end
   val cos: real -> real = 
      fn x_1024: real => 
      let
	 val x_1025: real = 
	    Real64_Math_cos (x_1024)
      in
	 x_1025
      end
   val cosh: real -> real = 
      fn x_1026: real => 
      let
	 val x_1027: real = 
	    Real64_Math_cosh (x_1026)
      in
	 x_1027
      end
   val x_1028: unit -> real = 
      fn x_1029: unit => 
      let
	 val x_1030: MLton.Pointer.t = 
	    Real64_Math_e ()
	 val x_1031: Word64.word = 
	    0x0
	 val x_1032: real = 
	    CPointer_getReal64 (x_1030, x_1031)
      in
	 x_1032
      end
   val exp: real -> real = 
      fn x_1033: real => 
      let
	 val x_1034: real = 
	    Real64_Math_exp (x_1033)
      in
	 x_1034
      end
   val ln: real -> real = 
      fn x_1035: real => 
      let
	 val x_1036: real = 
	    Real64_Math_ln (x_1035)
      in
	 x_1036
      end
   val log10: real -> real = 
      fn x_1037: real => 
      let
	 val x_1038: real = 
	    Real64_Math_log10 (x_1037)
      in
	 x_1038
      end
   val x_1039: unit -> real = 
      fn x_1040: unit => 
      let
	 val x_1041: MLton.Pointer.t = 
	    Real64_Math_pi ()
	 val x_1042: Word64.word = 
	    0x0
	 val x_1043: real = 
	    CPointer_getReal64 (x_1041, x_1042)
      in
	 x_1043
      end
   val pow: real * real -> real = 
      fn x_1044: real * real => 
      let
	 val x_1045: real = 
	    #1 x_1044
	 val x_1046: real = 
	    #0 x_1044
	 val x_1047: real = 
	    Real64_Math_pow (x_1046, x_1045)
      in
	 x_1047
      end
   val sin: real -> real = 
      fn x_1048: real => 
      let
	 val x_1049: real = 
	    Real64_Math_sin (x_1048)
      in
	 x_1049
      end
   val sinh: real -> real = 
      fn x_1050: real => 
      let
	 val x_1051: real = 
	    Real64_Math_sinh (x_1050)
      in
	 x_1051
      end
   val sqrt: real -> real = 
      fn x_1052: real => 
      let
	 val x_1053: real = 
	    Real64_Math_sqrt (x_1052)
      in
	 x_1053
      end
   val tan: real -> real = 
      fn x_1054: real => 
      let
	 val x_1055: real = 
	    Real64_Math_tan (x_1054)
      in
	 x_1055
      end
   val tanh: real -> real = 
      fn x_1056: real => 
      let
	 val x_1057: real = 
	    Real64_Math_tanh (x_1056)
      in
	 x_1057
      end
   val modf: real * real ref -> real = 
      fn x_1058: real * real ref => 
      let
	 val x_1059: real ref = 
	    #1 x_1058
	 val x_1060: real = 
	    #0 x_1058
	 val x_1061: real = 
	    Real64_modf (x_1060, x_1059)
      in
	 x_1061
      end
   val mul: real * real -> real = 
      fn x_1062: real * real => 
      let
	 val x_1063: real = 
	    #1 x_1062
	 val x_1064: real = 
	    #0 x_1062
	 val x_1065: real = 
	    Real64_mul (x_1064, x_1063)
      in
	 x_1065
      end
   val muladd: real * real * real -> real = 
      fn x_1066: real * real * real => 
      let
	 val x_1067: real = 
	    #2 x_1066
	 val x_1068: real = 
	    #1 x_1066
	 val x_1069: real = 
	    #0 x_1066
	 val x_1070: real = 
	    Real64_muladd (x_1069, x_1068, x_1067)
      in
	 x_1070
      end
   val mulsub: real * real * real -> real = 
      fn x_1071: real * real * real => 
      let
	 val x_1072: real = 
	    #2 x_1071
	 val x_1073: real = 
	    #1 x_1071
	 val x_1074: real = 
	    #0 x_1071
	 val x_1075: real = 
	    Real64_mulsub (x_1074, x_1073, x_1072)
      in
	 x_1075
      end
   val neg: real -> real = 
      fn x_1076: real => 
      let
	 val x_1077: real = 
	    Real64_neg (x_1076)
      in
	 x_1077
      end
   val round: real -> real = 
      fn x_1078: real => 
      let
	 val x_1079: real = 
	    Real64_round (x_1078)
      in
	 x_1079
      end
   val strto: Word8.word vector * word -> real = 
      fn x_1080: Word8.word vector * word => 
      let
	 val x_1081: word = 
	    #1 x_1080
	 val x_1082: Word8.word vector = 
	    #0 x_1080
	 val x_1083: real = 
	    Real64_strto (x_1082, x_1081)
      in
	 x_1083
      end
   val sub: real * real -> real = 
      fn x_1084: real * real => 
      let
	 val x_1085: real = 
	    #1 x_1084
	 val x_1086: real = 
	    #0 x_1084
	 val x_1087: real = 
	    Real64_sub (x_1086, x_1085)
      in
	 x_1087
      end
   val print: Word8.word vector -> unit = 
      fn x_1088: Word8.word vector => 
      let
	 val x_1089: unit = 
	    Stdio_print (x_1088)
      in
	 x_1089
      end
   val x_1090: exn -> unit = 
      fn x_1091: exn => 
      let
	 val x_1092: Word8.word vector = 
	    "unhandled exception: "
	 val x_1093: unit = 
	    print x_1092
	 val x_1094: unit = 
	    case x_1091 of
	    Fail8 x_1095: Word8.word vector => 
	       let
		  val x_1096: Word8.word vector = 
		     "Fail "
		  val x_1097: unit = 
		     print x_1096
		  val x_1098: unit = 
		     print x_1095
	       in
		  x_1098
	       end
	      _ => let
		      val x_1099: Word8.word vector = 
			 name x_1091
		      val x_1100: unit = 
			 print x_1099
		   in
		      x_1100
		   end
	 val x_1101: Word8.word vector = 
	    "
"
	 val x_1102: unit = 
	    print x_1101
	 val x_1103: Word8.word vector = 
	    "unhandled exception in Basis Library"
	 val x_1104: unit = 
	    bug x_1103
      in
	 x_1104
      end
   val x_1105: unit = 
      setHandler x_1090
   val x_1106: unit -> unit = 
      fn x_1107: unit => 
      let
	 val x_1108: word = 
	    0x0
	 val x_1109: unit = 
	    halt x_1108
	 val x_1110: Word8.word vector = 
	    "missing suffix in Basis Library"
	 val x_1111: unit = 
	    bug x_1110
      in
	 x_1111
      end
   val x_1112: unit = 
      setSuffix x_1106
   val rec 'a 
      check: 'a * 'a -> unit = 
	 fn x_1113: 'a * 'a => 
	 let
	    val x_1114: unit = 
	       ()
	 in
	    x_1114
	 end
   val x_1115: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (acos, acos)
   val x_1116: unit = 
      check (Real32.real -> Real32.real) x_1115
   val x_1117: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (asin, asin)
   val x_1118: unit = 
      check (Real32.real -> Real32.real) x_1117
   val x_1119: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (atan, atan)
   val x_1120: unit = 
      check (Real32.real -> Real32.real) x_1119
   val x_1121: (Real32.real * Real32.real -> Real32.real)
	       * (Real32.real * Real32.real -> Real32.real) = 
      (atan2, atan2)
   val x_1122: unit = 
      check (Real32.real * Real32.real -> Real32.real) x_1121
   val x_1123: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (cos, cos)
   val x_1124: unit = 
      check (Real32.real -> Real32.real) x_1123
   val x_1125: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (cosh, cosh)
   val x_1126: unit = 
      check (Real32.real -> Real32.real) x_1125
   val x_1127: unit -> Real32.real = 
      fn x_1128: unit => 
      let
      in
	 x_526
      end
   val x_1129: (unit -> Real32.real) * (unit -> Real32.real) = 
      (x_1127, x_917)
   val x_1130: unit = 
      check (unit -> Real32.real) x_1129
   val x_1131: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (exp, exp)
   val x_1132: unit = 
      check (Real32.real -> Real32.real) x_1131
   val x_1133: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (ln, ln)
   val x_1134: unit = 
      check (Real32.real -> Real32.real) x_1133
   val x_1135: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (log10, log10)
   val x_1136: unit = 
      check (Real32.real -> Real32.real) x_1135
   val x_1137: unit -> Real32.real = 
      fn x_1138: unit => 
      let
      in
	 x_535
      end
   val x_1139: (unit -> Real32.real) * (unit -> Real32.real) = 
      (x_1137, x_928)
   val x_1140: unit = 
      check (unit -> Real32.real) x_1139
   val x_1141: (Real32.real * Real32.real -> Real32.real)
	       * (Real32.real * Real32.real -> Real32.real) = 
      (pow, pow)
   val x_1142: unit = 
      check (Real32.real * Real32.real -> Real32.real) x_1141
   val x_1143: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (sin, sin)
   val x_1144: unit = 
      check (Real32.real -> Real32.real) x_1143
   val x_1145: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (sinh, sinh)
   val x_1146: unit = 
      check (Real32.real -> Real32.real) x_1145
   val x_1147: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (sqrt, sqrt)
   val x_1148: unit = 
      check (Real32.real -> Real32.real) x_1147
   val x_1149: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (tan, tan)
   val x_1150: unit = 
      check (Real32.real -> Real32.real) x_1149
   val x_1151: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (tanh, tanh)
   val x_1152: unit = 
      check (Real32.real -> Real32.real) x_1151
   val x_1153: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (abs, abs)
   val x_1154: unit = 
      check (Real32.real -> Real32.real) x_1153
   val x_1155: (Real32.real * Real32.real -> Real32.real)
	       * (Real32.real * Real32.real -> Real32.real) = 
      (+, add)
   val x_1156: unit = 
      check (Real32.real * Real32.real -> Real32.real) x_1155
   val x_1157: (Real32.real * Real32.real -> Real32.real)
	       * (Real32.real * Real32.real -> Real32.real) = 
      (/, div)
   val x_1158: unit = 
      check (Real32.real * Real32.real -> Real32.real) x_1157
   val x_1159: (Real32.real * Real32.real -> bool)
	       * (Real32.real * Real32.real -> bool) = 
      (==, equal)
   val x_1160: unit = 
      check (Real32.real * Real32.real -> bool) x_1159
   val x_1161: (Real32.real * word ref -> Real32.real)
	       * (Real32.real * word ref -> Real32.real) = 
      (frexp, frexp)
   val x_1162: unit = 
      check (Real32.real * word ref -> Real32.real) x_1161
   val x_1163: (Real32.real * word * word * word * word ref -> Word64.word)
	       * (Real32.real * word * word * word * word ref -> Word64.word) = 
      (gdtoa, gdtoa)
   val x_1164: unit = 
      check (Real32.real * word * word * word * word ref -> Word64.word) x_1163
   val x_1165: (Real32.real * word -> Real32.real)
	       * (Real32.real * word -> Real32.real) = 
      (ldexp, ldexp)
   val x_1166: unit = 
      check (Real32.real * word -> Real32.real) x_1165
   val x_1167: (Real32.real * Real32.real -> bool)
	       * (Real32.real * Real32.real -> bool) = 
      (<=, le)
   val x_1168: unit = 
      check (Real32.real * Real32.real -> bool) x_1167
   val x_1169: (Real32.real * Real32.real -> bool)
	       * (Real32.real * Real32.real -> bool) = 
      (<, lt)
   val x_1170: unit = 
      check (Real32.real * Real32.real -> bool) x_1169
   val x_1171: (Real32.real * Real32.real ref -> Real32.real)
	       * (Real32.real * Real32.real ref -> Real32.real) = 
      (modf, modf)
   val x_1172: unit = 
      check (Real32.real * Real32.real ref -> Real32.real) x_1171
   val x_1173: (Real32.real * Real32.real -> Real32.real)
	       * (Real32.real * Real32.real -> Real32.real) = 
      (*, mul)
   val x_1174: unit = 
      check (Real32.real * Real32.real -> Real32.real) x_1173
   val x_1175: (Real32.real * Real32.real * Real32.real -> Real32.real)
	       * (Real32.real * Real32.real * Real32.real -> Real32.real) = 
      (*+, muladd)
   val x_1176: unit = 
      check (Real32.real * Real32.real * Real32.real -> Real32.real) x_1175
   val x_1177: (Real32.real * Real32.real * Real32.real -> Real32.real)
	       * (Real32.real * Real32.real * Real32.real -> Real32.real) = 
      (*-, mulsub)
   val x_1178: unit = 
      check (Real32.real * Real32.real * Real32.real -> Real32.real) x_1177
   val x_1179: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (~, neg)
   val x_1180: unit = 
      check (Real32.real -> Real32.real) x_1179
   val x_1181: (Real32.real -> Real32.real) * (Real32.real -> Real32.real) = 
      (round, round)
   val x_1182: unit = 
      check (Real32.real -> Real32.real) x_1181
   val x_1183: (Word8.word vector * word -> Real32.real)
	       * (Word8.word vector * word -> Real32.real) = 
      (strto, strto)
   val x_1184: unit = 
      check (Word8.word vector * word -> Real32.real) x_1183
   val x_1185: (Real32.real * Real32.real -> Real32.real)
	       * (Real32.real * Real32.real -> Real32.real) = 
      (-, sub)
   val x_1186: unit = 
      check (Real32.real * Real32.real -> Real32.real) x_1185
   val x_1187: (real -> real) * (real -> real) = 
      (acos, acos)
   val x_1188: unit = 
      check (real -> real) x_1187
   val x_1189: (real -> real) * (real -> real) = 
      (asin, asin)
   val x_1190: unit = 
      check (real -> real) x_1189
   val x_1191: (real -> real) * (real -> real) = 
      (atan, atan)
   val x_1192: unit = 
      check (real -> real) x_1191
   val x_1193: (real * real -> real) * (real * real -> real) = 
      (atan2, atan2)
   val x_1194: unit = 
      check (real * real -> real) x_1193
   val x_1195: (real -> real) * (real -> real) = 
      (cos, cos)
   val x_1196: unit = 
      check (real -> real) x_1195
   val x_1197: (real -> real) * (real -> real) = 
      (cosh, cosh)
   val x_1198: unit = 
      check (real -> real) x_1197
   val x_1199: unit -> real = 
      fn x_1200: unit => 
      let
      in
	 x_673
      end
   val x_1201: (unit -> real) * (unit -> real) = 
      (x_1199, x_1028)
   val x_1202: unit = 
      check (unit -> real) x_1201
   val x_1203: (real -> real) * (real -> real) = 
      (exp, exp)
   val x_1204: unit = 
      check (real -> real) x_1203
   val x_1205: (real -> real) * (real -> real) = 
      (ln, ln)
   val x_1206: unit = 
      check (real -> real) x_1205
   val x_1207: (real -> real) * (real -> real) = 
      (log10, log10)
   val x_1208: unit = 
      check (real -> real) x_1207
   val x_1209: unit -> real = 
      fn x_1210: unit => 
      let
      in
	 x_682
      end
   val x_1211: (unit -> real) * (unit -> real) = 
      (x_1209, x_1039)
   val x_1212: unit = 
      check (unit -> real) x_1211
   val x_1213: (real * real -> real) * (real * real -> real) = 
      (pow, pow)
   val x_1214: unit = 
      check (real * real -> real) x_1213
   val x_1215: (real -> real) * (real -> real) = 
      (sin, sin)
   val x_1216: unit = 
      check (real -> real) x_1215
   val x_1217: (real -> real) * (real -> real) = 
      (sinh, sinh)
   val x_1218: unit = 
      check (real -> real) x_1217
   val x_1219: (real -> real) * (real -> real) = 
      (sqrt, sqrt)
   val x_1220: unit = 
      check (real -> real) x_1219
   val x_1221: (real -> real) * (real -> real) = 
      (tan, tan)
   val x_1222: unit = 
      check (real -> real) x_1221
   val x_1223: (real -> real) * (real -> real) = 
      (tanh, tanh)
   val x_1224: unit = 
      check (real -> real) x_1223
   val x_1225: (real -> real) * (real -> real) = 
      (abs, abs)
   val x_1226: unit = 
      check (real -> real) x_1225
   val x_1227: (real * real -> real) * (real * real -> real) = 
      (+, add)
   val x_1228: unit = 
      check (real * real -> real) x_1227
   val x_1229: (real * real -> real) * (real * real -> real) = 
      (/, div)
   val x_1230: unit = 
      check (real * real -> real) x_1229
   val x_1231: (real * real -> bool) * (real * real -> bool) = 
      (==, equal)
   val x_1232: unit = 
      check (real * real -> bool) x_1231
   val x_1233: (real * word ref -> real) * (real * word ref -> real) = 
      (frexp, frexp)
   val x_1234: unit = 
      check (real * word ref -> real) x_1233
   val x_1235: (real * word * word * word * word ref -> Word64.word)
	       * (real * word * word * word * word ref -> Word64.word) = 
      (gdtoa, gdtoa)
   val x_1236: unit = 
      check (real * word * word * word * word ref -> Word64.word) x_1235
   val x_1237: (real * word -> real) * (real * word -> real) = 
      (ldexp, ldexp)
   val x_1238: unit = 
      check (real * word -> real) x_1237
   val x_1239: (real * real -> bool) * (real * real -> bool) = 
      (<=, le)
   val x_1240: unit = 
      check (real * real -> bool) x_1239
   val x_1241: (real * real -> bool) * (real * real -> bool) = 
      (<, lt)
   val x_1242: unit = 
      check (real * real -> bool) x_1241
   val x_1243: (real * real ref -> real) * (real * real ref -> real) = 
      (modf, modf)
   val x_1244: unit = 
      check (real * real ref -> real) x_1243
   val x_1245: (real * real -> real) * (real * real -> real) = 
      (*, mul)
   val x_1246: unit = 
      check (real * real -> real) x_1245
   val x_1247: (real * real * real -> real) * (real * real * real -> real) = 
      (*+, muladd)
   val x_1248: unit = 
      check (real * real * real -> real) x_1247
   val x_1249: (real * real * real -> real) * (real * real * real -> real) = 
      (*-, mulsub)
   val x_1250: unit = 
      check (real * real * real -> real) x_1249
   val x_1251: (real -> real) * (real -> real) = 
      (~, neg)
   val x_1252: unit = 
      check (real -> real) x_1251
   val x_1253: (real -> real) * (real -> real) = 
      (round, round)
   val x_1254: unit = 
      check (real -> real) x_1253
   val x_1255: (Word8.word vector * word -> real)
	       * (Word8.word vector * word -> real) = 
      (strto, strto)
   val x_1256: unit = 
      check (Word8.word vector * word -> real) x_1255
   val x_1257: (real * real -> real) * (real * real -> real) = 
      (-, sub)
   val x_1258: unit = 
      check (real * real -> real) x_1257
   val rec ('a, 'b) 
      try: (unit -> 'a) * ('a -> 'b) * (exn -> 'b) -> 'b = 
	 fn x_1259: (unit -> 'a) * ('a -> 'b) * (exn -> 'b) => 
	 let
	    val h: exn -> 'b = 
	       #2 x_1259
	    val k: 'a -> 'b = 
	       #1 x_1259
	    val f: unit -> 'a = 
	       #0 x_1259
	    val x_1260: 'a DynamicWind.try.t = 
	       let
		  val x_1261: unit = 
		     ()
		  val x_1262: 'a = 
		     f x_1261
		  val x_1263: 'a DynamicWind.try.t = 
		     A['a] x_1262
	       in
		  x_1263
	       end
	       handle x_1264 => let
				   val x_1265: 'a DynamicWind.try.t = 
				      E['a] x_1264
				in
				   x_1265
				end
	    val x_1266: 'b = 
	       case x_1260 of
	       A['a] x_1269: 'a => 
		  let
		     val x_1270: 'b = 
			k x_1269
		  in
		     x_1270
		  end
	       E['a] x_1267: exn => 
		  let
		     val x_1268: 'b = 
			h x_1267
		  in
		     x_1268
		  end
	 in
	    x_1266
	 end
   val rec 'a_174 
      wind: (unit -> 'a_174) * (unit -> unit) -> 'a_174 = 
	 fn x_1271: (unit -> 'a_174) * (unit -> unit) => 
	 let
	    val cleanup: unit -> unit = 
	       #1 x_1271
	    val thunk: unit -> 'a_174 = 
	       #0 x_1271
	    val x_1272: 'a_174 -> 'a_174 = 
	       fn x_1273: 'a_174 => 
	       let
		  val x_1274: unit = 
		     ()
		  val x_1275: unit = 
		     cleanup x_1274
	       in
		  x_1273
	       end
	    val x_1276: exn -> 'a_174 = 
	       fn x_1277: exn => 
	       let
		  val x_1278: unit = 
		     ()
		  val x_1279: unit = 
		     cleanup x_1278
		  val x_1280: 'a_174 = 
		     raise x_1277
	       in
		  x_1280
	       end
	    val x_1281: (unit -> 'a_174) * ('a_174 -> 'a_174) * (exn -> 'a_174) = 
	       (thunk, x_1272, x_1276)
	    val x_1282: 'a_174 = 
	       try ('a_174, 'a_174) x_1281
	 in
	    x_1282
	 end
   val 'a wind_0: (unit -> 'a) * (unit -> unit) -> 'a = 
      let
      in
	 wind ('a)
      end
   val rec (''s, ''l) 
      make: (''l -> ''s) * (''s -> ''l) -> ''l -> ''s = 
	 fn x_1283: (''l -> ''s) * (''s -> ''l) => 
	 let
	    val zextdFromSmallToLarge: ''s -> ''l = 
	       #1 x_1283
	    val zextdFromLargeToSmall: ''l -> ''s = 
	       #0 x_1283
	    val x_1284: ''l -> ''s = 
	       fn x_1285: ''l => 
	       let
		  val res: ''s = 
		     zextdFromLargeToSmall x_1285
		  val x_1286: ''l = 
		     zextdFromSmallToLarge res
		  val x_1287: ''l * ''l = 
		     (x_1285, x_1286)
		  val x_1288: bool = 
		     = (''l) x_1287
		  val x_1289: ''s = 
		     case x_1288 of
		     true => 
			let
			in
			   res
			end
		     false => 
			let
			   val x_1290: exn = 
			      Overflow
			   val x_1291: ''s = 
			      raise x_1290
			in
			   x_1291
			end
	       in
		  x_1289
	       end
	 in
	    x_1284
	 end
   val x_1292: (Word16.word -> Word8.word) * (Word8.word -> Word16.word) = 
      (zextdFromInt16ToInt8, zextdFromInt8ToInt16)
   val zchckFromInt16ToInt8: Word16.word -> Word8.word = 
      make (Word8.word, Word16.word) x_1292
   val x_1293: (Word16.word -> Word8.word) * (Word8.word -> Word16.word) = 
      (zextdFromInt16ToWord8, zextdFromWord8ToInt16)
   val zchckFromInt16ToWord8: Word16.word -> Word8.word = 
      make (Word8.word, Word16.word) x_1293
   val x_1294: (word -> Word8.word) * (Word8.word -> word) = 
      (zextdFromInt32ToInt8, zextdFromInt8ToInt32)
   val zchckFromInt32ToInt8: word -> Word8.word = 
      make (Word8.word, word) x_1294
   val x_1295: (word -> Word16.word) * (Word16.word -> word) = 
      (zextdFromInt32ToInt16, zextdFromInt16ToInt32)
   val zchckFromInt32ToInt16: word -> Word16.word = 
      make (Word16.word, word) x_1295
   val x_1296: (word -> Word8.word) * (Word8.word -> word) = 
      (zextdFromInt32ToWord8, zextdFromWord8ToInt32)
   val zchckFromInt32ToWord8: word -> Word8.word = 
      make (Word8.word, word) x_1296
   val x_1297: (word -> Word16.word) * (Word16.word -> word) = 
      (zextdFromInt32ToWord16, zextdFromWord16ToInt32)
   val zchckFromInt32ToWord16: word -> Word16.word = 
      make (Word16.word, word) x_1297
   val x_1298: (Word64.word -> Word8.word) * (Word8.word -> Word64.word) = 
      (zextdFromInt64ToInt8, zextdFromInt8ToInt64)
   val zchckFromInt64ToInt8: Word64.word -> Word8.word = 
      make (Word8.word, Word64.word) x_1298
   val x_1299: (Word64.word -> Word16.word) * (Word16.word -> Word64.word) = 
      (zextdFromInt64ToInt16, zextdFromInt16ToInt64)
   val zchckFromInt64ToInt16: Word64.word -> Word16.word = 
      make (Word16.word, Word64.word) x_1299
   val x_1300: (Word64.word -> word) * (word -> Word64.word) = 
      (zextdFromInt64ToInt32, zextdFromInt32ToInt64)
   val zchckFromInt64ToInt32: Word64.word -> word = 
      make (word, Word64.word) x_1300
   val x_1301: (Word64.word -> Word8.word) * (Word8.word -> Word64.word) = 
      (zextdFromInt64ToWord8, zextdFromWord8ToInt64)
   val zchckFromInt64ToWord8: Word64.word -> Word8.word = 
      make (Word8.word, Word64.word) x_1301
   val x_1302: (Word64.word -> Word16.word) * (Word16.word -> Word64.word) = 
      (zextdFromInt64ToWord16, zextdFromWord16ToInt64)
   val zchckFromInt64ToWord16: Word64.word -> Word16.word = 
      make (Word16.word, Word64.word) x_1302
   val x_1303: (Word64.word -> word) * (word -> Word64.word) = 
      (zextdFromInt64ToWord32, zextdFromWord32ToInt64)
   val zchckFromInt64ToWord32: Word64.word -> word = 
      make (word, Word64.word) x_1303
   val x_1304: (Word16.word -> Word8.word) * (Word8.word -> Word16.word) = 
      (zextdFromWord16ToInt8, zextdFromInt8ToWord16)
   val zchckFromWord16ToInt8: Word16.word -> Word8.word = 
      make (Word8.word, Word16.word) x_1304
   val x_1305: (Word16.word -> Word8.word) * (Word8.word -> Word16.word) = 
      (zextdFromWord16ToWord8, zextdFromWord8ToWord16)
   val zchckFromWord16ToWord8: Word16.word -> Word8.word = 
      make (Word8.word, Word16.word) x_1305
   val x_1306: (word -> Word8.word) * (Word8.word -> word) = 
      (zextdFromWord32ToInt8, zextdFromInt8ToWord32)
   val zchckFromWord32ToInt8: word -> Word8.word = 
      make (Word8.word, word) x_1306
   val x_1307: (word -> Word16.word) * (Word16.word -> word) = 
      (zextdFromWord32ToInt16, zextdFromInt16ToWord32)
   val zchckFromWord32ToInt16: word -> Word16.word = 
      make (Word16.word, word) x_1307
   val x_1308: (word -> Word8.word) * (Word8.word -> word) = 
      (zextdFromWord32ToWord8, zextdFromWord8ToWord32)
   val zchckFromWord32ToWord8: word -> Word8.word = 
      make (Word8.word, word) x_1308
   val x_1309: (word -> Word16.word) * (Word16.word -> word) = 
      (zextdFromWord32ToWord16, zextdFromWord16ToWord32)
   val zchckFromWord32ToWord16: word -> Word16.word = 
      make (Word16.word, word) x_1309
   val x_1310: (Word64.word -> Word8.word) * (Word8.word -> Word64.word) = 
      (zextdFromWord64ToInt8, zextdFromInt8ToWord64)
   val zchckFromWord64ToInt8: Word64.word -> Word8.word = 
      make (Word8.word, Word64.word) x_1310
   val x_1311: (Word64.word -> Word16.word) * (Word16.word -> Word64.word) = 
      (zextdFromWord64ToInt16, zextdFromInt16ToWord64)
   val zchckFromWord64ToInt16: Word64.word -> Word16.word = 
      make (Word16.word, Word64.word) x_1311
   val x_1312: (Word64.word -> word) * (word -> Word64.word) = 
      (zextdFromWord64ToInt32, zextdFromInt32ToWord64)
   val zchckFromWord64ToInt32: Word64.word -> word = 
      make (word, Word64.word) x_1312
   val x_1313: (Word64.word -> Word8.word) * (Word8.word -> Word64.word) = 
      (zextdFromWord64ToWord8, zextdFromWord8ToWord64)
   val zchckFromWord64ToWord8: Word64.word -> Word8.word = 
      make (Word8.word, Word64.word) x_1313
   val x_1314: (Word64.word -> Word16.word) * (Word16.word -> Word64.word) = 
      (zextdFromWord64ToWord16, zextdFromWord16ToWord64)
   val zchckFromWord64ToWord16: Word64.word -> Word16.word = 
      make (Word16.word, Word64.word) x_1314
   val x_1315: (Word64.word -> word) * (word -> Word64.word) = 
      (zextdFromWord64ToWord32, zextdFromWord32ToWord64)
   val zchckFromWord64ToWord32: Word64.word -> word = 
      make (word, Word64.word) x_1315
   val rec (''s, ''l) 
      make: (''l -> ''s) * (''s -> ''l) -> ''l -> ''s = 
	 fn x_1316: (''l -> ''s) * (''s -> ''l) => 
	 let
	    val sextdFromSmallToLarge: ''s -> ''l = 
	       #1 x_1316
	    val sextdFromLargeToSmall: ''l -> ''s = 
	       #0 x_1316
	    val x_1317: ''l -> ''s = 
	       fn x_1318: ''l => 
	       let
		  val res: ''s = 
		     sextdFromLargeToSmall x_1318
		  val x_1319: ''l = 
		     sextdFromSmallToLarge res
		  val x_1320: ''l * ''l = 
		     (x_1318, x_1319)
		  val x_1321: bool = 
		     = (''l) x_1320
		  val x_1322: ''s = 
		     case x_1321 of
		     true => 
			let
			in
			   res
			end
		     false => 
			let
			   val x_1323: exn = 
			      Overflow
			   val x_1324: ''s = 
			      raise x_1323
			in
			   x_1324
			end
	       in
		  x_1322
	       end
	 in
	    x_1317
	 end
   val x_1325: (Word16.word -> Word8.word) * (Word8.word -> Word16.word) = 
      (sextdFromInt16ToInt8, sextdFromInt8ToInt16)
   val schckFromInt16ToInt8: Word16.word -> Word8.word = 
      make (Word8.word, Word16.word) x_1325
   val x_1326: (Word16.word -> Word8.word) * (Word8.word -> Word16.word) = 
      (sextdFromInt16ToWord8, sextdFromWord8ToInt16)
   val schckFromInt16ToWord8: Word16.word -> Word8.word = 
      make (Word8.word, Word16.word) x_1326
   val x_1327: (word -> Word8.word) * (Word8.word -> word) = 
      (sextdFromInt32ToInt8, sextdFromInt8ToInt32)
   val schckFromInt32ToInt8: word -> Word8.word = 
      make (Word8.word, word) x_1327
   val x_1328: (word -> Word16.word) * (Word16.word -> word) = 
      (sextdFromInt32ToInt16, sextdFromInt16ToInt32)
   val schckFromInt32ToInt16: word -> Word16.word = 
      make (Word16.word, word) x_1328
   val x_1329: (word -> Word8.word) * (Word8.word -> word) = 
      (sextdFromInt32ToWord8, sextdFromWord8ToInt32)
   val schckFromInt32ToWord8: word -> Word8.word = 
      make (Word8.word, word) x_1329
   val x_1330: (word -> Word16.word) * (Word16.word -> word) = 
      (sextdFromInt32ToWord16, sextdFromWord16ToInt32)
   val schckFromInt32ToWord16: word -> Word16.word = 
      make (Word16.word, word) x_1330
   val x_1331: (Word64.word -> Word8.word) * (Word8.word -> Word64.word) = 
      (sextdFromInt64ToInt8, sextdFromInt8ToInt64)
   val schckFromInt64ToInt8: Word64.word -> Word8.word = 
      make (Word8.word, Word64.word) x_1331
   val x_1332: (Word64.word -> Word16.word) * (Word16.word -> Word64.word) = 
      (sextdFromInt64ToInt16, sextdFromInt16ToInt64)
   val schckFromInt64ToInt16: Word64.word -> Word16.word = 
      make (Word16.word, Word64.word) x_1332
   val x_1333: (Word64.word -> word) * (word -> Word64.word) = 
      (sextdFromInt64ToInt32, sextdFromInt32ToInt64)
   val schckFromInt64ToInt32: Word64.word -> word = 
      make (word, Word64.word) x_1333
   val x_1334: (Word64.word -> Word8.word) * (Word8.word -> Word64.word) = 
      (sextdFromInt64ToWord8, sextdFromWord8ToInt64)
   val schckFromInt64ToWord8: Word64.word -> Word8.word = 
      make (Word8.word, Word64.word) x_1334
   val x_1335: (Word64.word -> Word16.word) * (Word16.word -> Word64.word) = 
      (sextdFromInt64ToWord16, sextdFromWord16ToInt64)
   val schckFromInt64ToWord16: Word64.word -> Word16.word = 
      make (Word16.word, Word64.word) x_1335
   val x_1336: (Word64.word -> word) * (word -> Word64.word) = 
      (sextdFromInt64ToWord32, sextdFromWord32ToInt64)
   val schckFromInt64ToWord32: Word64.word -> word = 
      make (word, Word64.word) x_1336
   val x_1337: (Word16.word -> Word8.word) * (Word8.word -> Word16.word) = 
      (sextdFromWord16ToInt8, sextdFromInt8ToWord16)
   val schckFromWord16ToInt8: Word16.word -> Word8.word = 
      make (Word8.word, Word16.word) x_1337
   val x_1338: (Word16.word -> Word8.word) * (Word8.word -> Word16.word) = 
      (sextdFromWord16ToWord8, sextdFromWord8ToWord16)
   val schckFromWord16ToWord8: Word16.word -> Word8.word = 
      make (Word8.word, Word16.word) x_1338
   val x_1339: (word -> Word8.word) * (Word8.word -> word) = 
      (sextdFromWord32ToInt8, sextdFromInt8ToWord32)
   val schckFromWord32ToInt8: word -> Word8.word = 
      make (Word8.word, word) x_1339
   val x_1340: (word -> Word16.word) * (Word16.word -> word) = 
      (sextdFromWord32ToInt16, sextdFromInt16ToWord32)
   val schckFromWord32ToInt16: word -> Word16.word = 
      make (Word16.word, word) x_1340
   val x_1341: (word -> Word8.word) * (Word8.word -> word) = 
      (sextdFromWord32ToWord8, sextdFromWord8ToWord32)
   val schckFromWord32ToWord8: word -> Word8.word = 
      make (Word8.word, word) x_1341
   val x_1342: (word -> Word16.word) * (Word16.word -> word) = 
      (sextdFromWord32ToWord16, sextdFromWord16ToWord32)
   val schckFromWord32ToWord16: word -> Word16.word = 
      make (Word16.word, word) x_1342
   val x_1343: (Word64.word -> Word8.word) * (Word8.word -> Word64.word) = 
      (sextdFromWord64ToInt8, sextdFromInt8ToWord64)
   val schckFromWord64ToInt8: Word64.word -> Word8.word = 
      make (Word8.word, Word64.word) x_1343
   val x_1344: (Word64.word -> Word16.word) * (Word16.word -> Word64.word) = 
      (sextdFromWord64ToInt16, sextdFromInt16ToWord64)
   val schckFromWord64ToInt16: Word64.word -> Word16.word = 
      make (Word16.word, Word64.word) x_1344
   val x_1345: (Word64.word -> word) * (word -> Word64.word) = 
      (sextdFromWord64ToInt32, sextdFromInt32ToWord64)
   val schckFromWord64ToInt32: Word64.word -> word = 
      make (word, Word64.word) x_1345
   val x_1346: (Word64.word -> Word8.word) * (Word8.word -> Word64.word) = 
      (sextdFromWord64ToWord8, sextdFromWord8ToWord64)
   val schckFromWord64ToWord8: Word64.word -> Word8.word = 
      make (Word8.word, Word64.word) x_1346
   val x_1347: (Word64.word -> Word16.word) * (Word16.word -> Word64.word) = 
      (sextdFromWord64ToWord16, sextdFromWord16ToWord64)
   val schckFromWord64ToWord16: Word64.word -> Word16.word = 
      make (Word16.word, Word64.word) x_1347
   val x_1348: (Word64.word -> word) * (word -> Word64.word) = 
      (sextdFromWord64ToWord32, sextdFromWord32ToWord64)
   val schckFromWord64ToWord32: Word64.word -> word = 
      make (word, Word64.word) x_1348
   val x_1349: word * word = 
      (sizeInBits, sizeInBits)
   val x_1350: bool = 
      <> (word) x_1349
   val x_1351: bool = 
      case x_1350 of
      true => 
	 let
	    val x_1354: bool = 
	       true
	 in
	    x_1354
	 end
      false => 
	 let
	    val x_1352: word * word = 
	       (sizeInBitsWord, sizeInBitsWord)
	    val x_1353: bool = 
	       <> (word) x_1352
	 in
	    x_1353
	 end
   val x_1355: unit = 
      case x_1351 of
      true => 
	 let
	    val x_1357: Word8.word vector = 
	       "MkNum0: Int.sizeInBits <> Word.sizeInBits"
	    val x_1358: exn = 
	       Fail8 x_1357
	    val x_1359: unit = 
	       raise x_1358
	 in
	    x_1359
	 end
      false => 
	 let
	    val x_1356: unit = 
	       ()
	 in
	    x_1356
	 end
   val x_1360: word = 
      0x0
   val zero: Word8.word = 
      zextdFromWord32ToWord8 x_1360
   val maxWord': Word8.word = 
      notb zero
   val x_1361: word = 
      0x0
   val zero: Word8.word = 
      zextdFromInt32ToInt8 x_1361
   val x_1362: word = 
      0x1
   val one: Word8.word = 
      zextdFromInt32ToInt8 x_1362
   val rec 
      makeShop: (Word8.word * word -> Word8.word)
		-> Word8.word * word -> Word8.word = 
	 fn x_1363: Word8.word * word -> Word8.word => 
	 let
	    val x_1364: Word8.word * word -> Word8.word = 
	       fn x_1365: Word8.word * word => 
	       let
		  val w: word = 
		     #1 x_1365
		  val x: Word8.word = 
		     #0 x_1365
		  val x_1366: Word8.word = 
		     idFromInt8ToWord8 x
		  val x_1367: Word8.word * word = 
		     (x_1366, w)
		  val x_1368: Word8.word = 
		     x_1363 x_1367
		  val x_1369: Word8.word = 
		     idFromWord8ToInt8 x_1368
	       in
		  x_1369
	       end
	 in
	    x_1364
	 end
   val <<?: Word8.word * word -> Word8.word = 
      makeShop <<?
   val >>?: Word8.word * word -> Word8.word = 
      makeShop >>?
   val x_1370: word = 
      0x1
   val x_1371: word * word = 
      (sizeInBitsWord, x_1370)
   val x_1372: word = 
      - x_1371
   val x_1373: Word8.word * word = 
      (one, x_1372)
   val minInt': Word8.word = 
      <<? x_1373
   val x_1374: Word8.word = 
      idFromInt8ToWord8 zero
   val x_1375: Word8.word = 
      notb x_1374
   val x_1376: Word8.word = 
      idFromWord8ToInt8 x_1375
   val x_1377: word = 
      0x1
   val x_1378: Word8.word * word = 
      (x_1376, x_1377)
   val maxInt': Word8.word = 
      >>? x_1378
   val x_1379: word * word = 
      (sizeInBits, sizeInBits)
   val x_1380: bool = 
      <> (word) x_1379
   val x_1381: bool = 
      case x_1380 of
      true => 
	 let
	    val x_1384: bool = 
	       true
	 in
	    x_1384
	 end
      false => 
	 let
	    val x_1382: word * word = 
	       (sizeInBitsWord, sizeInBitsWord)
	    val x_1383: bool = 
	       <> (word) x_1382
	 in
	    x_1383
	 end
   val x_1385: unit = 
      case x_1381 of
      true => 
	 let
	    val x_1387: Word8.word vector = 
	       "MkNum0: Int.sizeInBits <> Word.sizeInBits"
	    val x_1388: exn = 
	       Fail8 x_1387
	    val x_1389: unit = 
	       raise x_1388
	 in
	    x_1389
	 end
      false => 
	 let
	    val x_1386: unit = 
	       ()
	 in
	    x_1386
	 end
   val x_1390: word = 
      0x0
   val zero: Word16.word = 
      zextdFromWord32ToWord16 x_1390
   val maxWord': Word16.word = 
      notb zero
   val x_1391: word = 
      0x0
   val zero: Word16.word = 
      zextdFromInt32ToInt16 x_1391
   val x_1392: word = 
      0x1
   val one: Word16.word = 
      zextdFromInt32ToInt16 x_1392
   val rec 
      makeShop: (Word16.word * word -> Word16.word)
		-> Word16.word * word -> Word16.word = 
	 fn x_1393: Word16.word * word -> Word16.word => 
	 let
	    val x_1394: Word16.word * word -> Word16.word = 
	       fn x_1395: Word16.word * word => 
	       let
		  val w: word = 
		     #1 x_1395
		  val x: Word16.word = 
		     #0 x_1395
		  val x_1396: Word16.word = 
		     idFromInt16ToWord16 x
		  val x_1397: Word16.word * word = 
		     (x_1396, w)
		  val x_1398: Word16.word = 
		     x_1393 x_1397
		  val x_1399: Word16.word = 
		     idFromWord16ToInt16 x_1398
	       in
		  x_1399
	       end
	 in
	    x_1394
	 end
   val <<?: Word16.word * word -> Word16.word = 
      makeShop <<?
   val >>?: Word16.word * word -> Word16.word = 
      makeShop >>?
   val x_1400: word = 
      0x1
   val x_1401: word * word = 
      (sizeInBitsWord, x_1400)
   val x_1402: word = 
      - x_1401
   val x_1403: Word16.word * word = 
      (one, x_1402)
   val minInt': Word16.word = 
      <<? x_1403
   val x_1404: Word16.word = 
      idFromInt16ToWord16 zero
   val x_1405: Word16.word = 
      notb x_1404
   val x_1406: Word16.word = 
      idFromWord16ToInt16 x_1405
   val x_1407: word = 
      0x1
   val x_1408: Word16.word * word = 
      (x_1406, x_1407)
   val maxInt': Word16.word = 
      >>? x_1408
   val x_1409: word * word = 
      (sizeInBits, sizeInBits)
   val x_1410: bool = 
      <> (word) x_1409
   val x_1411: bool = 
      case x_1410 of
      true => 
	 let
	    val x_1414: bool = 
	       true
	 in
	    x_1414
	 end
      false => 
	 let
	    val x_1412: word * word = 
	       (sizeInBitsWord, sizeInBitsWord)
	    val x_1413: bool = 
	       <> (word) x_1412
	 in
	    x_1413
	 end
   val x_1415: unit = 
      case x_1411 of
      true => 
	 let
	    val x_1417: Word8.word vector = 
	       "MkNum0: Int.sizeInBits <> Word.sizeInBits"
	    val x_1418: exn = 
	       Fail8 x_1417
	    val x_1419: unit = 
	       raise x_1418
	 in
	    x_1419
	 end
      false => 
	 let
	    val x_1416: unit = 
	       ()
	 in
	    x_1416
	 end
   val x_1420: word = 
      0x0
   val zero: word = 
      zextdFromWord32ToWord32 x_1420
   val x_1421: word = 
      0x1
   val one: word = 
      zextdFromWord32ToWord32 x_1421
   val maxWord': word = 
      notb zero
   val x_1422: word = 
      0x0
   val zero: word = 
      zextdFromInt32ToInt32 x_1422
   val x_1423: word = 
      0x1
   val one: word = 
      zextdFromInt32ToInt32 x_1423
   val rec 
      makeShop: (word * word -> word) -> word * word -> word = 
	 fn x_1424: word * word -> word => 
	 let
	    val x_1425: word * word -> word = 
	       fn x_1426: word * word => 
	       let
		  val w: word = 
		     #1 x_1426
		  val x: word = 
		     #0 x_1426
		  val x_1427: word = 
		     idFromInt32ToWord32 x
		  val x_1428: word * word = 
		     (x_1427, w)
		  val x_1429: word = 
		     x_1424 x_1428
		  val x_1430: word = 
		     idFromWord32ToInt32 x_1429
	       in
		  x_1430
	       end
	 in
	    x_1425
	 end
   val <<?: word * word -> word = 
      makeShop <<?
   val >>?: word * word -> word = 
      makeShop >>?
   val x_1431: word = 
      0x1
   val x_1432: word * word = 
      (sizeInBitsWord, x_1431)
   val x_1433: word = 
      - x_1432
   val x_1434: word * word = 
      (one, x_1433)
   val minInt': word = 
      <<? x_1434
   val x_1435: word = 
      idFromInt32ToWord32 zero
   val x_1436: word = 
      notb x_1435
   val x_1437: word = 
      idFromWord32ToInt32 x_1436
   val x_1438: word = 
      0x1
   val x_1439: word * word = 
      (x_1437, x_1438)
   val maxInt': word = 
      >>? x_1439
   val rec 
      quot: word * word -> word = 
	 fn x_1440: word * word => 
	 let
	    val y: word = 
	       #1 x_1440
	    val x: word = 
	       #0 x_1440
	    val x_1441: word * word = 
	       (y, zero)
	    val x_1442: bool = 
	       = (word) x_1441
	    val x_1443: word = 
	       case x_1442 of
	       true => 
		  let
		     val x_1455: exn = 
			Div
		     val x_1456: word = 
			raise x_1455
		  in
		     x_1456
		  end
	       false => 
		  let
		     val x_1444: word * word = 
			(x, minInt')
		     val x_1445: bool = 
			= (word) x_1444
		     val x_1446: bool = 
			case x_1445 of
			true => 
			   let
			      val x_1448: word = 
				 ~! one
			      val x_1449: word * word = 
				 (y, x_1448)
			      val x_1450: bool = 
				 = (word) x_1449
			   in
			      x_1450
			   end
			false => 
			   let
			      val x_1447: bool = 
				 false
			   in
			      x_1447
			   end
		     val x_1451: word = 
			case x_1446 of
			true => 
			   let
			      val x_1453: exn = 
				 Overflow
			      val x_1454: word = 
				 raise x_1453
			   in
			      x_1454
			   end
			false => 
			   let
			      val x_1452: word = 
				 WordS32_quot (x, y)
			   in
			      x_1452
			   end
		  in
		     x_1451
		  end
	 in
	    x_1443
	 end
   val x_1457: word * word = 
      (sizeInBits, sizeInBits)
   val x_1458: bool = 
      <> (word) x_1457
   val x_1459: bool = 
      case x_1458 of
      true => 
	 let
	    val x_1462: bool = 
	       true
	 in
	    x_1462
	 end
      false => 
	 let
	    val x_1460: word * word = 
	       (sizeInBitsWord, sizeInBitsWord)
	    val x_1461: bool = 
	       <> (word) x_1460
	 in
	    x_1461
	 end
   val x_1463: unit = 
      case x_1459 of
      true => 
	 let
	    val x_1465: Word8.word vector = 
	       "MkNum0: Int.sizeInBits <> Word.sizeInBits"
	    val x_1466: exn = 
	       Fail8 x_1465
	    val x_1467: unit = 
	       raise x_1466
	 in
	    x_1467
	 end
      false => 
	 let
	    val x_1464: unit = 
	       ()
	 in
	    x_1464
	 end
   val x_1468: word = 
      0x0
   val zero: Word64.word = 
      zextdFromWord32ToWord64 x_1468
   val x_1469: word = 
      0x1
   val one: Word64.word = 
      zextdFromWord32ToWord64 x_1469
   val maxWord': Word64.word = 
      notb zero
   val x_1470: word = 
      0x0
   val zero: Word64.word = 
      zextdFromInt32ToInt64 x_1470
   val x_1471: word = 
      0x1
   val one: Word64.word = 
      zextdFromInt32ToInt64 x_1471
   val rec 
      makeShop: (Word64.word * word -> Word64.word)
		-> Word64.word * word -> Word64.word = 
	 fn x_1472: Word64.word * word -> Word64.word => 
	 let
	    val x_1473: Word64.word * word -> Word64.word = 
	       fn x_1474: Word64.word * word => 
	       let
		  val w: word = 
		     #1 x_1474
		  val x: Word64.word = 
		     #0 x_1474
		  val x_1475: Word64.word = 
		     idFromInt64ToWord64 x
		  val x_1476: Word64.word * word = 
		     (x_1475, w)
		  val x_1477: Word64.word = 
		     x_1472 x_1476
		  val x_1478: Word64.word = 
		     idFromWord64ToInt64 x_1477
	       in
		  x_1478
	       end
	 in
	    x_1473
	 end
   val <<?: Word64.word * word -> Word64.word = 
      makeShop <<?
   val ~>>?: Word64.word * word -> Word64.word = 
      makeShop ~>>?
   val >>?: Word64.word * word -> Word64.word = 
      makeShop >>?
   val x_1479: word = 
      0x1
   val x_1480: word * word = 
      (sizeInBitsWord, x_1479)
   val x_1481: word = 
      - x_1480
   val x_1482: Word64.word * word = 
      (one, x_1481)
   val minInt': Word64.word = 
      <<? x_1482
   val x_1483: Word64.word = 
      idFromInt64ToWord64 zero
   val x_1484: Word64.word = 
      notb x_1483
   val x_1485: Word64.word = 
      idFromWord64ToInt64 x_1484
   val x_1486: word = 
      0x1
   val x_1487: Word64.word * word = 
      (x_1485, x_1486)
   val maxInt': Word64.word = 
      >>? x_1487
   val rec 
      ltu: Word64.word * Word64.word -> bool = 
	 fn x_1488: Word64.word * Word64.word => 
	 let
	    val i': Word64.word = 
	       #1 x_1488
	    val i: Word64.word = 
	       #0 x_1488
	    val x_1489: Word64.word = 
	       idFromInt64ToWord64 i
	    val x_1490: Word64.word = 
	       idFromInt64ToWord64 i'
	    val x_1491: bool = 
	       WordU64_lt (x_1489, x_1490)
	 in
	    x_1491
	 end
   val rec 
      >: Word64.word * Word64.word -> bool = 
	 fn x_1492: Word64.word * Word64.word => 
	 let
	    val b: Word64.word = 
	       #1 x_1492
	    val a: Word64.word = 
	       #0 x_1492
	    val x_1493: Word64.word * Word64.word = 
	       (b, a)
	    val x_1494: bool = 
	       ltu x_1493
	 in
	    x_1494
	 end
   val rec 
      >=: Word64.word * Word64.word -> bool = 
	 fn x_1495: Word64.word * Word64.word => 
	 let
	    val b: Word64.word = 
	       #1 x_1495
	    val a: Word64.word = 
	       #0 x_1495
	    val x_1496: Word64.word * Word64.word = 
	       (a, b)
	    val x_1497: bool = 
	       ltu x_1496
	    val x_1498: bool = 
	       not x_1497
	 in
	    x_1498
	 end
   val zero: IntInf.int = 
      0
   val rec 
      isSmall: IntInf.int -> bool = 
	 fn x_1499: IntInf.int => 
	 let
	    val x_1500: Word64.word = 
	       0x0
	    val x_1501: Word64.word = 
	       toWord x_1499
	    val x_1502: Word64.word = 
	       0x1
	    val x_1503: Word64.word * Word64.word = 
	       (x_1501, x_1502)
	    val x_1504: Word64.word = 
	       andb x_1503
	    val x_1505: Word64.word * Word64.word = 
	       (x_1500, x_1504)
	    val x_1506: bool = 
	       <> (Word64.word) x_1505
	 in
	    x_1506
	 end
   val rec 
      areSmall: IntInf.int * IntInf.int -> bool = 
	 fn x_1507: IntInf.int * IntInf.int => 
	 let
	    val i': IntInf.int = 
	       #1 x_1507
	    val i: IntInf.int = 
	       #0 x_1507
	    val x_1508: Word64.word = 
	       0x0
	    val x_1509: Word64.word = 
	       toWord i
	    val x_1510: Word64.word = 
	       toWord i'
	    val x_1511: Word64.word * Word64.word = 
	       (x_1509, x_1510)
	    val x_1512: Word64.word = 
	       andb x_1511
	    val x_1513: Word64.word = 
	       0x1
	    val x_1514: Word64.word * Word64.word = 
	       (x_1512, x_1513)
	    val x_1515: Word64.word = 
	       andb x_1514
	    val x_1516: Word64.word * Word64.word = 
	       (x_1508, x_1515)
	    val x_1517: bool = 
	       <> (Word64.word) x_1516
	 in
	    x_1517
	 end
   val rec 
      numLimbs: IntInf.int -> Word64.word = 
	 fn x_1518: IntInf.int => 
	 let
	    val x_1519: bool = 
	       isSmall x_1518
	    val x_1520: Word64.word = 
	       case x_1519 of
	       true => 
		  let
		     val x_1526: Word64.word = 
			0x1
		  in
		     x_1526
		  end
	       false => 
		  let
		     val x_1521: Word64.word vector = 
			toVector x_1518
		     val x_1522: Word64.word = 
			length (Word64.word) x_1521
		     val x_1523: Word64.word = 
			0x1
		     val x_1524: Word64.word * Word64.word = 
			(x_1522, x_1523)
		     val x_1525: Word64.word = 
			-! x_1524
		  in
		     x_1525
		  end
	 in
	    x_1520
	 end
   val rec 
      dropTagCoerce: IntInf.int -> Word64.word = 
	 fn x_1527: IntInf.int => 
	 let
	    val x_1528: Word64.word = 
	       toWord x_1527
	    val x_1529: word = 
	       0x1
	    val x_1530: Word64.word * word = 
	       (x_1528, x_1529)
	    val x_1531: Word64.word = 
	       ~>>? x_1530
	 in
	    x_1531
	 end
   val rec 
      addTag: Word64.word -> Word64.word = 
	 fn x_1532: Word64.word => 
	 let
	    val x_1533: word = 
	       0x1
	    val x_1534: Word64.word * word = 
	       (x_1532, x_1533)
	    val x_1535: Word64.word = 
	       <<? x_1534
	    val x_1536: Word64.word = 
	       0x1
	    val x_1537: Word64.word * Word64.word = 
	       (x_1535, x_1536)
	    val x_1538: Word64.word = 
	       orb x_1537
	 in
	    x_1538
	 end
   val rec 
      addTagCoerce: Word64.word -> IntInf.int = 
	 fn x_1539: Word64.word => 
	 let
	    val x_1540: Word64.word = 
	       addTag x_1539
	    val x_1541: IntInf.int = 
	       fromWord x_1540
	 in
	    x_1541
	 end
   val rec 'a 
      make: (('a * 'a -> bool)
	     * ('a -> bool)
	     * ('a -> 'a)
	     * ('a -> 'a)
	     * ('a * word -> 'a)
	     * ('a * word -> 'a)
	     * word
	     * 'a)
	    * ('a -> Word64.word)
	    * ('a -> Word64.word)
	    * ('a -> Word64.word)
	    -> bool * 'a -> IntInf.int = 
	 fn x_1542: (('a * 'a -> bool)
		     * ('a -> bool)
		     * ('a -> 'a)
		     * ('a -> 'a)
		     * ('a * word -> 'a)
		     * ('a * word -> 'a)
		     * word
		     * 'a)
		    * ('a -> Word64.word)
		    * ('a -> Word64.word)
		    * ('a -> Word64.word) => 
	 let
	    val x_1543: bool * 'a -> IntInf.int = 
	       fn x_1544: bool * 'a => 
	       let
		  val x_1545: 'a -> Word64.word = 
		     #3 x_1542
		  val x_1546: 'a -> Word64.word = 
		     #2 x_1542
		  val x_1547: 'a -> Word64.word = 
		     #1 x_1542
		  val x_1548: ('a * 'a -> bool)
			      * ('a -> bool)
			      * ('a -> 'a)
			      * ('a -> 'a)
			      * ('a * word -> 'a)
			      * ('a * word -> 'a)
			      * word
			      * 'a = 
		     #0 x_1542
		  val x_1549: 'a = 
		     #1 x_1544
		  val x_1550: bool = 
		     #0 x_1544
		  val x_1551: word = 
		     #6 x_1548
		  val x_1552: word * word = 
		     (sizeInBits, x_1551)
		  val x_1553: bool = 
		     > x_1552
		  val x_1554: bool = 
		     case x_1553 of
		     true => 
			let
			   val x_1571: bool = 
			      true
			in
			   x_1571
			end
		     false => 
			let
			   val x_1555: word = 
			      0x2
			   val x_1556: word * word = 
			      (sizeInBitsWord, x_1555)
			   val shift: word = 
			      - x_1556
			   val x_1557: 'a * word -> 'a = 
			      #4 x_1548
			   val x_1558: 'a * word = 
			      (x_1549, shift)
			   val upperBits: 'a = 
			      x_1557 x_1558
			   val x_1559: 'a = 
			      #7 x_1548
			   val x_1560: 'a -> 'a = 
			      #3 x_1548
			   val oneBits: 'a = 
			      x_1560 x_1559
			   val x_1561: 'a * 'a -> bool = 
			      #0 x_1548
			   val x_1562: 'a * 'a = 
			      (upperBits, x_1559)
			   val x_1563: bool = 
			      x_1561 x_1562
			   val x_1564: bool = 
			      case x_1563 of
			      true => 
				 let
				    val x_1570: bool = 
				       true
				 in
				    x_1570
				 end
			      false => 
				 let
				    val x_1565: bool = 
				       case x_1550 of
				       true => 
					  let
					     val x_1567: 'a * 'a -> bool = 
						#0 x_1548
					     val x_1568: 'a * 'a = 
						(upperBits, oneBits)
					     val x_1569: bool = 
						x_1567 x_1568
					  in
					     x_1569
					  end
				       false => 
					  let
					     val x_1566: bool = 
						false
					  in
					     x_1566
					  end
				 in
				    x_1565
				 end
			in
			   x_1564
			end
		  val x_1572: IntInf.int = 
		     case x_1554 of
		     true => 
			let
			   val x_1629: IntInf.int = 
			      case x_1550 of
			      true => 
				 let
				    val x_1633: Word64.word = 
				       x_1547 x_1549
				    val x_1634: Word64.word = 
				       addTag x_1633
				    val x_1635: IntInf.int = 
				       fromWord x_1634
				 in
				    x_1635
				 end
			      false => 
				 let
				    val x_1630: Word64.word = 
				       x_1545 x_1549
				    val x_1631: Word64.word = 
				       addTag x_1630
				    val x_1632: IntInf.int = 
				       fromWord x_1631
				 in
				    x_1632
				 end
			in
			   x_1629
			end
		     false => 
			let
			   val rec 
			      loop: 'a
				    * Word64.word
				    * (Word64.word * Word64.word) list
				    -> Word64.word
				       * (Word64.word * Word64.word) list = 
				 fn x_1573: 'a
					    * Word64.word
					    * (Word64.word * Word64.word) list => 
				 let
				    val acc: (Word64.word * Word64.word) list = 
				       #2 x_1573
				    val i: Word64.word = 
				       #1 x_1573
				    val w: 'a = 
				       #0 x_1573
				    val x_1574: 'a * 'a -> bool = 
				       #0 x_1548
				    val x_1575: 'a = 
				       #7 x_1548
				    val x_1576: 'a * 'a = 
				       (w, x_1575)
				    val x_1577: bool = 
				       x_1574 x_1576
				    val x_1578: Word64.word
						* (Word64.word * Word64.word) list = 
				       case x_1577 of
				       true => 
					  let
					     val x_1589: Word64.word
							 * (Word64.word
							    * Word64.word) list = 
						(i, acc)
					  in
					     x_1589
					  end
				       false => 
					  let
					     val limb: Word64.word = 
						x_1546 w
					     val x_1579: 'a * word -> 'a = 
						#5 x_1548
					     val x_1580: 'a * word = 
						(w, sizeInBitsWord)
					     val w: 'a = 
						x_1579 x_1580
					     val x_1581: Word64.word = 
						0x1
					     val x_1582: Word64.word
							 * Word64.word = 
						(i, x_1581)
					     val x_1583: Word64.word = 
						+! x_1582
					     val x_1584: Word64.word
							 * Word64.word = 
						(i, limb)
					     val x_1585: (Word64.word
							  * Word64.word)
							 * (Word64.word
							    * Word64.word) list = 
						(x_1584, acc)
					     val x_1586: (Word64.word
							  * Word64.word) list = 
						::[Word64.word * Word64.word] x_1585
					     val x_1587: 'a
							 * Word64.word
							 * (Word64.word
							    * Word64.word) list = 
						(w, x_1583, x_1586)
					     val x_1588: Word64.word
							 * (Word64.word
							    * Word64.word) list = 
						loop x_1587
					  in
					     x_1588
					  end
				 in
				    x_1578
				 end
			   val x_1590: bool = 
			      case x_1550 of
			      true => 
				 let
				    val x_1592: 'a -> bool = 
				       #1 x_1548
				    val x_1593: bool = 
				       x_1592 x_1549
				 in
				    x_1593
				 end
			      false => 
				 let
				    val x_1591: bool = 
				       false
				 in
				    x_1591
				 end
			   val x_1594: Word64.word
				       * (Word64.word * Word64.word) list = 
			      case x_1590 of
			      true => 
				 let
				    val x_1604: 'a -> 'a = 
				       #2 x_1548
				    val x_1605: 'a = 
				       x_1604 x_1549
				    val x_1606: Word64.word = 
				       0x1
				    val x_1607: (Word64.word * Word64.word) list = 
				       nil[Word64.word * Word64.word]
				    val x_1608: Word64.word = 
				       0x0
				    val x_1609: Word64.word = 
				       0x1
				    val x_1610: Word64.word * Word64.word = 
				       (x_1608, x_1609)
				    val x_1611: (Word64.word * Word64.word)
						* (Word64.word * Word64.word) list = 
				       (x_1610, x_1607)
				    val x_1612: (Word64.word * Word64.word) list = 
				       ::[Word64.word * Word64.word] x_1611
				    val x_1613: 'a
						* Word64.word
						* (Word64.word * Word64.word) list = 
				       (x_1605, x_1606, x_1612)
				    val x_1614: Word64.word
						* (Word64.word * Word64.word) list = 
				       loop x_1613
				 in
				    x_1614
				 end
			      false => 
				 let
				    val x_1595: Word64.word = 
				       0x1
				    val x_1596: (Word64.word * Word64.word) list = 
				       nil[Word64.word * Word64.word]
				    val x_1597: Word64.word = 
				       0x0
				    val x_1598: Word64.word = 
				       0x0
				    val x_1599: Word64.word * Word64.word = 
				       (x_1597, x_1598)
				    val x_1600: (Word64.word * Word64.word)
						* (Word64.word * Word64.word) list = 
				       (x_1599, x_1596)
				    val x_1601: (Word64.word * Word64.word) list = 
				       ::[Word64.word * Word64.word] x_1600
				    val x_1602: 'a
						* Word64.word
						* (Word64.word * Word64.word) list = 
				       (x_1549, x_1595, x_1601)
				    val x_1603: Word64.word
						* (Word64.word * Word64.word) list = 
				       loop x_1602
				 in
				    x_1603
				 end
			   val acc: (Word64.word * Word64.word) list = 
			      #1 x_1594
			   val n: Word64.word = 
			      #0 x_1594
			   val a: Word64.word array = 
			      arrayUnsafe (Word64.word) n
			   val rec 
			      loop: (Word64.word * Word64.word) list -> unit = 
				 fn x_1615: (Word64.word * Word64.word) list => 
				 let
				    val x_1616: unit = 
				       case x_1615 of
				       nil[Word64.word * Word64.word] => 
					  let
					     val x_1625: unit = 
						()
					  in
					     x_1625
					  end
				       ::[Word64.word * Word64.word] x_1617: (Word64.word
									      * Word64.word)
									     * (Word64.word
										* Word64.word) list => 
					  let
					     val x_1618: (Word64.word
							  * Word64.word) list = 
						#1 x_1617
					     val x_1619: Word64.word
							 * Word64.word = 
						#0 x_1617
					     val x_1620: Word64.word = 
						#1 x_1619
					     val x_1621: Word64.word = 
						#0 x_1619
					     val x_1622: Word64.word array
							 * Word64.word
							 * Word64.word = 
						(a, x_1621, x_1620)
					     val x_1623: unit = 
						updateUnsafe (Word64.word) x_1622
					     val x_1624: unit = 
						loop x_1618
					  in
					     x_1624
					  end
				 in
				    x_1616
				 end
			   val x_1626: unit = 
			      loop acc
			   val x_1627: Word64.word vector = 
			      fromArrayUnsafe (Word64.word) a
			   val x_1628: IntInf.int = 
			      WordVector_toIntInf (x_1627)
			in
			   x_1628
			end
	       in
		  x_1572
	       end
	 in
	    x_1543
	 end
   val rec 
      sextdFromInt64: Word64.word -> IntInf.int = 
	 fn x_1636: Word64.word => 
	 let
	    val x_1637: Word64.word = 
	       idFromInt64ToWord64 x_1636
	    val x_1638: bool = 
	       true
	    val x_1639: Word64.word -> bool = 
	       fn x_1640: Word64.word => 
	       let
		  val x_1641: Word64.word = 
		     idFromWord64ToInt64 x_1640
		  val x_1642: Word64.word = 
		     0x0
		  val x_1643: Word64.word * Word64.word = 
		     (x_1641, x_1642)
		  val x_1644: bool = 
		     < x_1643
	       in
		  x_1644
	       end
	    val x_1645: (Word64.word * Word64.word -> bool)
			* (Word64.word -> bool)
			* (Word64.word -> Word64.word)
			* (Word64.word -> Word64.word)
			* (Word64.word * word -> Word64.word)
			* (Word64.word * word -> Word64.word)
			* word
			* Word64.word = 
	       (= (Word64.word), x_1639, ~, notb, ~>>?, >>?, sizeInBits, zero)
	    val x_1646: ((Word64.word * Word64.word -> bool)
			 * (Word64.word -> bool)
			 * (Word64.word -> Word64.word)
			 * (Word64.word -> Word64.word)
			 * (Word64.word * word -> Word64.word)
			 * (Word64.word * word -> Word64.word)
			 * word
			 * Word64.word)
			* (Word64.word -> Word64.word)
			* (Word64.word -> Word64.word)
			* (Word64.word -> Word64.word) = 
	       (x_1645,
		sextdFromWord64ToWord64,
		zextdFromWord64ToWord64,
		zextdFromWord64ToWord64)
	    val x_1647: bool * Word64.word -> IntInf.int = 
	       make (Word64.word) x_1646
	    val x_1648: bool * Word64.word = 
	       (x_1638, x_1637)
	    val x_1649: IntInf.int = 
	       x_1647 x_1648
	 in
	    x_1649
	 end
   val rec 'a_353 
      zextdFromIntInf: 'a_353 -> 'a_353 = 
	 fn x_1650: 'a_353 => 
	 let
	 in
	    x_1650
	 end
   val rec 'a_354 
      sextdFromIntInf: 'a_354 -> 'a_354 = 
	 fn x_1651: 'a_354 => 
	 let
	 in
	    x_1651
	 end
   val rec 'a_355 
      castFromIntInf: 'a_355 -> 'a_355 = 
	 fn x_1652: 'a_355 => 
	 let
	 in
	    x_1652
	 end
   val rec 'a_356 
      zchckFromIntInf: 'a_356 -> 'a_356 = 
	 fn x_1653: 'a_356 => 
	 let
	 in
	    x_1653
	 end
   val rec 'a_357 
      schckFromIntInf: 'a_357 -> 'a_357 = 
	 fn x_1654: 'a_357 => 
	 let
	 in
	    x_1654
	 end
   val rec 'a 
      make: (('a * word -> 'a) * ('a * 'a -> 'a) * word * word * 'a)
	    * (Word64.word -> 'a)
	    -> IntInf.int -> 'a Primitive.IntInf.ans = 
	 fn x_1655: (('a * word -> 'a) * ('a * 'a -> 'a) * word * word * 'a)
		    * (Word64.word -> 'a) => 
	 let
	    val x_1656: IntInf.int -> 'a Primitive.IntInf.ans = 
	       fn x_1657: IntInf.int => 
	       let
		  val x_1658: Word64.word -> 'a = 
		     #1 x_1655
		  val x_1659: ('a * word -> 'a)
			      * ('a * 'a -> 'a)
			      * word
			      * word
			      * 'a = 
		     #0 x_1655
		  val x_1660: bool = 
		     isSmall x_1657
		  val x_1661: 'a Primitive.IntInf.ans = 
		     case x_1660 of
		     true => 
			let
			   val x_1722: Word64.word = 
			      dropTagCoerce x_1657
			   val x_1723: 'a Primitive.IntInf.ans = 
			      Small['a] x_1722
			in
			   x_1723
			end
		     false => 
			let
			   val v: Word64.word vector = 
			      toVector x_1657
			   val n: Word64.word = 
			      length (Word64.word) v
			   val x_1662: Word64.word = 
			      0x0
			   val x_1663: Word64.word vector * Word64.word = 
			      (v, x_1662)
			   val x_1664: Word64.word = 
			      subUnsafe (Word64.word) x_1663
			   val x_1665: Word64.word = 
			      0x0
			   val x_1666: Word64.word * Word64.word = 
			      (x_1664, x_1665)
			   val isneg: bool = 
			      <> (Word64.word) x_1666
			   val x_1667: word = 
			      #2 x_1659
			   val x_1668: word * word = 
			      (sizeInBits, x_1667)
			   val x_1669: bool = 
			      >= x_1668
			   val x_1670: 'a Primitive.IntInf.ans = 
			      case x_1669 of
			      true => 
				 let
				    val limbsPer: Word64.word = 
				       0x1
				    val x_1705: Word64.word = 
				       0x1
				    val x_1706: Word64.word vector * Word64.word = 
				       (v, x_1705)
				    val limb: Word64.word = 
				       subUnsafe (Word64.word) x_1706
				    val x_1707: Word64.word = 
				       0x1
				    val x_1708: Word64.word * Word64.word = 
				       (limbsPer, x_1707)
				    val x_1709: Word64.word = 
				       +! x_1708
				    val x_1710: Word64.word * Word64.word = 
				       (n, x_1709)
				    val x_1711: bool = 
				       > x_1710
				    val x_1712: bool = 
				       case x_1711 of
				       true => 
					  let
					     val x_1719: bool = 
						true
					  in
					     x_1719
					  end
				       false => 
					  let
					     val x_1713: word = 
						#3 x_1659
					     val x_1714: Word64.word * word = 
						(limb, x_1713)
					     val x_1715: Word64.word = 
						>>? x_1714
					     val x_1716: Word64.word = 
						0x0
					     val x_1717: Word64.word
							 * Word64.word = 
						(x_1715, x_1716)
					     val x_1718: bool = 
						<> (Word64.word) x_1717
					  in
					     x_1718
					  end
				    val ans: 'a = 
				       x_1658 limb
				    val x_1720: bool * bool * 'a = 
				       (isneg, x_1712, ans)
				    val x_1721: 'a Primitive.IntInf.ans = 
				       Big['a] x_1720
				 in
				    x_1721
				 end
			      false => 
				 let
				    val x_1671: word = 
				       #2 x_1659
				    val x_1672: word * word = 
				       (x_1671, sizeInBits)
				    val x_1673: word = 
				       quot x_1672
				    val limbsPer: Word64.word = 
				       sextdFromInt32ToInt64 x_1673
				    val x_1674: Word64.word = 
				       0x1
				    val x_1675: Word64.word * Word64.word = 
				       (limbsPer, x_1674)
				    val x_1676: Word64.word = 
				       +! x_1675
				    val x_1677: Word64.word * Word64.word = 
				       (n, x_1676)
				    val extra: bool = 
				       > x_1677
				    val rec 
				       loop: Word64.word * 'a -> 'a = 
					  fn x_1678: Word64.word * 'a => 
					  let
					     val ans: 'a = 
						#1 x_1678
					     val i: Word64.word = 
						#0 x_1678
					     val x_1679: Word64.word = 
						0x0
					     val x_1680: Word64.word
							 * Word64.word = 
						(i, x_1679)
					     val x_1681: bool = 
						> x_1680
					     val x_1682: 'a = 
						case x_1681 of
						true => 
						   let
						      val x_1683: Word64.word vector
								  * Word64.word = 
							 (v, i)
						      val limb: Word64.word = 
							 subUnsafe (Word64.word) x_1683
						      val x_1684: 'a * 'a -> 'a = 
							 #1 x_1659
						      val x_1685: 'a * word
								  -> 'a = 
							 #0 x_1659
						      val x_1686: 'a * word = 
							 (ans, sizeInBitsWord)
						      val x_1687: 'a = 
							 x_1685 x_1686
						      val x_1688: 'a = 
							 x_1658 limb
						      val x_1689: 'a * 'a = 
							 (x_1687, x_1688)
						      val ans: 'a = 
							 x_1684 x_1689
						      val x_1690: Word64.word = 
							 0x1
						      val x_1691: Word64.word
								  * Word64.word = 
							 (i, x_1690)
						      val x_1692: Word64.word = 
							 -! x_1691
						      val x_1693: Word64.word
								  * 'a = 
							 (x_1692, ans)
						      val x_1694: 'a = 
							 loop x_1693
						   in
						      x_1694
						   end
						false => 
						   let
						   in
						      ans
						   end
					  in
					     x_1682
					  end
				    val x_1695: Word64.word = 
				       0x1
				    val x_1696: Word64.word * Word64.word = 
				       (n, x_1695)
				    val x_1697: Word64.word = 
				       -! x_1696
				    val x_1698: Word64.word * Word64.word = 
				       (x_1697, limbsPer)
				    val x_1699: bool = 
				       < x_1698
				    val x_1700: Word64.word = 
				       case x_1699 of
				       true => 
					  let
					  in
					     x_1697
					  end
				       false => 
					  let
					  in
					     limbsPer
					  end
				    val x_1701: 'a = 
				       #4 x_1659
				    val x_1702: Word64.word * 'a = 
				       (x_1700, x_1701)
				    val ans: 'a = 
				       loop x_1702
				    val x_1703: bool * bool * 'a = 
				       (isneg, extra, ans)
				    val x_1704: 'a Primitive.IntInf.ans = 
				       Big['a] x_1703
				 in
				    x_1704
				 end
			in
			   x_1670
			end
	       in
		  x_1661
	       end
	 in
	    x_1656
	 end
   val x_1724: (Word8.word * word -> Word8.word)
	       * (Word8.word * Word8.word -> Word8.word)
	       * word
	       * word
	       * Word8.word = 
      (<<?, orb, sizeInBits, sizeInBitsWord, zero)
   val x_1725: ((Word8.word * word -> Word8.word)
		* (Word8.word * Word8.word -> Word8.word)
		* word
		* word
		* Word8.word)
	       * (Word64.word -> Word8.word) = 
      (x_1724, zextdFromWord64ToWord8)
   val chckToWord8Aux: IntInf.int -> Word8.word Primitive.IntInf.ans = 
      make (Word8.word) x_1725
   val x_1726: (Word16.word * word -> Word16.word)
	       * (Word16.word * Word16.word -> Word16.word)
	       * word
	       * word
	       * Word16.word = 
      (<<?, orb, sizeInBits, sizeInBitsWord, zero)
   val x_1727: ((Word16.word * word -> Word16.word)
		* (Word16.word * Word16.word -> Word16.word)
		* word
		* word
		* Word16.word)
	       * (Word64.word -> Word16.word) = 
      (x_1726, zextdFromWord64ToWord16)
   val chckToWord16Aux: IntInf.int -> Word16.word Primitive.IntInf.ans = 
      make (Word16.word) x_1727
   val x_1728: (word * word -> word)
	       * (word * word -> word)
	       * word
	       * word
	       * word = 
      (<<?, orb, sizeInBits, sizeInBitsWord, zero)
   val x_1729: ((word * word -> word)
		* (word * word -> word)
		* word
		* word
		* word)
	       * (Word64.word -> word) = 
      (x_1728, zextdFromWord64ToWord32)
   val chckToWord32Aux: IntInf.int -> word Primitive.IntInf.ans = 
      make (word) x_1729
   val x_1730: (Word64.word * word -> Word64.word)
	       * (Word64.word * Word64.word -> Word64.word)
	       * word
	       * word
	       * Word64.word = 
      (<<?, orb, sizeInBits, sizeInBitsWord, zero)
   val x_1731: ((Word64.word * word -> Word64.word)
		* (Word64.word * Word64.word -> Word64.word)
		* word
		* word
		* Word64.word)
	       * (Word64.word -> Word64.word) = 
      (x_1730, zextdFromWord64ToWord64)
   val chckToWord64Aux: IntInf.int -> Word64.word Primitive.IntInf.ans = 
      make (Word64.word) x_1731
   val rec 'a_360 
      zextdToIntInf: 'a_360 -> 'a_360 = 
	 fn x_1732: 'a_360 => 
	 let
	 in
	    x_1732
	 end
   val rec 'a_361 
      sextdToIntInf: 'a_361 -> 'a_361 = 
	 fn x_1733: 'a_361 => 
	 let
	 in
	    x_1733
	 end
   val rec 'a_362 
      castToIntInf: 'a_362 -> 'a_362 = 
	 fn x_1734: 'a_362 => 
	 let
	 in
	    x_1734
	 end
   val rec 'a_363 
      zchckToIntInf: 'a_363 -> 'a_363 = 
	 fn x_1735: 'a_363 => 
	 let
	 in
	    x_1735
	 end
   val rec 'a_364 
      schckToIntInf: 'a_364 -> 'a_364 = 
	 fn x_1736: 'a_364 => 
	 let
	 in
	    x_1736
	 end
   val x_1737: word = 
      0x8
   val x_1738: word * word = 
      (sizeInBits, x_1737)
   val x_1739: word = 
      quot x_1738
   val bytesPerMPLimb: Word64.word = 
      zextdFromInt32ToWord64 x_1739
   val x_1740: word = 
      0x8
   val x_1741: word * word = 
      (sizeInBits, x_1740)
   val x_1742: word = 
      quot x_1741
   val bytesPerCounter: Word64.word = 
      zextdFromInt32ToWord64 x_1742
   val x_1743: word = 
      0x8
   val x_1744: word * word = 
      (sizeInBits, x_1743)
   val x_1745: word = 
      quot x_1744
   val bytesPerLength: Word64.word = 
      zextdFromInt32ToWord64 x_1745
   val x_1746: word = 
      0x8
   val x_1747: word * word = 
      (sizeInBits, x_1746)
   val x_1748: word = 
      quot x_1747
   val bytesPerHeader: Word64.word = 
      zextdFromInt32ToWord64 x_1748
   val x_1749: Word64.word * Word64.word = 
      (bytesPerLength, bytesPerHeader)
   val x_1750: Word64.word = 
      + x_1749
   val x_1751: Word64.word * Word64.word = 
      (bytesPerCounter, x_1750)
   val bytesPerArrayHeader: Word64.word = 
      + x_1751
   val rec 
      reserve: Word64.word * Word64.word -> Word64.word = 
	 fn x_1752: Word64.word * Word64.word => 
	 let
	    val extra: Word64.word = 
	       #1 x_1752
	    val num: Word64.word = 
	       #0 x_1752
	    val x_1753: Word64.word = 
	       zextdFromInt64ToWord64 num
	    val x_1754: Word64.word * Word64.word = 
	       (bytesPerMPLimb, x_1753)
	    val x_1755: Word64.word = 
	       * x_1754
	    val x_1756: Word64.word = 
	       zextdFromInt64ToWord64 extra
	    val x_1757: Word64.word * Word64.word = 
	       (bytesPerMPLimb, x_1756)
	    val x_1758: Word64.word = 
	       * x_1757
	    val x_1759: Word64.word = 
	       0x7
	    val x_1760: Word64.word * Word64.word = 
	       (bytesPerArrayHeader, x_1759)
	    val x_1761: Word64.word = 
	       + x_1760
	    val x_1762: Word64.word * Word64.word = 
	       (bytesPerMPLimb, x_1761)
	    val x_1763: Word64.word = 
	       + x_1762
	    val x_1764: Word64.word * Word64.word = 
	       (x_1758, x_1763)
	    val x_1765: Word64.word = 
	       + x_1764
	    val x_1766: Word64.word * Word64.word = 
	       (x_1755, x_1765)
	    val x_1767: Word64.word = 
	       + x_1766
	 in
	    x_1767
	 end
   val x_1768: word = 
      0x1
   val x_1769: Word64.word * word = 
      (minInt', x_1768)
   val badObjptrInt: Word64.word = 
      ~>>? x_1769
   val badObjptrWord: Word64.word = 
      zextdFromInt64ToWord64 badObjptrInt
   val badObjptrWordTagged: Word64.word = 
      addTag badObjptrWord
   val x_1770: Word64.word = 
      ~! badObjptrInt
   val negBadIntInf: IntInf.int = 
      sextdFromInt64 x_1770
   val rec 
      make: (Word64.word * Word64.word -> Word64.word)
	    * (IntInf.int * IntInf.int * Word64.word -> IntInf.int)
	    * (Word64.word * Word64.word -> Word64.word)
	    * Word64.word
	    -> IntInf.int * IntInf.int -> IntInf.int = 
	 fn x_1771: (Word64.word * Word64.word -> Word64.word)
		    * (IntInf.int * IntInf.int * Word64.word -> IntInf.int)
		    * (Word64.word * Word64.word -> Word64.word)
		    * Word64.word => 
	 let
	    val x_1772: IntInf.int * IntInf.int -> IntInf.int = 
	       fn x_1773: IntInf.int * IntInf.int => 
	       let
		  val x_1774: Word64.word = 
		     #3 x_1771
		  val x_1775: Word64.word * Word64.word -> Word64.word = 
		     #2 x_1771
		  val x_1776: IntInf.int * IntInf.int * Word64.word
			      -> IntInf.int = 
		     #1 x_1771
		  val x_1777: Word64.word * Word64.word -> Word64.word = 
		     #0 x_1771
		  val x_1778: IntInf.int = 
		     #1 x_1773
		  val x_1779: IntInf.int = 
		     #0 x_1773
		  val x_1780: IntInf.int * IntInf.int = 
		     (x_1779, x_1778)
		  val x_1781: bool = 
		     areSmall x_1780
		  val x_1782: IntInf.int option = 
		     case x_1781 of
		     true => 
			let
			   val x_1784: IntInf.int option = 
			      let
				 val lhsw: Word64.word = 
				    dropTagCoerce x_1779
				 val lhsi: Word64.word = 
				    zextdFromWord64ToInt64 lhsw
				 val rhsw: Word64.word = 
				    dropTagCoerce x_1778
				 val rhsi: Word64.word = 
				    zextdFromWord64ToInt64 rhsw
				 val x_1785: Word64.word * Word64.word = 
				    (lhsi, rhsi)
				 val ansi: Word64.word = 
				    x_1777 x_1785
				 val answ: Word64.word = 
				    zextdFromInt64ToWord64 ansi
				 val ans: Word64.word = 
				    addTag answ
				 val x_1786: Word64.word = 
				    Word64_xorb (ans, answ)
				 val x_1787: Word64.word = 
				    zextdFromWord64ToInt64 x_1786
				 val x_1788: Word64.word = 
				    0x0
				 val x_1789: Word64.word * Word64.word = 
				    (x_1787, x_1788)
				 val x_1790: bool = 
				    >= x_1789
				 val x_1791: IntInf.int option = 
				    case x_1790 of
				    true => 
				       let
					  val x_1793: IntInf.int = 
					     fromWord ans
					  val x_1794: IntInf.int option = 
					     SOME[IntInf.int] x_1793
				       in
					  x_1794
				       end
				    false => 
				       let
					  val x_1792: IntInf.int option = 
					     NONE[IntInf.int]
				       in
					  x_1792
				       end
			      in
				 x_1791
			      end
			      handle x_1795 => let
						  val x_1796: IntInf.int option = 
						     case x_1795 of
						     Overflow => 
							let
							   val x_1797: IntInf.int option = 
							      NONE[IntInf.int]
							in
							   x_1797
							end
						       _ => let
							       val x_1798: IntInf.int option = 
								  raise x_1795
							    in
							       x_1798
							    end
					       in
						  x_1796
					       end
			in
			   x_1784
			end
		     false => 
			let
			   val x_1783: IntInf.int option = 
			      NONE[IntInf.int]
			in
			   x_1783
			end
		  val x_1799: IntInf.int = 
		     case x_1782 of
		     NONE[IntInf.int] => 
			let
			   val x_1801: Word64.word = 
			      numLimbs x_1779
			   val x_1802: Word64.word = 
			      numLimbs x_1778
			   val x_1803: Word64.word * Word64.word = 
			      (x_1801, x_1802)
			   val x_1804: Word64.word = 
			      x_1775 x_1803
			   val x_1805: Word64.word * Word64.word = 
			      (x_1804, x_1774)
			   val x_1806: Word64.word = 
			      reserve x_1805
			   val x_1807: IntInf.int * IntInf.int * Word64.word = 
			      (x_1779, x_1778, x_1806)
			   val x_1808: IntInf.int = 
			      x_1776 x_1807
			in
			   x_1808
			end
		     SOME[IntInf.int] x_1800: IntInf.int => 
			let
			in
			   x_1800
			end
	       in
		  x_1799
	       end
	 in
	    x_1772
	 end
   val x_1809: Word64.word = 
      0x1
   val x_1810: (Word64.word * Word64.word -> Word64.word)
	       * (IntInf.int * IntInf.int * Word64.word -> IntInf.int)
	       * (Word64.word * Word64.word -> Word64.word)
	       * Word64.word = 
      (+!, +, max, x_1809)
   val bigAdd: IntInf.int * IntInf.int -> IntInf.int = 
      make x_1810
   val x_1811: Word64.word = 
      0x0
   val x_1812: (Word64.word * Word64.word -> Word64.word)
	       * (IntInf.int * IntInf.int * Word64.word -> IntInf.int)
	       * (Word64.word * Word64.word -> Word64.word)
	       * Word64.word = 
      (*!, *, +!, x_1811)
   val bigMul: IntInf.int * IntInf.int -> IntInf.int = 
      make x_1812
   val rec 'a 
      make: (Word64.word * Word64.word -> 'a) * (word * word -> 'a)
	    -> IntInf.int * IntInf.int -> 'a = 
	 fn x_1813: (Word64.word * Word64.word -> 'a) * (word * word -> 'a) => 
	 let
	    val x_1814: IntInf.int * IntInf.int -> 'a = 
	       fn x_1815: IntInf.int * IntInf.int => 
	       let
		  val x_1816: word * word -> 'a = 
		     #1 x_1813
		  val x_1817: Word64.word * Word64.word -> 'a = 
		     #0 x_1813
		  val x_1818: IntInf.int = 
		     #1 x_1815
		  val x_1819: IntInf.int = 
		     #0 x_1815
		  val x_1820: IntInf.int * IntInf.int = 
		     (x_1819, x_1818)
		  val x_1821: bool = 
		     areSmall x_1820
		  val x_1822: 'a = 
		     case x_1821 of
		     true => 
			let
			   val x_1827: Word64.word = 
			      toWord x_1819
			   val x_1828: Word64.word = 
			      zextdFromWord64ToInt64 x_1827
			   val x_1829: Word64.word = 
			      toWord x_1818
			   val x_1830: Word64.word = 
			      zextdFromWord64ToInt64 x_1829
			   val x_1831: Word64.word * Word64.word = 
			      (x_1828, x_1830)
			   val x_1832: 'a = 
			      x_1817 x_1831
			in
			   x_1832
			end
		     false => 
			let
			   val x_1823: word = 
			      IntInf_compare (x_1819, x_1818)
			   val x_1824: word = 
			      0x0
			   val x_1825: word * word = 
			      (x_1823, x_1824)
			   val x_1826: 'a = 
			      x_1816 x_1825
			in
			   x_1826
			end
	       in
		  x_1822
	       end
	 in
	    x_1814
	 end
   val x_1833: (Word64.word * Word64.word -> bool) * (word * word -> bool) = 
      (<, <)
   val bigLT: IntInf.int * IntInf.int -> bool = 
      make (bool) x_1833
   val rec 
      mkBigCvt: word * (Word64.word -> Word8.word vector)
		-> IntInf.int -> Word8.word vector = 
	 fn x_1834: word * (Word64.word -> Word8.word vector) => 
	 let
	    val x_1835: IntInf.int -> Word8.word vector = 
	       fn x_1836: IntInf.int => 
	       let
		  val x_1837: Word64.word -> Word8.word vector = 
		     #1 x_1834
		  val x_1838: word = 
		     #0 x_1834
		  val x_1839: bool = 
		     isSmall x_1836
		  val x_1840: Word8.word vector = 
		     case x_1839 of
		     true => 
			let
			   val x_1945: Word64.word = 
			      dropTagCoerce x_1836
			   val x_1946: Word64.word = 
			      zextdFromWord64ToInt64 x_1945
			   val x_1947: Word8.word vector = 
			      x_1837 x_1946
			in
			   x_1947
			end
		     false => 
			let
			   val x_1841: word = 
			      idFromInt32ToWord32 x_1838
			   val rec 
			      loop: word * word * word -> word = 
				 fn x_1842: word * word * word => 
				 let
				    val acc: word = 
				       #2 x_1842
				    val s: word = 
				       #1 x_1842
				    val n: word = 
				       #0 x_1842
				    val x_1843: word * word = 
				       (n, one)
				    val x_1844: bool = 
				       = (word) x_1843
				    val x_1845: word = 
				       case x_1844 of
				       true => 
					  let
					  in
					     acc
					  end
				       false => 
					  let
					     val x_1846: word * word = 
						(one, s)
					     val x_1847: word = 
						<<? x_1846
					     val x_1848: word * word = 
						(n, x_1847)
					     val x_1849: bool = 
						>= x_1848
					     val x_1850: word * word = 
						case x_1849 of
						true => 
						   let
						      val x_1852: word * word = 
							 (n, s)
						      val x_1853: word = 
							 >>? x_1852
						      val x_1854: word = 
							 Word32_add (acc, s)
						      val x_1855: word * word = 
							 (x_1853, x_1854)
						   in
						      x_1855
						   end
						false => 
						   let
						      val x_1851: word * word = 
							 (n, acc)
						   in
						      x_1851
						   end
					     val acc: word = 
						#1 x_1850
					     val n: word = 
						#0 x_1850
					     val x_1856: word = 
						0x1
					     val x_1857: word * word = 
						(s, x_1856)
					     val x_1858: word = 
						>>? x_1857
					     val x_1859: word * word * word = 
						(n, x_1858, acc)
					     val x_1860: word = 
						loop x_1859
					  in
					     x_1860
					  end
				 in
				    x_1845
				 end
			   val x_1861: word * word = 
			      (x_1841, zero)
			   val x_1862: bool = 
			      = (word) x_1861
			   val x_1863: word = 
			      case x_1862 of
			      true => 
				 let
				    val x_1870: exn = 
				       Domain
				    val x_1871: word = 
				       raise x_1870
				 in
				    x_1871
				 end
			      false => 
				 let
				    val x_1864: word = 
				       0x1
				    val x_1865: word * word = 
				       (sizeInBitsWord, x_1864)
				    val x_1866: word = 
				       >>? x_1865
				    val x_1867: word = 
				       0x0
				    val x_1868: word * word * word = 
				       (x_1841, x_1866, x_1867)
				    val x_1869: word = 
				       loop x_1868
				 in
				    x_1869
				 end
			   val x_1872: word = 
			      zextdFromWord32ToInt32 x_1863
			   val x_1873: word * word = 
			      (sizeInBits, x_1872)
			   val x_1874: word = 
			      quot x_1873
			   val x_1875: word * word = 
			      (sizeInBits, zero)
			   val x_1876: bool = 
			      >= x_1875
			   val x_1877: word = 
			      case x_1876 of
			      true => 
				 let
				    val x_1904: word * word = 
				       (x_1872, zero)
				    val x_1905: bool = 
				       > x_1904
				    val x_1906: word = 
				       case x_1905 of
				       true => 
					  let
					     val x_1923: word * word = 
						(sizeInBits, x_1872)
					     val x_1924: word = 
						remUnsafe x_1923
					  in
					     x_1924
					  end
				       false => 
					  let
					     val x_1907: word * word = 
						(x_1872, zero)
					     val x_1908: bool = 
						< x_1907
					     val x_1909: word = 
						case x_1908 of
						true => 
						   let
						      val x_1912: word * word = 
							 (sizeInBits, zero)
						      val x_1913: bool = 
							 = (word) x_1912
						      val x_1914: word = 
							 case x_1913 of
							 true => 
							    let
							    in
							       zero
							    end
							 false => 
							    let
							       val x_1915: word
									   * word = 
								  (sizeInBits,
								   one)
							       val x_1916: word = 
								  -? x_1915
							       val x_1917: word
									   * word = 
								  (x_1916,
								   x_1872)
							       val x_1918: word = 
								  remUnsafe x_1917
							       val x_1919: word
									   * word = 
								  (x_1872, one)
							       val x_1920: word = 
								  +! x_1919
							       val x_1921: word
									   * word = 
								  (x_1918,
								   x_1920)
							       val x_1922: word = 
								  +? x_1921
							    in
							       x_1922
							    end
						   in
						      x_1914
						   end
						false => 
						   let
						      val x_1910: exn = 
							 Div
						      val x_1911: word = 
							 raise x_1910
						   in
						      x_1911
						   end
					  in
					     x_1909
					  end
				 in
				    x_1906
				 end
			      false => 
				 let
				    val x_1878: word * word = 
				       (x_1872, zero)
				    val x_1879: bool = 
				       < x_1878
				    val x_1880: word = 
				       case x_1879 of
				       true => 
					  let
					     val x_1894: word * word = 
						(sizeInBits, minInt')
					     val x_1895: bool = 
						= (word) x_1894
					     val x_1896: bool = 
						case x_1895 of
						true => 
						   let
						      val x_1898: word = 
							 ~! one
						      val x_1899: word * word = 
							 (x_1872, x_1898)
						      val x_1900: bool = 
							 = (word) x_1899
						   in
						      x_1900
						   end
						false => 
						   let
						      val x_1897: bool = 
							 false
						   in
						      x_1897
						   end
					     val x_1901: word = 
						case x_1896 of
						true => 
						   let
						   in
						      zero
						   end
						false => 
						   let
						      val x_1902: word * word = 
							 (sizeInBits, x_1872)
						      val x_1903: word = 
							 remUnsafe x_1902
						   in
						      x_1903
						   end
					  in
					     x_1901
					  end
				       false => 
					  let
					     val x_1881: word * word = 
						(x_1872, zero)
					     val x_1882: bool = 
						> x_1881
					     val x_1883: word = 
						case x_1882 of
						true => 
						   let
						      val x_1886: word * word = 
							 (sizeInBits, one)
						      val x_1887: word = 
							 +? x_1886
						      val x_1888: word * word = 
							 (x_1887, x_1872)
						      val x_1889: word = 
							 remUnsafe x_1888
						      val x_1890: word * word = 
							 (x_1872, one)
						      val x_1891: word = 
							 -? x_1890
						      val x_1892: word * word = 
							 (x_1889, x_1891)
						      val x_1893: word = 
							 +? x_1892
						   in
						      x_1893
						   end
						false => 
						   let
						      val x_1884: exn = 
							 Div
						      val x_1885: word = 
							 raise x_1884
						   in
						      x_1885
						   end
					  in
					     x_1883
					  end
				 in
				    x_1880
				 end
			   val x_1925: word = 
			      0x0
			   val x_1926: word * word = 
			      (x_1877, x_1925)
			   val x_1927: bool = 
			      = (word) x_1926
			   val x_1928: word = 
			      case x_1927 of
			      true => 
				 let
				    val x_1930: word = 
				       0x0
				 in
				    x_1930
				 end
			      false => 
				 let
				    val x_1929: word = 
				       0x1
				 in
				    x_1929
				 end
			   val x_1931: word * word = 
			      (x_1874, x_1928)
			   val dpl: word = 
			      +! x_1931
			   val x_1932: Word64.word = 
			      0x1
			   val x_1933: Word64.word = 
			      0x7
			   val x_1934: Word64.word * Word64.word = 
			      (x_1932, x_1933)
			   val x_1935: Word64.word = 
			      + x_1934
			   val x_1936: Word64.word * Word64.word = 
			      (bytesPerArrayHeader, x_1935)
			   val x_1937: Word64.word = 
			      + x_1936
			   val x_1938: Word64.word = 
			      zextdFromInt32ToWord64 dpl
			   val x_1939: Word64.word = 
			      numLimbs x_1836
			   val x_1940: Word64.word = 
			      zextdFromInt64ToWord64 x_1939
			   val x_1941: Word64.word * Word64.word = 
			      (x_1938, x_1940)
			   val x_1942: Word64.word = 
			      * x_1941
			   val x_1943: Word64.word * Word64.word = 
			      (x_1937, x_1942)
			   val bytes: Word64.word = 
			      + x_1943
			   val x_1944: Word8.word vector = 
			      IntInf_toString (x_1836, x_1838, bytes)
			in
			   x_1944
			end
	       in
		  x_1840
	       end
	 in
	    x_1835
	 end
   exception Chr
   exception Fail of Word8.word vector
   exception Span
   val 'a_1659 !: 'a_1659 ref -> 'a_1659 = 
      let
      in
	 deref ('a_1659)
      end
   val 'a_1660 :=: 'a_1660 ref * 'a_1660 -> unit = 
      let
      in
	 assign ('a_1660)
      end
   val rec ('a_1663, 'a_1662, 'a_1661) 
      o: ('a_1663 -> 'a_1662) * ('a_1661 -> 'a_1663) -> 'a_1661 -> 'a_1662 = 
	 fn x_1948: ('a_1663 -> 'a_1662) * ('a_1661 -> 'a_1663) => 
	 let
	    val x_1949: 'a_1661 -> 'a_1662 = 
	       fn x_1950: 'a_1661 => 
	       let
		  val x_1951: 'a_1661 -> 'a_1663 = 
		     #1 x_1948
		  val x_1952: 'a_1663 -> 'a_1662 = 
		     #0 x_1948
		  val x_1953: 'a_1663 = 
		     x_1951 x_1950
		  val x_1954: 'a_1662 = 
		     x_1952 x_1953
	       in
		  x_1954
	       end
	 in
	    x_1949
	 end
   val x_1955: (exn -> Word8.word vector option) list = 
      nil[exn -> Word8.word vector option]
   val messagers: (exn -> Word8.word vector option) list ref = 
      Ref_ref[(exn -> Word8.word vector option) list] (x_1955)
   val addExnMessager: (exn -> Word8.word vector option) -> unit = 
      fn x_1956: exn -> Word8.word vector option => 
      let
	 val x_1957: (exn -> Word8.word vector option) list = 
	    ! ((exn -> Word8.word vector option) list) messagers
	 val x_1958: (exn -> Word8.word vector option)
		     * (exn -> Word8.word vector option) list = 
	    (x_1956, x_1957)
	 val x_1959: (exn -> Word8.word vector option) list = 
	    ::[exn -> Word8.word vector option] x_1958
	 val x_1960: (exn -> Word8.word vector option) list ref
		     * (exn -> Word8.word vector option) list = 
	    (messagers, x_1959)
	 val x_1961: unit = 
	    := ((exn -> Word8.word vector option) list) x_1960
      in
	 x_1961
      end
   val rec 
      exnMessage: exn -> Word8.word vector = 
	 fn x_1962: exn => 
	 let
	    val rec 
	       find: (exn -> Word8.word vector option) list -> Word8.word vector = 
		  fn x_1963: (exn -> Word8.word vector option) list => 
		  let
		     val x_1964: Word8.word vector = 
			case x_1963 of
			nil[exn -> Word8.word vector option] => 
			   let
			      val x_1972: Word8.word vector = 
				 name x_1962
			   in
			      x_1972
			   end
			::[exn -> Word8.word vector option] x_1965: (exn
								     -> Word8.word vector option)
								    * (exn
								       -> Word8.word vector option) list => 
			   let
			      val x_1966: (exn -> Word8.word vector option) list = 
				 #1 x_1965
			      val x_1967: exn -> Word8.word vector option = 
				 #0 x_1965
			      val x_1968: Word8.word vector option = 
				 x_1967 x_1962
			      val x_1969: Word8.word vector = 
				 case x_1968 of
				 NONE[Word8.word vector] => 
				    let
				       val x_1971: Word8.word vector = 
					  find x_1966
				    in
				       x_1971
				    end
				 SOME[Word8.word vector] x_1970: Word8.word vector => 
				    let
				    in
				       x_1970
				    end
			   in
			      x_1969
			   end
		  in
		     x_1964
		  end
	    val x_1973: (exn -> Word8.word vector option) list = 
	       ! ((exn -> Word8.word vector option) list) messagers
	    val x_1974: Word8.word vector = 
	       find x_1973
	 in
	    x_1974
	 end
   val ('a, 'c, 'b) o_0: ('b -> 'c) * ('a -> 'b) -> 'a -> 'c = 
      let
      in
	 o ('b, 'c, 'a)
      end
   val 'a :=_0: 'a ref * 'a -> unit = 
      let
      in
	 := ('a)
      end
   val 'a !_0: 'a ref -> 'a = 
      let
      in
	 ! ('a)
      end
   val ('a, 'c, 'b) o_1: ('b -> 'c) * ('a -> 'b) -> 'a -> 'c = 
      let
      in
	 o_0 ('a, 'c, 'b)
      end
   val 'a :=_1: 'a ref * 'a -> unit = 
      let
      in
	 :=_0 ('a)
      end
   val 'a !_1: 'a ref -> 'a = 
      let
      in
	 !_0 ('a)
      end
   val rec 'a_1666 
      make: (unit -> 'a_1666) -> 'a_1666 One.t = 
	 fn x_1975: unit -> 'a_1666 => 
	 let
	    val x_1976: unit = 
	       ()
	    val x_1977: 'a_1666 = 
	       x_1975 x_1976
	    val x_1978: bool = 
	       false
	    val x_1979: bool ref = 
	       Ref_ref[bool] (x_1978)
	    val x_1980: (unit -> 'a_1666) * 'a_1666 * bool ref = 
	       (x_1975, x_1977, x_1979)
	    val x_1981: 'a_1666 One.t = 
	       T['a_1666] x_1980
	 in
	    x_1981
	 end
   val rec ('a_1668, 'a_1667) 
      use: 'a_1668 One.t * ('a_1668 -> 'a_1667) -> 'a_1667 = 
	 fn x_1982: 'a_1668 One.t * ('a_1668 -> 'a_1667) => 
	 let
	    val x_1983: 'a_1668 -> 'a_1667 = 
	       #1 x_1982
	    val x_1984: 'a_1668 One.t = 
	       #0 x_1982
	    val x_1985: 'a_1667 = 
	       case x_1984 of
	       T['a_1668] x_1986: (unit -> 'a_1668) * 'a_1668 * bool ref => 
		  let
		     val x_1987: bool ref = 
			#2 x_1986
		     val x_1988: 'a_1668 = 
			#1 x_1986
		     val x_1989: unit -> 'a_1668 = 
			#0 x_1986
		     val x_1990: unit = 
			Thread_atomicBegin ()
		     val b: bool = 
			!_1 (bool) x_1987
		     val x_1991: 'a_1668 = 
			case b of
			true => 
			   let
			      val x_1997: unit = 
				 ()
			      val x_1998: unit = 
				 atomicEnd x_1997
			      val x_1999: unit = 
				 ()
			      val x_2000: 'a_1668 = 
				 x_1989 x_1999
			   in
			      x_2000
			   end
			false => 
			   let
			      val x_1992: bool = 
				 true
			      val x_1993: bool ref * bool = 
				 (x_1987, x_1992)
			      val x_1994: unit = 
				 :=_1 (bool) x_1993
			      val x_1995: unit = 
				 ()
			      val x_1996: unit = 
				 atomicEnd x_1995
			   in
			      x_1988
			   end
		     val x_2001: unit -> 'a_1667 = 
			fn x_2002: unit => 
			let
			   val x_2003: 'a_1667 = 
			      x_1983 x_1991
			in
			   x_2003
			end
		     val x_2004: unit -> unit = 
			fn x_2005: unit => 
			let
			   val x_2006: unit = 
			      case b of
			      true => 
				 let
				    val x_2010: unit = 
				       ()
				 in
				    x_2010
				 end
			      false => 
				 let
				    val x_2007: bool = 
				       false
				    val x_2008: bool ref * bool = 
				       (x_1987, x_2007)
				    val x_2009: unit = 
				       :=_1 (bool) x_2008
				 in
				    x_2009
				 end
			in
			   x_2006
			end
		     val x_2011: (unit -> 'a_1667) * (unit -> unit) = 
			(x_2001, x_2004)
		     val x_2012: 'a_1667 = 
			wind_0 ('a_1667) x_2011
		  in
		     x_2012
		  end
	 in
	    x_1985
	 end
   val ('b, 'a) use_0: 'a One.t * ('a -> 'b) -> 'b = 
      let
      in
	 use ('a, 'b)
      end
   val 'a make_0: (unit -> 'a) -> 'a One.t = 
      let
      in
	 make ('a)
      end
   exception Option
   val rec ('a_1673, 'a_1672) 
      map: ('a_1673 -> 'a_1672) -> 'a_1673 option -> 'a_1672 option = 
	 fn x_2013: 'a_1673 -> 'a_1672 => 
	 let
	    val x_2014: 'a_1673 option -> 'a_1672 option = 
	       fn x_2015: 'a_1673 option => 
	       let
		  val x_2016: 'a_1672 option = 
		     case x_2015 of
		     NONE['a_1673] => 
			let
			   val x_2020: 'a_1672 option = 
			      NONE['a_1672]
			in
			   x_2020
			end
		     SOME['a_1673] x_2017: 'a_1673 => 
			let
			   val x_2018: 'a_1672 = 
			      x_2013 x_2017
			   val x_2019: 'a_1672 option = 
			      SOME['a_1672] x_2018
			in
			   x_2019
			end
	       in
		  x_2016
	       end
	 in
	    x_2014
	 end
   val 'a_1688 valOf: 'a_1688 option -> 'a_1688 = 
      let
	 val x_2021: 'a_1688 option -> 'a_1688 = 
	    fn x_2022: 'a_1688 option => 
	    let
	       val x_2023: 'a_1688 = 
		  case x_2022 of
		  NONE['a_1688] => 
		     let
			val x_2025: exn = 
			   Option
			val x_2026: 'a_1688 = 
			   raise x_2025
		     in
			x_2026
		     end
		  SOME['a_1688] x_2024: 'a_1688 => 
		     let
		     in
			x_2024
		     end
	    in
	       x_2023
	    end
      in
	 x_2021
      end
   val 'a valOf_0: 'a option -> 'a = 
      let
      in
	 valOf ('a)
      end
   val ('b, 'a) map_0: ('a -> 'b) -> 'a option -> 'b option = 
      let
      in
	 map ('a, 'b)
      end
   val 'a valOf_1: 'a option -> 'a = 
      let
      in
	 valOf_0 ('a)
      end
   exception Empty
   val rec ('a_1699, 'a_1698) 
      foldl: ('a_1699 * 'a_1698 -> 'a_1698)
	     -> 'a_1698 -> 'a_1699 list -> 'a_1698 = 
	 fn x_2027: 'a_1699 * 'a_1698 -> 'a_1698 => 
	 let
	    val x_2028: 'a_1698 -> 'a_1699 list -> 'a_1698 = 
	       fn x_2029: 'a_1698 => 
	       let
		  val x_2030: 'a_1699 list -> 'a_1698 = 
		     fn x_2031: 'a_1699 list => 
		     let
			val rec 
			   loop: 'a_1699 list * 'a_1698 -> 'a_1698 = 
			      fn x_2032: 'a_1699 list * 'a_1698 => 
			      let
				 val b: 'a_1698 = 
				    #1 x_2032
				 val l: 'a_1699 list = 
				    #0 x_2032
				 val x_2033: 'a_1698 = 
				    case l of
				    nil['a_1699] => 
				       let
				       in
					  b
				       end
				    ::['a_1699] x_2034: 'a_1699 * 'a_1699 list => 
				       let
					  val x_2035: 'a_1699 list = 
					     #1 x_2034
					  val x_2036: 'a_1699 = 
					     #0 x_2034
					  val x_2037: 'a_1699 * 'a_1698 = 
					     (x_2036, b)
					  val x_2038: 'a_1698 = 
					     x_2027 x_2037
					  val x_2039: 'a_1699 list * 'a_1698 = 
					     (x_2035, x_2038)
					  val x_2040: 'a_1698 = 
					     loop x_2039
				       in
					  x_2040
				       end
			      in
				 x_2033
			      end
			val x_2041: 'a_1699 list * 'a_1698 = 
			   (x_2031, x_2029)
			val x_2042: 'a_1698 = 
			   loop x_2041
		     in
			x_2042
		     end
	       in
		  x_2030
	       end
	 in
	    x_2028
	 end
   val rec 'a_1700 
      length: 'a_1700 list -> word = 
	 fn x_2043: 'a_1700 list => 
	 let
	    val x_2044: 'a_1700 * word -> word = 
	       fn x_2045: 'a_1700 * word => 
	       let
		  val x_2046: word = 
		     #1 x_2045
		  val x_2047: word = 
		     0x1
		  val x_2048: word * word = 
		     (x_2046, x_2047)
		  val x_2049: word = 
		     +? x_2048
	       in
		  x_2049
	       end
	    val x_2050: word -> 'a_1700 list -> word = 
	       foldl ('a_1700, word) x_2044
	    val x_2051: word = 
	       0x0
	    val x_2052: 'a_1700 list -> word = 
	       x_2050 x_2051
	    val x_2053: word = 
	       x_2052 x_2043
	 in
	    x_2053
	 end
   val rec 'a_1701 
      appendRev: 'a_1701 list * 'a_1701 list -> 'a_1701 list = 
	 fn x_2054: 'a_1701 list * 'a_1701 list => 
	 let
	    val l2: 'a_1701 list = 
	       #1 x_2054
	    val l1: 'a_1701 list = 
	       #0 x_2054
	    val x_2055: 'a_1701 * 'a_1701 list -> 'a_1701 list = 
	       fn x_2056: 'a_1701 * 'a_1701 list => 
	       let
		  val x_2057: 'a_1701 list = 
		     ::['a_1701] x_2056
	       in
		  x_2057
	       end
	    val x_2058: 'a_1701 list -> 'a_1701 list -> 'a_1701 list = 
	       foldl ('a_1701, 'a_1701 list) x_2055
	    val x_2059: 'a_1701 list -> 'a_1701 list = 
	       x_2058 l2
	    val x_2060: 'a_1701 list = 
	       x_2059 l1
	 in
	    x_2060
	 end
   val rec 'a_1703 
      rev: 'a_1703 list -> 'a_1703 list = 
	 fn x_2061: 'a_1703 list => 
	 let
	    val x_2062: 'a_1703 list = 
	       nil['a_1703]
	    val x_2063: 'a_1703 list * 'a_1703 list = 
	       (x_2061, x_2062)
	    val x_2064: 'a_1703 list = 
	       appendRev ('a_1703) x_2063
	 in
	    x_2064
	 end
   val rec 'a_1708 
      app: ('a_1708 -> unit) -> 'a_1708 list -> unit = 
	 fn x_2065: 'a_1708 -> unit => 
	 let
	    val x_2066: 'a_1708 * unit -> 'a_1708 = 
	       fn x_2067: 'a_1708 * unit => 
	       let
		  val x_2068: 'a_1708 = 
		     #0 x_2067
	       in
		  x_2068
	       end
	    val x_2069: ('a_1708 -> unit) * ('a_1708 * unit -> 'a_1708) = 
	       (x_2065, x_2066)
	    val x_2070: 'a_1708 * unit -> unit = 
	       o_1 ('a_1708 * unit, unit, 'a_1708) x_2069
	    val x_2071: unit -> 'a_1708 list -> unit = 
	       foldl ('a_1708, unit) x_2070
	    val x_2072: unit = 
	       ()
	    val x_2073: 'a_1708 list -> unit = 
	       x_2071 x_2072
	 in
	    x_2073
	 end
   val rec ('a_1710, 'a_1709) 
      map: ('a_1710 -> 'a_1709) -> 'a_1710 list -> 'a_1709 list = 
	 fn x_2074: 'a_1710 -> 'a_1709 => 
	 let
	    val x_2075: 'a_1710 list -> 'a_1709 list = 
	       fn x_2076: 'a_1710 list => 
	       let
		  val x_2077: 'a_1710 * 'a_1709 list -> 'a_1709 list = 
		     fn x_2078: 'a_1710 * 'a_1709 list => 
		     let
			val l: 'a_1709 list = 
			   #1 x_2078
			val x: 'a_1710 = 
			   #0 x_2078
			val x_2079: 'a_1709 = 
			   x_2074 x
			val x_2080: 'a_1709 * 'a_1709 list = 
			   (x_2079, l)
			val x_2081: 'a_1709 list = 
			   ::['a_1709] x_2080
		     in
			x_2081
		     end
		  val x_2082: 'a_1709 list -> 'a_1710 list -> 'a_1709 list = 
		     foldl ('a_1710, 'a_1709 list) x_2077
		  val x_2083: 'a_1709 list = 
		     nil['a_1709]
		  val x_2084: 'a_1710 list -> 'a_1709 list = 
		     x_2082 x_2083
		  val x_2085: 'a_1709 list = 
		     x_2084 x_2076
		  val x_2086: 'a_1709 list = 
		     rev ('a_1709) x_2085
	       in
		  x_2086
	       end
	 in
	    x_2075
	 end
   val rec 'a_1715 
      find: ('a_1715 -> bool) -> 'a_1715 list -> 'a_1715 option = 
	 fn x_2087: 'a_1715 -> bool => 
	 let
	    val rec 
	       loop: 'a_1715 list -> 'a_1715 option = 
		  fn x_2088: 'a_1715 list => 
		  let
		     val x_2089: 'a_1715 option = 
			case x_2088 of
			nil['a_1715] => 
			   let
			      val x_2097: 'a_1715 option = 
				 NONE['a_1715]
			   in
			      x_2097
			   end
			::['a_1715] x_2090: 'a_1715 * 'a_1715 list => 
			   let
			      val x_2091: 'a_1715 list = 
				 #1 x_2090
			      val x_2092: 'a_1715 = 
				 #0 x_2090
			      val x_2093: bool = 
				 x_2087 x_2092
			      val x_2094: 'a_1715 option = 
				 case x_2093 of
				 true => 
				    let
				       val x_2096: 'a_1715 option = 
					  SOME['a_1715] x_2092
				    in
				       x_2096
				    end
				 false => 
				    let
				       val x_2095: 'a_1715 option = 
					  loop x_2091
				    in
				       x_2095
				    end
			   in
			      x_2094
			   end
		  in
		     x_2089
		  end
	 in
	    loop
	 end
   val 'a rev_0: 'a list -> 'a list = 
      let
      in
	 rev ('a)
      end
   val ('b, 'a) map_1: ('a -> 'b) -> 'a list -> 'b list = 
      let
      in
	 map ('a, 'b)
      end
   val 'a length_0: 'a list -> word = 
      let
      in
	 length ('a)
      end
   val ('b, 'a) foldl_0: ('a * 'b -> 'b) -> 'b -> 'a list -> 'b = 
      let
      in
	 foldl ('a, 'b)
      end
   val 'a find_0: ('a -> bool) -> 'a list -> 'a option = 
      let
      in
	 find ('a)
      end
   val 'a app_0: ('a -> unit) -> 'a list -> unit = 
      let
      in
	 app ('a)
      end
   val 'a rev_1: 'a list -> 'a list = 
      let
      in
	 rev_0 ('a)
      end
   val ('b, 'a) map_2: ('a -> 'b) -> 'a list -> 'b list = 
      let
      in
	 map_1 ('b, 'a)
      end
   val 'a app_1: ('a -> unit) -> 'a list -> unit = 
      let
      in
	 app_0 ('a)
      end
   exception UnequalLengths
   val 'a_2004 fromArray: 'a_2004 array -> 'a_2004 vector = 
      let
      in
	 fromArrayUnsafe ('a_2004)
      end
   val isMutable: bool = 
      false
   val 'a_2005 length: 'a_2005 vector -> Word64.word = 
      let
      in
	 length ('a_2005)
      end
   val 'a_2006 subUnsafe: 'a_2006 vector * Word64.word -> 'a_2006 = 
      let
      in
	 subUnsafe ('a_2006)
      end
   val 'a subUnsafe_0: 'a vector * Word64.word -> 'a = 
      let
      in
	 subUnsafe ('a)
      end
   val 'a length_1: 'a vector -> Word64.word = 
      let
      in
	 length ('a)
      end
   val 'a fromArray_0: 'a array -> 'a vector = 
      let
      in
	 fromArray ('a)
      end
   val rec ('a_2012, 'a_2011) 
      wrap2: (word * 'a_2012 -> 'a_2011) -> Word64.word * 'a_2012 -> 'a_2011 = 
	 fn x_2098: word * 'a_2012 -> 'a_2011 => 
	 let
	    val x_2099: Word64.word * 'a_2012 -> 'a_2011 = 
	       fn x_2100: Word64.word * 'a_2012 => 
	       let
		  val x: 'a_2012 = 
		     #1 x_2100
		  val i: Word64.word = 
		     #0 x_2100
		  val x_2101: word = 
		     sextdFromInt64ToInt32 i
		  val x_2102: word * 'a_2012 = 
		     (x_2101, x)
		  val x_2103: 'a_2011 = 
		     x_2098 x_2102
	       in
		  x_2103
	       end
	 in
	    x_2099
	 end
   val rec 'a_2019 
      doit: word * (Word64.word -> 'a_2019) * ('a_2019 -> Word64.word) * 'a_2019
	    -> Word64.word * 'a_2019 = 
	 fn x_2104: word
		    * (Word64.word -> 'a_2019)
		    * ('a_2019 -> Word64.word)
		    * 'a_2019 => 
	 let
	    val maxInt': 'a_2019 = 
	       #3 x_2104
	    val fromInt: 'a_2019 -> Word64.word = 
	       #2 x_2104
	    val toInt: Word64.word -> 'a_2019 = 
	       #1 x_2104
	    val precision: word = 
	       #0 x_2104
	    val x_2105: word = 
	       valOf_1 (word) precision
	    val x_2106: word * word = 
	       (x_2105, precision)
	    val x_2107: bool = 
	       >= x_2106
	    val x_2108: Word64.word * 'a_2019 = 
	       case x_2107 of
	       true => 
		  let
		     val x_2111: Word64.word = 
			fromInt maxInt'
		     val x_2112: Word64.word * 'a_2019 = 
			(x_2111, maxInt')
		  in
		     x_2112
		  end
	       false => 
		  let
		     val x_2109: 'a_2019 = 
			toInt maxInt'
		     val x_2110: Word64.word * 'a_2019 = 
			(maxInt', x_2109)
		  in
		     x_2110
		  end
	 in
	    x_2108
	 end
   val x_2113: word = 
      valOf_1 (word) precision
   val x_2114: word
	       * (Word64.word -> Word8.word)
	       * (Word8.word -> Word64.word)
	       * Word8.word = 
      (x_2113, schckFromInt64ToInt8, sextdFromInt8ToInt64, maxInt')
   val fInt8: Word64.word * Word8.word = 
      doit (Word8.word) x_2114
   val x_2115: word = 
      valOf_1 (word) precision
   val x_2116: word
	       * (Word64.word -> Word16.word)
	       * (Word16.word -> Word64.word)
	       * Word16.word = 
      (x_2115, schckFromInt64ToInt16, sextdFromInt16ToInt64, maxInt')
   val fInt16: Word64.word * Word16.word = 
      doit (Word16.word) x_2116
   val x_2117: word = 
      valOf_1 (word) precision
   val x_2118: word * (Word64.word -> word) * (word -> Word64.word) * word = 
      (x_2117, schckFromInt64ToInt32, sextdFromInt32ToInt64, maxInt')
   val fInt32: Word64.word * word = 
      doit (word) x_2118
   val x_2119: word = 
      valOf_1 (word) precision
   val x_2120: word
	       * (Word64.word -> Word64.word)
	       * (Word64.word -> Word64.word)
	       * Word64.word = 
      (x_2119, sextdFromInt64ToInt64, sextdFromInt64ToInt64, maxInt')
   val fInt64: Word64.word * Word64.word = 
      doit (Word64.word) x_2120
   val x_2121: IntInf.int = 
      sextdFromInt64 maxInt'
   val maxLen': Word64.word = 
      #0 fInt32
   val rec 'a_2022 
      length': 'a_2022 vector -> Word64.word = 
	 fn x_2122: 'a_2022 vector => 
	 let
	    val x_2123: Word64.word = 
	       length_1 ('a_2022) x_2122
	 in
	    x_2123
	 end
   val rec 'a_2023 
      length: 'a_2023 vector -> word = 
	 fn x_2124: 'a_2023 vector => 
	 let
	    val x_2125: word = 
	       let
		  val x_2126: Word64.word = 
		     length' ('a_2023) x_2124
		  val x_2127: word = 
		     schckFromInt64ToInt32 x_2126
	       in
		  x_2127
	       end
	       handle x_2128 => let
				   val x_2129: word = 
				      case x_2128 of
				      Overflow => 
					 let
					    val x_2130: Word8.word vector = 
					       "Sequence.length"
					    val x_2131: exn = 
					       Fail x_2130
					    val x_2132: word = 
					       raise x_2131
					 in
					    x_2132
					 end
					_ => let
						val x_2133: word = 
						   raise x_2128
					     in
						x_2133
					     end
				in
				   x_2129
				end
	 in
	    x_2125
	 end
   val rec 'a_2024 
      arrayUninit': Word64.word -> 'a_2024 array = 
	 fn x_2134: Word64.word => 
	 let
	    val x_2135: bool = 
	       not isMutable
	    val x_2136: bool = 
	       case x_2135 of
	       true => 
		  let
		     val x_2138: Word64.word = 
			0x0
		     val x_2139: Word64.word * Word64.word = 
			(x_2134, x_2138)
		     val x_2140: bool = 
			= (Word64.word) x_2139
		  in
		     x_2140
		  end
	       false => 
		  let
		     val x_2137: bool = 
			false
		  in
		     x_2137
		  end
	    val x_2141: 'a_2024 array = 
	       case x_2136 of
	       true => 
		  let
		     val x_2148: unit = 
			()
		     val x_2149: 'a_2024 array = 
			array0Const ('a_2024) x_2148
		  in
		     x_2149
		  end
	       false => 
		  let
		     val x_2142: Word64.word * Word64.word = 
			(x_2134, maxLen')
		     val x_2143: bool = 
			> x_2142
		     val x_2144: 'a_2024 array = 
			case x_2143 of
			true => 
			   let
			      val x_2146: exn = 
				 Size
			      val x_2147: 'a_2024 array = 
				 raise x_2146
			   in
			      x_2147
			   end
			false => 
			   let
			      val x_2145: 'a_2024 array = 
				 arrayUnsafe ('a_2024) x_2134
			   in
			      x_2145
			   end
		  in
		     x_2144
		  end
	 in
	    x_2141
	 end
   val rec ('a_2031, 'a_2030) 
      unfoldi': Word64.word
		* 'a_2031
		* (Word64.word * 'a_2031 -> 'a_2030 * 'a_2031)
		-> 'a_2030 vector * 'a_2031 = 
	 fn x_2150: Word64.word
		    * 'a_2031
		    * (Word64.word * 'a_2031 -> 'a_2030 * 'a_2031) => 
	 let
	    val f: Word64.word * 'a_2031 -> 'a_2030 * 'a_2031 = 
	       #2 x_2150
	    val b: 'a_2031 = 
	       #1 x_2150
	    val n: Word64.word = 
	       #0 x_2150
	    val a: 'a_2030 array = 
	       arrayUninit' ('a_2030) n
	    val rec 
	       loop: Word64.word * 'a_2031 -> 'a_2031 = 
		  fn x_2151: Word64.word * 'a_2031 => 
		  let
		     val b: 'a_2031 = 
			#1 x_2151
		     val i: Word64.word = 
			#0 x_2151
		     val x_2152: Word64.word * Word64.word = 
			(i, n)
		     val x_2153: bool = 
			>= x_2152
		     val x_2154: 'a_2031 = 
			case x_2153 of
			true => 
			   let
			   in
			      b
			   end
			false => 
			   let
			      val x_2155: Word64.word * 'a_2031 = 
				 (i, b)
			      val x_2156: 'a_2030 * 'a_2031 = 
				 f x_2155
			      val b': 'a_2031 = 
				 #1 x_2156
			      val x: 'a_2030 = 
				 #0 x_2156
			      val x_2157: 'a_2030 array * Word64.word * 'a_2030 = 
				 (a, i, x)
			      val x_2158: unit = 
				 updateUnsafe ('a_2030) x_2157
			      val x_2159: Word64.word = 
				 0x1
			      val x_2160: Word64.word * Word64.word = 
				 (i, x_2159)
			      val x_2161: Word64.word = 
				 +? x_2160
			      val x_2162: Word64.word * 'a_2031 = 
				 (x_2161, b')
			      val x_2163: 'a_2031 = 
				 loop x_2162
			   in
			      x_2163
			   end
		  in
		     x_2154
		  end
	    val x_2164: Word64.word = 
	       0x0
	    val x_2165: Word64.word * 'a_2031 = 
	       (x_2164, b)
	    val b: 'a_2031 = 
	       loop x_2165
	    val x_2166: 'a_2030 vector = 
	       fromArray_0 ('a_2030) a
	    val x_2167: 'a_2030 vector * 'a_2031 = 
	       (x_2166, b)
	 in
	    x_2167
	 end
   val rec ('a_2033, 'a_2032) 
      unfoldi: word * 'a_2032 * (word * 'a_2032 -> 'a_2033 * 'a_2032)
	       -> 'a_2033 vector * 'a_2032 = 
	 fn x_2168: word * 'a_2032 * (word * 'a_2032 -> 'a_2033 * 'a_2032) => 
	 let
	    val f: word * 'a_2032 -> 'a_2033 * 'a_2032 = 
	       #2 x_2168
	    val b: 'a_2032 = 
	       #1 x_2168
	    val n: word = 
	       #0 x_2168
	    val x_2169: Word64.word = 
	       let
		  val x_2170: Word64.word = 
		     sextdFromInt32ToInt64 n
	       in
		  x_2170
	       end
	       handle x_2171 => let
				   val x_2172: Word64.word = 
				      case x_2171 of
				      Overflow => 
					 let
					    val x_2173: exn = 
					       Size
					    val x_2174: Word64.word = 
					       raise x_2173
					 in
					    x_2174
					 end
					_ => let
						val x_2175: Word64.word = 
						   raise x_2171
					     in
						x_2175
					     end
				in
				   x_2172
				end
	    val x_2176: Word64.word * 'a_2032 -> 'a_2033 * 'a_2032 = 
	       wrap2 ('a_2032, 'a_2033 * 'a_2032) f
	    val x_2177: Word64.word
			* 'a_2032
			* (Word64.word * 'a_2032 -> 'a_2033 * 'a_2032) = 
	       (x_2169, b, x_2176)
	    val x_2178: 'a_2033 vector * 'a_2032 = 
	       unfoldi' ('a_2032, 'a_2033) x_2177
	 in
	    x_2178
	 end
   val rec ('a_2035, 'a_2034) 
      unfold: word * 'a_2034 * ('a_2034 -> 'a_2035 * 'a_2034)
	      -> 'a_2035 vector * 'a_2034 = 
	 fn x_2179: word * 'a_2034 * ('a_2034 -> 'a_2035 * 'a_2034) => 
	 let
	    val f: 'a_2034 -> 'a_2035 * 'a_2034 = 
	       #2 x_2179
	    val b: 'a_2034 = 
	       #1 x_2179
	    val n: word = 
	       #0 x_2179
	    val x_2180: word * 'a_2034 -> 'a_2034 = 
	       fn x_2181: word * 'a_2034 => 
	       let
		  val x_2182: 'a_2034 = 
		     #1 x_2181
	       in
		  x_2182
	       end
	    val x_2183: ('a_2034 -> 'a_2035 * 'a_2034)
			* (word * 'a_2034 -> 'a_2034) = 
	       (f, x_2180)
	    val x_2184: word * 'a_2034 -> 'a_2035 * 'a_2034 = 
	       o_1 (word * 'a_2034, 'a_2035 * 'a_2034, 'a_2034) x_2183
	    val x_2185: word * 'a_2034 * (word * 'a_2034 -> 'a_2035 * 'a_2034) = 
	       (n, b, x_2184)
	    val x_2186: 'a_2035 vector * 'a_2034 = 
	       unfoldi ('a_2035, 'a_2034) x_2185
	 in
	    x_2186
	 end
   val rec 'a_2036 
      seq0: unit -> 'a_2036 vector = 
	 fn x_2187: unit => 
	 let
	    val x_2188: word = 
	       0x0
	    val x_2189: unit = 
	       ()
	    val x_2190: unit -> 'a_2036 * unit = 
	       fn x_2191: unit => 
	       let
		  val x_2192: Word8.word vector = 
		     "Sequence.seq0"
		  val x_2193: exn = 
		     Fail x_2192
		  val x_2194: 'a_2036 * unit = 
		     raise x_2193
	       in
		  x_2194
	       end
	    val x_2195: word * unit * (unit -> 'a_2036 * unit) = 
	       (x_2188, x_2189, x_2190)
	    val x_2196: 'a_2036 vector * unit = 
	       unfold ('a_2036, unit) x_2195
	    val x_2197: 'a_2036 vector = 
	       #0 x_2196
	 in
	    x_2197
	 end
   val rec 'a_2037 
      tabulate': Word64.word * (Word64.word -> 'a_2037) -> 'a_2037 vector = 
	 fn x_2198: Word64.word * (Word64.word -> 'a_2037) => 
	 let
	    val f: Word64.word -> 'a_2037 = 
	       #1 x_2198
	    val n: Word64.word = 
	       #0 x_2198
	    val x_2199: unit = 
	       ()
	    val x_2200: Word64.word * unit -> 'a_2037 * unit = 
	       fn x_2201: Word64.word * unit => 
	       let
		  val x_2202: Word64.word = 
		     #0 x_2201
		  val x_2203: 'a_2037 = 
		     f x_2202
		  val x_2204: unit = 
		     ()
		  val x_2205: 'a_2037 * unit = 
		     (x_2203, x_2204)
	       in
		  x_2205
	       end
	    val x_2206: Word64.word
			* unit
			* (Word64.word * unit -> 'a_2037 * unit) = 
	       (n, x_2199, x_2200)
	    val x_2207: 'a_2037 vector * unit = 
	       unfoldi' (unit, 'a_2037) x_2206
	    val x_2208: 'a_2037 vector = 
	       #0 x_2207
	 in
	    x_2208
	 end
   val rec 'a_2038 
      tabulate: word * (word -> 'a_2038) -> 'a_2038 vector = 
	 fn x_2209: word * (word -> 'a_2038) => 
	 let
	    val f: word -> 'a_2038 = 
	       #1 x_2209
	    val n: word = 
	       #0 x_2209
	    val x_2210: unit = 
	       ()
	    val x_2211: word * unit -> 'a_2038 * unit = 
	       fn x_2212: word * unit => 
	       let
		  val x_2213: word = 
		     #0 x_2212
		  val x_2214: 'a_2038 = 
		     f x_2213
		  val x_2215: unit = 
		     ()
		  val x_2216: 'a_2038 * unit = 
		     (x_2214, x_2215)
	       in
		  x_2216
	       end
	    val x_2217: word * unit * (word * unit -> 'a_2038 * unit) = 
	       (n, x_2210, x_2211)
	    val x_2218: 'a_2038 vector * unit = 
	       unfoldi ('a_2038, unit) x_2217
	    val x_2219: 'a_2038 vector = 
	       #0 x_2218
	 in
	    x_2219
	 end
   val rec 'a_2040 
      new: word * 'a_2040 -> 'a_2040 vector = 
	 fn x_2220: word * 'a_2040 => 
	 let
	    val x: 'a_2040 = 
	       #1 x_2220
	    val n: word = 
	       #0 x_2220
	    val x_2221: word -> 'a_2040 = 
	       fn x_2222: word => 
	       let
	       in
		  x
	       end
	    val x_2223: word * (word -> 'a_2040) = 
	       (n, x_2221)
	    val x_2224: 'a_2040 vector = 
	       tabulate ('a_2040) x_2223
	 in
	    x_2224
	 end
   val rec 'a_2041 
      fromList: 'a_2041 list -> 'a_2041 vector = 
	 fn x_2225: 'a_2041 list => 
	 let
	    val x_2226: word = 
	       length_0 ('a_2041) x_2225
	    val x_2227: 'a_2041 list -> 'a_2041 * 'a_2041 list = 
	       fn x_2228: 'a_2041 list => 
	       let
		  val x_2229: 'a_2041 * 'a_2041 list = 
		     case x_2228 of
		     nil['a_2041] => 
			let
			   val x_2234: Word8.word vector = 
			      "Sequence.fromList"
			   val x_2235: exn = 
			      Fail x_2234
			   val x_2236: 'a_2041 * 'a_2041 list = 
			      raise x_2235
			in
			   x_2236
			end
		     ::['a_2041] x_2230: 'a_2041 * 'a_2041 list => 
			let
			   val x_2231: 'a_2041 list = 
			      #1 x_2230
			   val x_2232: 'a_2041 = 
			      #0 x_2230
			   val x_2233: 'a_2041 * 'a_2041 list = 
			      (x_2232, x_2231)
			in
			   x_2233
			end
	       in
		  x_2229
	       end
	    val x_2237: word
			* 'a_2041 list
			* ('a_2041 list -> 'a_2041 * 'a_2041 list) = 
	       (x_2226, x_2225, x_2227)
	    val x_2238: 'a_2041 vector * 'a_2041 list = 
	       unfold ('a_2041, 'a_2041 list) x_2237
	    val x_2239: 'a_2041 vector = 
	       #0 x_2238
	 in
	    x_2239
	 end
   val rec 'a_2042 
      length': 'a_2042 VectorSlice.slice -> Word64.word = 
	 fn x_2240: 'a_2042 VectorSlice.slice => 
	 let
	    val x_2241: Word64.word = 
	       case x_2240 of
	       T['a_2042] x_2242: Word64.word * 'a_2042 vector * Word64.word => 
		  let
		     val x_2243: Word64.word = 
			#0 x_2242
		  in
		     x_2243
		  end
	 in
	    x_2241
	 end
   val rec 'a_2044 
      unsafeSub': 'a_2044 VectorSlice.slice * Word64.word -> 'a_2044 = 
	 fn x_2244: 'a_2044 VectorSlice.slice * Word64.word => 
	 let
	    val x_2245: Word64.word = 
	       #1 x_2244
	    val x_2246: 'a_2044 VectorSlice.slice = 
	       #0 x_2244
	    val x_2247: 'a_2044 = 
	       case x_2246 of
	       T['a_2044] x_2248: Word64.word * 'a_2044 vector * Word64.word => 
		  let
		     val x_2249: Word64.word = 
			#2 x_2248
		     val x_2250: 'a_2044 vector = 
			#1 x_2248
		     val x_2251: Word64.word * Word64.word = 
			(x_2249, x_2245)
		     val x_2252: Word64.word = 
			+? x_2251
		     val x_2253: 'a_2044 vector * Word64.word = 
			(x_2250, x_2252)
		     val x_2254: 'a_2044 = 
			subUnsafe_0 ('a_2044) x_2253
		  in
		     x_2254
		  end
	 in
	    x_2247
	 end
   val rec 'a_2045 
      unsafeSub: 'a_2045 VectorSlice.slice * word -> 'a_2045 = 
	 fn x_2255: 'a_2045 VectorSlice.slice * word => 
	 let
	    val i: word = 
	       #1 x_2255
	    val sl: 'a_2045 VectorSlice.slice = 
	       #0 x_2255
	    val x_2256: Word64.word = 
	       sextdFromInt32ToInt64 i
	    val x_2257: 'a_2045 VectorSlice.slice * Word64.word = 
	       (sl, x_2256)
	    val x_2258: 'a_2045 = 
	       unsafeSub' ('a_2045) x_2257
	 in
	    x_2258
	 end
   val rec 'a_2046 
      sub': 'a_2046 VectorSlice.slice * Word64.word -> 'a_2046 = 
	 fn x_2259: 'a_2046 VectorSlice.slice * Word64.word => 
	 let
	    val x_2260: Word64.word = 
	       #1 x_2259
	    val x_2261: 'a_2046 VectorSlice.slice = 
	       #0 x_2259
	    val x_2262: 'a_2046 = 
	       case x_2261 of
	       T['a_2046] x_2263: Word64.word * 'a_2046 vector * Word64.word => 
		  let
		     val x_2264: Word64.word = 
			#0 x_2263
		     val x_2265: Word64.word * Word64.word = 
			(x_2260, x_2264)
		     val x_2266: bool = 
			>= x_2265
		     val x_2267: 'a_2046 = 
			case x_2266 of
			true => 
			   let
			      val x_2270: exn = 
				 Subscript
			      val x_2271: 'a_2046 = 
				 raise x_2270
			   in
			      x_2271
			   end
			false => 
			   let
			      val x_2268: 'a_2046 VectorSlice.slice
					  * Word64.word = 
				 (x_2261, x_2260)
			      val x_2269: 'a_2046 = 
				 unsafeSub' ('a_2046) x_2268
			   in
			      x_2269
			   end
		  in
		     x_2267
		  end
	 in
	    x_2262
	 end
   val rec 'a_2047 
      sub: 'a_2047 VectorSlice.slice * word -> 'a_2047 = 
	 fn x_2272: 'a_2047 VectorSlice.slice * word => 
	 let
	    val i: word = 
	       #1 x_2272
	    val sl: 'a_2047 VectorSlice.slice = 
	       #0 x_2272
	    val i: Word64.word = 
	       let
		  val x_2273: Word64.word = 
		     sextdFromInt32ToInt64 i
	       in
		  x_2273
	       end
	       handle x_2274 => let
				   val x_2275: Word64.word = 
				      case x_2274 of
				      Overflow => 
					 let
					    val x_2276: exn = 
					       Subscript
					    val x_2277: Word64.word = 
					       raise x_2276
					 in
					    x_2277
					 end
					_ => let
						val x_2278: Word64.word = 
						   raise x_2274
					     in
						x_2278
					     end
				in
				   x_2275
				end
	    val x_2279: 'a_2047 VectorSlice.slice * Word64.word = 
	       (sl, i)
	    val x_2280: 'a_2047 = 
	       sub' ('a_2047) x_2279
	 in
	    x_2280
	 end
   val rec 'a 
      full: 'a vector -> 'a VectorSlice.slice = 
	 fn x_2281: 'a vector => 
	 let
	    val x_2282: Word64.word = 
	       0x0
	    val x_2283: Word64.word = 
	       length_1 ('a) x_2281
	    val x_2284: Word64.word * 'a vector * Word64.word = 
	       (x_2283, x_2281, x_2282)
	    val x_2285: 'a VectorSlice.slice = 
	       T['a] x_2284
	 in
	    x_2285
	 end
   val rec 'a_2060 
      unsafeSubslice': 'a_2060 VectorSlice.slice
		       * Word64.word
		       * Word64.word option
		       -> 'a_2060 VectorSlice.slice = 
	 fn x_2286: 'a_2060 VectorSlice.slice * Word64.word * Word64.word option => 
	 let
	    val x_2287: Word64.word option = 
	       #2 x_2286
	    val x_2288: Word64.word = 
	       #1 x_2286
	    val x_2289: 'a_2060 VectorSlice.slice = 
	       #0 x_2286
	    val x_2290: 'a_2060 VectorSlice.slice = 
	       case x_2289 of
	       T['a_2060] x_2291: Word64.word * 'a_2060 vector * Word64.word => 
		  let
		     val x_2292: Word64.word = 
			#2 x_2291
		     val x_2293: 'a_2060 vector = 
			#1 x_2291
		     val x_2294: Word64.word = 
			#0 x_2291
		     val x_2295: Word64.word * Word64.word = 
			(x_2292, x_2288)
		     val x_2296: Word64.word = 
			+? x_2295
		     val x_2297: Word64.word = 
			case x_2287 of
			NONE[Word64.word] => 
			   let
			      val x_2299: Word64.word * Word64.word = 
				 (x_2294, x_2288)
			      val x_2300: Word64.word = 
				 -? x_2299
			   in
			      x_2300
			   end
			SOME[Word64.word] x_2298: Word64.word => 
			   let
			   in
			      x_2298
			   end
		     val x_2301: Word64.word * 'a_2060 vector * Word64.word = 
			(x_2297, x_2293, x_2296)
		     val x_2302: 'a_2060 VectorSlice.slice = 
			T['a_2060] x_2301
		  in
		     x_2302
		  end
	 in
	    x_2290
	 end
   val rec 'a_2061 
      unsafeSubslice: 'a_2061 VectorSlice.slice * word * word option
		      -> 'a_2061 VectorSlice.slice = 
	 fn x_2303: 'a_2061 VectorSlice.slice * word * word option => 
	 let
	    val len: word option = 
	       #2 x_2303
	    val start: word = 
	       #1 x_2303
	    val sl: 'a_2061 VectorSlice.slice = 
	       #0 x_2303
	    val x_2304: Word64.word = 
	       sextdFromInt32ToInt64 start
	    val x_2305: word option -> Word64.word option = 
	       map_0 (Word64.word, word) sextdFromInt32ToInt64
	    val x_2306: Word64.word option = 
	       x_2305 len
	    val x_2307: 'a_2061 VectorSlice.slice
			* Word64.word
			* Word64.word option = 
	       (sl, x_2304, x_2306)
	    val x_2308: 'a_2061 VectorSlice.slice = 
	       unsafeSubslice' ('a_2061) x_2307
	 in
	    x_2308
	 end
   val rec 'a_2062 
      unsafeSlice': 'a_2062 vector * Word64.word * Word64.word option
		    -> 'a_2062 VectorSlice.slice = 
	 fn x_2309: 'a_2062 vector * Word64.word * Word64.word option => 
	 let
	    val len: Word64.word option = 
	       #2 x_2309
	    val start: Word64.word = 
	       #1 x_2309
	    val seq: 'a_2062 vector = 
	       #0 x_2309
	    val x_2310: 'a_2062 VectorSlice.slice = 
	       full ('a_2062) seq
	    val x_2311: 'a_2062 VectorSlice.slice
			* Word64.word
			* Word64.word option = 
	       (x_2310, start, len)
	    val x_2312: 'a_2062 VectorSlice.slice = 
	       unsafeSubslice' ('a_2062) x_2311
	 in
	    x_2312
	 end
   val rec 'a_2064 
      subslice': 'a_2064 VectorSlice.slice * Word64.word * Word64.word option
		 -> 'a_2064 VectorSlice.slice = 
	 fn x_2313: 'a_2064 VectorSlice.slice * Word64.word * Word64.word option => 
	 let
	    val x_2314: Word64.word option = 
	       #2 x_2313
	    val x_2315: Word64.word = 
	       #1 x_2313
	    val x_2316: 'a_2064 VectorSlice.slice = 
	       #0 x_2313
	    val x_2317: 'a_2064 VectorSlice.slice = 
	       case x_2316 of
	       T['a_2064] x_2318: Word64.word * 'a_2064 vector * Word64.word => 
		  let
		     val x_2319: Word64.word = 
			#2 x_2318
		     val x_2320: 'a_2064 vector = 
			#1 x_2318
		     val x_2321: Word64.word = 
			#0 x_2318
		     val x_2322: 'a_2064 VectorSlice.slice = 
			case x_2314 of
			NONE[Word64.word] => 
			   let
			      val x_2339: Word64.word * Word64.word = 
				 (x_2315, x_2321)
			      val x_2340: bool = 
				 > x_2339
			      val x_2341: 'a_2064 VectorSlice.slice = 
				 case x_2340 of
				 true => 
				    let
				       val x_2348: exn = 
					  Subscript
				       val x_2349: 'a_2064 VectorSlice.slice = 
					  raise x_2348
				    in
				       x_2349
				    end
				 false => 
				    let
				       val x_2342: Word64.word * Word64.word = 
					  (x_2319, x_2315)
				       val x_2343: Word64.word = 
					  +? x_2342
				       val x_2344: Word64.word * Word64.word = 
					  (x_2321, x_2315)
				       val x_2345: Word64.word = 
					  -? x_2344
				       val x_2346: Word64.word
						   * 'a_2064 vector
						   * Word64.word = 
					  (x_2345, x_2320, x_2343)
				       val x_2347: 'a_2064 VectorSlice.slice = 
					  T['a_2064] x_2346
				    in
				       x_2347
				    end
			   in
			      x_2341
			   end
			SOME[Word64.word] x_2323: Word64.word => 
			   let
			      val x_2324: Word64.word * Word64.word = 
				 (x_2315, x_2321)
			      val x_2325: bool = 
				 > x_2324
			      val x_2326: bool = 
				 case x_2325 of
				 true => 
				    let
				       val x_2331: bool = 
					  true
				    in
				       x_2331
				    end
				 false => 
				    let
				       val x_2327: Word64.word * Word64.word = 
					  (x_2321, x_2315)
				       val x_2328: Word64.word = 
					  -? x_2327
				       val x_2329: Word64.word * Word64.word = 
					  (x_2323, x_2328)
				       val x_2330: bool = 
					  > x_2329
				    in
				       x_2330
				    end
			      val x_2332: 'a_2064 VectorSlice.slice = 
				 case x_2326 of
				 true => 
				    let
				       val x_2337: exn = 
					  Subscript
				       val x_2338: 'a_2064 VectorSlice.slice = 
					  raise x_2337
				    in
				       x_2338
				    end
				 false => 
				    let
				       val x_2333: Word64.word * Word64.word = 
					  (x_2319, x_2315)
				       val x_2334: Word64.word = 
					  +? x_2333
				       val x_2335: Word64.word
						   * 'a_2064 vector
						   * Word64.word = 
					  (x_2323, x_2320, x_2334)
				       val x_2336: 'a_2064 VectorSlice.slice = 
					  T['a_2064] x_2335
				    in
				       x_2336
				    end
			   in
			      x_2332
			   end
		  in
		     x_2322
		  end
	 in
	    x_2317
	 end
   val rec 'a_2065 
      subslice: 'a_2065 VectorSlice.slice * word * word option
		-> 'a_2065 VectorSlice.slice = 
	 fn x_2350: 'a_2065 VectorSlice.slice * word * word option => 
	 let
	    val len: word option = 
	       #2 x_2350
	    val start: word = 
	       #1 x_2350
	    val sl: 'a_2065 VectorSlice.slice = 
	       #0 x_2350
	    val x_2351: 'a_2065 VectorSlice.slice = 
	       let
		  val x_2352: Word64.word = 
		     sextdFromInt32ToInt64 start
		  val x_2353: word option -> Word64.word option = 
		     map_0 (Word64.word, word) sextdFromInt32ToInt64
		  val x_2354: Word64.word option = 
		     x_2353 len
		  val x_2355: 'a_2065 VectorSlice.slice
			      * Word64.word
			      * Word64.word option = 
		     (sl, x_2352, x_2354)
		  val x_2356: 'a_2065 VectorSlice.slice = 
		     subslice' ('a_2065) x_2355
	       in
		  x_2356
	       end
	       handle x_2357 => let
				   val x_2358: 'a_2065 VectorSlice.slice = 
				      case x_2357 of
				      Overflow => 
					 let
					    val x_2359: exn = 
					       Subscript
					    val x_2360: 'a_2065 VectorSlice.slice = 
					       raise x_2359
					 in
					    x_2360
					 end
					_ => let
						val x_2361: 'a_2065 VectorSlice.slice = 
						   raise x_2357
					     in
						x_2361
					     end
				in
				   x_2358
				end
	 in
	    x_2351
	 end
   val rec 'a 
      slice: 'a vector * word * word option -> 'a VectorSlice.slice = 
	 fn x_2362: 'a vector * word * word option => 
	 let
	    val len: word option = 
	       #2 x_2362
	    val start: word = 
	       #1 x_2362
	    val seq: 'a vector = 
	       #0 x_2362
	    val x_2363: 'a VectorSlice.slice = 
	       full ('a) seq
	    val x_2364: 'a VectorSlice.slice * word * word option = 
	       (x_2363, start, len)
	    val x_2365: 'a VectorSlice.slice = 
	       subslice ('a) x_2364
	 in
	    x_2365
	 end
   val rec ('a_2071, 'a_2070) 
      foldli': (Word64.word * 'a_2071 * 'a_2070 -> 'a_2070)
	       -> 'a_2070 -> 'a_2071 VectorSlice.slice -> 'a_2070 = 
	 fn x_2366: Word64.word * 'a_2071 * 'a_2070 -> 'a_2070 => 
	 let
	    val x_2367: 'a_2070 -> 'a_2071 VectorSlice.slice -> 'a_2070 = 
	       fn x_2368: 'a_2070 => 
	       let
		  val x_2369: 'a_2071 VectorSlice.slice -> 'a_2070 = 
		     fn x_2370: 'a_2071 VectorSlice.slice => 
		     let
			val x_2371: 'a_2070 = 
			   case x_2370 of
			   T['a_2071] x_2372: Word64.word
					      * 'a_2071 vector
					      * Word64.word => 
			      let
				 val x_2373: Word64.word = 
				    #2 x_2372
				 val x_2374: 'a_2071 vector = 
				    #1 x_2372
				 val x_2375: Word64.word = 
				    #0 x_2372
				 val x_2376: Word64.word = 
				    0x1
				 val x_2377: Word64.word * Word64.word = 
				    (x_2375, x_2376)
				 val len: Word64.word = 
				    -? x_2377
				 val x_2378: Word64.word * Word64.word = 
				    (x_2373, len)
				 val max: Word64.word = 
				    +? x_2378
				 val rec 
				    loop: Word64.word * 'a_2070 -> 'a_2070 = 
				       fn x_2379: Word64.word * 'a_2070 => 
				       let
					  val b: 'a_2070 = 
					     #1 x_2379
					  val i: Word64.word = 
					     #0 x_2379
					  val x_2380: Word64.word * Word64.word = 
					     (i, max)
					  val x_2381: bool = 
					     > x_2380
					  val x_2382: 'a_2070 = 
					     case x_2381 of
					     true => 
						let
						in
						   b
						end
					     false => 
						let
						   val x_2383: Word64.word = 
						      0x1
						   val x_2384: Word64.word
							       * Word64.word = 
						      (i, x_2383)
						   val x_2385: Word64.word = 
						      +? x_2384
						   val x_2386: Word64.word
							       * Word64.word = 
						      (i, x_2373)
						   val x_2387: Word64.word = 
						      -? x_2386
						   val x_2388: 'a_2071 vector
							       * Word64.word = 
						      (x_2374, i)
						   val x_2389: 'a_2071 = 
						      subUnsafe_0 ('a_2071) x_2388
						   val x_2390: Word64.word
							       * 'a_2071
							       * 'a_2070 = 
						      (x_2387, x_2389, b)
						   val x_2391: 'a_2070 = 
						      x_2366 x_2390
						   val x_2392: Word64.word
							       * 'a_2070 = 
						      (x_2385, x_2391)
						   val x_2393: 'a_2070 = 
						      loop x_2392
						in
						   x_2393
						end
				       in
					  x_2382
				       end
				 val x_2394: Word64.word * 'a_2070 = 
				    (x_2373, x_2368)
				 val x_2395: 'a_2070 = 
				    loop x_2394
			      in
				 x_2395
			      end
		     in
			x_2371
		     end
	       in
		  x_2369
	       end
	 in
	    x_2367
	 end
   val rec ('a_2084, 'a_2083, 'a_2082, 'a_2081, 'a_2080, 'a_2079, 'a_2078) 
      make: (('a_2084 * 'a_2083 * 'a_2082 -> 'a_2081)
	     -> 'a_2079 -> 'a_2078 -> 'a_2080)
	    -> ('a_2083 * 'a_2082 -> 'a_2081) -> 'a_2079 -> 'a_2078 -> 'a_2080 = 
	 fn x_2396: ('a_2084 * 'a_2083 * 'a_2082 -> 'a_2081)
		    -> 'a_2079 -> 'a_2078 -> 'a_2080 => 
	 let
	    val x_2397: ('a_2083 * 'a_2082 -> 'a_2081)
			-> 'a_2079 -> 'a_2078 -> 'a_2080 = 
	       fn x_2398: 'a_2083 * 'a_2082 -> 'a_2081 => 
	       let
		  val x_2399: 'a_2079 -> 'a_2078 -> 'a_2080 = 
		     fn x_2400: 'a_2079 => 
		     let
			val x_2401: 'a_2078 -> 'a_2080 = 
			   fn x_2402: 'a_2078 => 
			   let
			      val x_2403: 'a_2084 * 'a_2083 * 'a_2082 -> 'a_2081 = 
				 fn x_2404: 'a_2084 * 'a_2083 * 'a_2082 => 
				 let
				    val x_2405: 'a_2082 = 
				       #2 x_2404
				    val x_2406: 'a_2083 = 
				       #1 x_2404
				    val x_2407: 'a_2083 * 'a_2082 = 
				       (x_2406, x_2405)
				    val x_2408: 'a_2081 = 
				       x_2398 x_2407
				 in
				    x_2408
				 end
			      val x_2409: 'a_2079 -> 'a_2078 -> 'a_2080 = 
				 x_2396 x_2403
			      val x_2410: 'a_2078 -> 'a_2080 = 
				 x_2409 x_2400
			      val x_2411: 'a_2080 = 
				 x_2410 x_2402
			   in
			      x_2411
			   end
		     in
			x_2401
		     end
	       in
		  x_2399
	       end
	 in
	    x_2397
	 end
   val rec ('a_2086, 'a_2085) 
      foldl: ('a_2086 * 'a_2085 -> 'a_2085)
	     -> 'a_2085 -> 'a_2086 VectorSlice.slice -> 'a_2085 = 
	 fn x_2412: 'a_2086 * 'a_2085 -> 'a_2085 => 
	 let
	    val x_2413: ('a_2086 * 'a_2085 -> 'a_2085)
			-> 'a_2085 -> 'a_2086 VectorSlice.slice -> 'a_2085 = 
	       make (Word64.word,
		     'a_2086,
		     'a_2085,
		     'a_2085,
		     'a_2085,
		     'a_2085,
		     'a_2086 VectorSlice.slice) foldli' ('a_2086, 'a_2085)
	    val x_2414: 'a_2085 -> 'a_2086 VectorSlice.slice -> 'a_2085 = 
	       x_2413 x_2412
	 in
	    x_2414
	 end
   val rec ('a_2094, 'a_2093, 'a_2092) 
      createi': (Word64.word * (Word64.word -> 'a_2093) -> 'a_2092)
		-> (Word64.word * 'a_2094 -> 'a_2093)
		   -> 'a_2094 VectorSlice.slice -> 'a_2092 = 
	 fn x_2415: Word64.word * (Word64.word -> 'a_2093) -> 'a_2092 => 
	 let
	    val x_2416: (Word64.word * 'a_2094 -> 'a_2093)
			-> 'a_2094 VectorSlice.slice -> 'a_2092 = 
	       fn x_2417: Word64.word * 'a_2094 -> 'a_2093 => 
	       let
		  val x_2418: 'a_2094 VectorSlice.slice -> 'a_2092 = 
		     fn x_2419: 'a_2094 VectorSlice.slice => 
		     let
			val x_2420: 'a_2092 = 
			   case x_2419 of
			   T['a_2094] x_2421: Word64.word
					      * 'a_2094 vector
					      * Word64.word => 
			      let
				 val x_2422: Word64.word = 
				    #2 x_2421
				 val x_2423: 'a_2094 vector = 
				    #1 x_2421
				 val x_2424: Word64.word = 
				    #0 x_2421
				 val x_2425: Word64.word -> 'a_2093 = 
				    fn x_2426: Word64.word => 
				    let
				       val x_2427: Word64.word * Word64.word = 
					  (x_2422, x_2426)
				       val x_2428: Word64.word = 
					  +? x_2427
				       val x_2429: 'a_2094 vector * Word64.word = 
					  (x_2423, x_2428)
				       val x_2430: 'a_2094 = 
					  subUnsafe_0 ('a_2094) x_2429
				       val x_2431: Word64.word * 'a_2094 = 
					  (x_2426, x_2430)
				       val x_2432: 'a_2093 = 
					  x_2417 x_2431
				    in
				       x_2432
				    end
				 val x_2433: Word64.word
					     * (Word64.word -> 'a_2093) = 
				    (x_2424, x_2425)
				 val x_2434: 'a_2092 = 
				    x_2415 x_2433
			      in
				 x_2434
			      end
		     in
			x_2420
		     end
	       in
		  x_2418
	       end
	 in
	    x_2416
	 end
   val rec ('a_2102, 'a_2101) 
      mapi': (Word64.word * 'a_2102 -> 'a_2101)
	     -> 'a_2102 VectorSlice.slice -> 'a_2101 vector = 
	 fn x_2435: Word64.word * 'a_2102 -> 'a_2101 => 
	 let
	    val x_2436: 'a_2102 VectorSlice.slice -> 'a_2101 vector = 
	       fn x_2437: 'a_2102 VectorSlice.slice => 
	       let
		  val x_2438: (Word64.word * 'a_2102 -> 'a_2101)
			      -> 'a_2102 VectorSlice.slice -> 'a_2101 vector = 
		     createi' ('a_2102, 'a_2101, 'a_2101 vector) tabulate' ('a_2101)
		  val x_2439: 'a_2102 VectorSlice.slice -> 'a_2101 vector = 
		     x_2438 x_2435
		  val x_2440: 'a_2101 vector = 
		     x_2439 x_2437
	       in
		  x_2440
	       end
	 in
	    x_2436
	 end
   val rec ('a_2104, 'a_2103) 
      mapi: (word * 'a_2104 -> 'a_2103)
	    -> 'a_2104 VectorSlice.slice -> 'a_2103 vector = 
	 fn x_2441: word * 'a_2104 -> 'a_2103 => 
	 let
	    val x_2442: 'a_2104 VectorSlice.slice -> 'a_2103 vector = 
	       fn x_2443: 'a_2104 VectorSlice.slice => 
	       let
		  val x_2444: Word64.word * 'a_2104 -> 'a_2103 = 
		     wrap2 ('a_2104, 'a_2103) x_2441
		  val x_2445: 'a_2104 VectorSlice.slice -> 'a_2103 vector = 
		     mapi' ('a_2104, 'a_2103) x_2444
		  val x_2446: 'a_2103 vector = 
		     x_2445 x_2443
	       in
		  x_2446
	       end
	 in
	    x_2442
	 end
   val rec ('a_2106, 'a_2105) 
      map: ('a_2105 -> 'a_2106) -> 'a_2105 VectorSlice.slice -> 'a_2106 vector = 
	 fn x_2447: 'a_2105 -> 'a_2106 => 
	 let
	    val x_2448: 'a_2105 VectorSlice.slice -> 'a_2106 vector = 
	       fn x_2449: 'a_2105 VectorSlice.slice => 
	       let
		  val x_2450: word * 'a_2105 -> 'a_2105 = 
		     fn x_2451: word * 'a_2105 => 
		     let
			val x_2452: 'a_2105 = 
			   #1 x_2451
		     in
			x_2452
		     end
		  val x_2453: ('a_2105 -> 'a_2106) * (word * 'a_2105 -> 'a_2105) = 
		     (x_2447, x_2450)
		  val x_2454: word * 'a_2105 -> 'a_2106 = 
		     o_1 (word * 'a_2105, 'a_2106, 'a_2105) x_2453
		  val x_2455: 'a_2105 VectorSlice.slice -> 'a_2106 vector = 
		     mapi ('a_2105, 'a_2106) x_2454
		  val x_2456: 'a_2106 vector = 
		     x_2455 x_2449
	       in
		  x_2456
	       end
	 in
	    x_2448
	 end
   val rec 'a 
      sequence: 'a VectorSlice.slice -> 'a vector = 
	 fn x_2457: 'a VectorSlice.slice => 
	 let
	    val x_2458: 'a vector = 
	       case x_2457 of
	       T['a] x_2459: Word64.word * 'a vector * Word64.word => 
		  let
		     val x_2460: Word64.word = 
			#2 x_2459
		     val x_2461: 'a vector = 
			#1 x_2459
		     val x_2462: Word64.word = 
			#0 x_2459
		     val x_2463: Word64.word = 
			0x0
		     val x_2464: Word64.word * Word64.word = 
			(x_2460, x_2463)
		     val x_2465: bool = 
			<> (Word64.word) x_2464
		     val x_2466: bool = 
			case x_2465 of
			true => 
			   let
			      val x_2470: bool = 
				 true
			   in
			      x_2470
			   end
			false => 
			   let
			      val x_2467: Word64.word = 
				 length_1 ('a) x_2461
			      val x_2468: Word64.word * Word64.word = 
				 (x_2462, x_2467)
			      val x_2469: bool = 
				 <> (Word64.word) x_2468
			   in
			      x_2469
			   end
		     val x_2471: 'a vector = 
			case x_2466 of
			true => 
			   let
			      val x_2472: 'a -> 'a = 
				 fn x_2473: 'a => 
				 let
				 in
				    x_2473
				 end
			      val x_2474: 'a VectorSlice.slice -> 'a vector = 
				 map ('a, 'a) x_2472
			      val x_2475: 'a vector = 
				 x_2474 x_2457
			   in
			      x_2475
			   end
			false => 
			   let
			   in
			      x_2461
			   end
		  in
		     x_2471
		  end
	 in
	    x_2458
	 end
   val rec 'a 
      append: 'a VectorSlice.slice * 'a VectorSlice.slice -> 'a vector = 
	 fn x_2476: 'a VectorSlice.slice * 'a VectorSlice.slice => 
	 let
	    val sl2: 'a VectorSlice.slice = 
	       #1 x_2476
	    val sl1: 'a VectorSlice.slice = 
	       #0 x_2476
	    val x_2477: Word64.word = 
	       length' ('a) sl1
	    val x_2478: Word64.word = 
	       0x0
	    val x_2479: Word64.word * Word64.word = 
	       (x_2477, x_2478)
	    val x_2480: bool = 
	       = (Word64.word) x_2479
	    val x_2481: 'a vector = 
	       case x_2480 of
	       true => 
		  let
		     val x_2522: 'a vector = 
			sequence ('a) sl2
		  in
		     x_2522
		  end
	       false => 
		  let
		     val x_2482: Word64.word = 
			length' ('a) sl2
		     val x_2483: Word64.word = 
			0x0
		     val x_2484: Word64.word * Word64.word = 
			(x_2482, x_2483)
		     val x_2485: bool = 
			= (Word64.word) x_2484
		     val x_2486: 'a vector = 
			case x_2485 of
			true => 
			   let
			      val x_2521: 'a vector = 
				 sequence ('a) sl1
			   in
			      x_2521
			   end
			false => 
			   let
			      val l1: Word64.word = 
				 length' ('a) sl1
			      val l2: Word64.word = 
				 length' ('a) sl2
			      val n: Word64.word = 
				 let
				    val x_2487: Word64.word * Word64.word = 
				       (l1, l2)
				    val x_2488: Word64.word = 
				       +! x_2487
				 in
				    x_2488
				 end
				 handle x_2489 => let
						     val x_2490: Word64.word = 
							case x_2489 of
							Overflow => 
							   let
							      val x_2491: exn = 
								 Size
							      val x_2492: Word64.word = 
								 raise x_2491
							   in
							      x_2492
							   end
							  _ => let
								  val x_2493: Word64.word = 
								     raise x_2489
							       in
								  x_2493
							       end
						  in
						     x_2490
						  end
			      val x_2494: Word64.word = 
				 0x0
			      val x_2495: Word64.word * 'a VectorSlice.slice = 
				 (x_2494, sl1)
			      val x_2496: Word64.word
					  * (Word64.word * 'a VectorSlice.slice)
					  -> 'a
					     * (Word64.word
						* 'a VectorSlice.slice) = 
				 fn x_2497: Word64.word
					    * (Word64.word
					       * 'a VectorSlice.slice) => 
				 let
				    val x_2498: Word64.word
						* 'a VectorSlice.slice = 
				       #1 x_2497
				    val x_2499: 'a VectorSlice.slice = 
				       #1 x_2498
				    val x_2500: Word64.word = 
				       #0 x_2498
				    val x_2501: Word64.word = 
				       length' ('a) x_2499
				    val x_2502: Word64.word * Word64.word = 
				       (x_2500, x_2501)
				    val x_2503: bool = 
				       < x_2502
				    val x_2504: 'a
						* (Word64.word
						   * 'a VectorSlice.slice) = 
				       case x_2503 of
				       true => 
					  let
					     val x_2511: 'a VectorSlice.slice
							 * Word64.word = 
						(x_2499, x_2500)
					     val x_2512: 'a = 
						unsafeSub' ('a) x_2511
					     val x_2513: Word64.word = 
						0x1
					     val x_2514: Word64.word
							 * Word64.word = 
						(x_2500, x_2513)
					     val x_2515: Word64.word = 
						+? x_2514
					     val x_2516: Word64.word
							 * 'a VectorSlice.slice = 
						(x_2515, x_2499)
					     val x_2517: 'a
							 * (Word64.word
							    * 'a VectorSlice.slice) = 
						(x_2512, x_2516)
					  in
					     x_2517
					  end
				       false => 
					  let
					     val x_2505: Word64.word = 
						0x0
					     val x_2506: 'a VectorSlice.slice
							 * Word64.word = 
						(sl2, x_2505)
					     val x_2507: 'a = 
						unsafeSub' ('a) x_2506
					     val x_2508: Word64.word = 
						0x1
					     val x_2509: Word64.word
							 * 'a VectorSlice.slice = 
						(x_2508, sl2)
					     val x_2510: 'a
							 * (Word64.word
							    * 'a VectorSlice.slice) = 
						(x_2507, x_2509)
					  in
					     x_2510
					  end
				 in
				    x_2504
				 end
			      val x_2518: Word64.word
					  * (Word64.word * 'a VectorSlice.slice)
					  * (Word64.word
					     * (Word64.word
						* 'a VectorSlice.slice)
					     -> 'a
						* (Word64.word
						   * 'a VectorSlice.slice)) = 
				 (n, x_2495, x_2496)
			      val x_2519: 'a vector
					  * (Word64.word * 'a VectorSlice.slice) = 
				 unfoldi' (Word64.word * 'a VectorSlice.slice,
					   'a) x_2518
			      val x_2520: 'a vector = 
				 #0 x_2519
			   in
			      x_2520
			   end
		  in
		     x_2486
		  end
	 in
	    x_2481
	 end
   val rec 'a 
      concat: 'a VectorSlice.slice list -> 'a vector = 
	 fn x_2523: 'a VectorSlice.slice list => 
	 let
	    val x_2524: 'a vector = 
	       case x_2523 of
	       nil['a VectorSlice.slice] => 
		  let
		     val x_2575: unit = 
			()
		     val x_2576: 'a vector = 
			seq0 ('a) x_2575
		  in
		     x_2576
		  end
	       ::['a VectorSlice.slice] x_2525: 'a VectorSlice.slice
						* 'a VectorSlice.slice list => 
		  let
		     val x_2526: 'a VectorSlice.slice list = 
			#1 x_2525
		     val x_2527: 'a VectorSlice.slice = 
			#0 x_2525
		     val x_2528: 'a vector = 
			case x_2526 of
			nil['a VectorSlice.slice] => 
			   let
			      val x_2529: 'a vector = 
				 sequence ('a) x_2527
			   in
			      x_2529
			   end
			  _ => let
				  val n: Word64.word = 
				     let
					val x_2530: 'a VectorSlice.slice
						    * Word64.word
						    -> Word64.word = 
					   fn x_2531: 'a VectorSlice.slice
						      * Word64.word => 
					   let
					      val s: Word64.word = 
						 #1 x_2531
					      val sl: 'a VectorSlice.slice = 
						 #0 x_2531
					      val x_2532: Word64.word = 
						 length' ('a) sl
					      val x_2533: Word64.word
							  * Word64.word = 
						 (s, x_2532)
					      val x_2534: Word64.word = 
						 +? x_2533
					   in
					      x_2534
					   end
					val x_2535: Word64.word
						    -> 'a VectorSlice.slice list
						       -> Word64.word = 
					   foldl_0 (Word64.word,
						    'a VectorSlice.slice) x_2530
					val x_2536: Word64.word = 
					   0x0
					val x_2537: 'a VectorSlice.slice list
						    -> Word64.word = 
					   x_2535 x_2536
					val x_2538: Word64.word = 
					   x_2537 x_2523
				     in
					x_2538
				     end
				     handle x_2539 => let
							 val x_2540: Word64.word = 
							    case x_2539 of
							    Overflow => 
							       let
								  val x_2541: exn = 
								     Size
								  val x_2542: Word64.word = 
								     raise x_2541
							       in
								  x_2542
							       end
							      _ => let
								      val x_2543: Word64.word = 
									 raise x_2539
								   in
								      x_2543
								   end
						      in
							 x_2540
						      end
				  val x_2544: Word64.word = 
				     0x0
				  val x_2545: Word64.word
					      * 'a VectorSlice.slice
					      * 'a VectorSlice.slice list = 
				     (x_2544, x_2527, x_2526)
				  val x_2546: Word64.word
					      * (Word64.word
						 * 'a VectorSlice.slice
						 * 'a VectorSlice.slice list)
					      -> 'a
						 * (Word64.word
						    * 'a VectorSlice.slice
						    * 'a VectorSlice.slice list) = 
				     fn x_2547: Word64.word
						* (Word64.word
						   * 'a VectorSlice.slice
						   * 'a VectorSlice.slice list) => 
				     let
					val x_2548: Word64.word
						    * 'a VectorSlice.slice
						    * 'a VectorSlice.slice list = 
					   #1 x_2547
					val rec 'a_2118 
					   loop: Word64.word
						 * 'a_2118 VectorSlice.slice
						 * 'a_2118 VectorSlice.slice list
						 -> 'a_2118
						    * (Word64.word
						       * 'a_2118 VectorSlice.slice
						       * 'a_2118 VectorSlice.slice list) = 
					      fn x_2549: Word64.word
							 * 'a_2118 VectorSlice.slice
							 * 'a_2118 VectorSlice.slice list => 
					      let
						 val sls: 'a_2118 VectorSlice.slice list = 
						    #2 x_2549
						 val sl: 'a_2118 VectorSlice.slice = 
						    #1 x_2549
						 val i: Word64.word = 
						    #0 x_2549
						 val x_2550: Word64.word = 
						    length' ('a_2118) sl
						 val x_2551: Word64.word
							     * Word64.word = 
						    (i, x_2550)
						 val x_2552: bool = 
						    < x_2551
						 val x_2553: 'a_2118
							     * (Word64.word
								* 'a_2118 VectorSlice.slice
								* 'a_2118 VectorSlice.slice list) = 
						    case x_2552 of
						    true => 
						       let
							  val x_2564: 'a_2118 VectorSlice.slice
								      * Word64.word = 
							     (sl, i)
							  val x_2565: 'a_2118 = 
							     unsafeSub' ('a_2118) x_2564
							  val x_2566: Word64.word = 
							     0x1
							  val x_2567: Word64.word
								      * Word64.word = 
							     (i, x_2566)
							  val x_2568: Word64.word = 
							     +? x_2567
							  val x_2569: Word64.word
								      * 'a_2118 VectorSlice.slice
								      * 'a_2118 VectorSlice.slice list = 
							     (x_2568, sl, sls)
							  val x_2570: 'a_2118
								      * (Word64.word
									 * 'a_2118 VectorSlice.slice
									 * 'a_2118 VectorSlice.slice list) = 
							     (x_2565, x_2569)
						       in
							  x_2570
						       end
						    false => 
						       let
							  val x_2554: 'a_2118
								      * (Word64.word
									 * 'a_2118 VectorSlice.slice
									 * 'a_2118 VectorSlice.slice list) = 
							     case sls of
							     nil['a_2118 VectorSlice.slice] => 
								let
								   val x_2561: Word8.word vector = 
								      "Sequence.Slice.concat"
								   val x_2562: exn = 
								      Fail x_2561
								   val x_2563: 'a_2118
									       * (Word64.word
										  * 'a_2118 VectorSlice.slice
										  * 'a_2118 VectorSlice.slice list) = 
								      raise x_2562
								in
								   x_2563
								end
							     ::['a_2118 VectorSlice.slice] x_2555: 'a_2118 VectorSlice.slice
												   * 'a_2118 VectorSlice.slice list => 
								let
								   val x_2556: 'a_2118 VectorSlice.slice list = 
								      #1 x_2555
								   val x_2557: 'a_2118 VectorSlice.slice = 
								      #0 x_2555
								   val x_2558: Word64.word = 
								      0x0
								   val x_2559: Word64.word
									       * 'a_2118 VectorSlice.slice
									       * 'a_2118 VectorSlice.slice list = 
								      (x_2558,
								       x_2557,
								       x_2556)
								   val x_2560: 'a_2118
									       * (Word64.word
										  * 'a_2118 VectorSlice.slice
										  * 'a_2118 VectorSlice.slice list) = 
								      loop ('a_2118) x_2559
								in
								   x_2560
								end
						       in
							  x_2554
						       end
					      in
						 x_2553
					      end
					val x_2571: 'a
						    * (Word64.word
						       * 'a VectorSlice.slice
						       * 'a VectorSlice.slice list) = 
					   loop ('a) x_2548
				     in
					x_2571
				     end
				  val x_2572: Word64.word
					      * (Word64.word
						 * 'a VectorSlice.slice
						 * 'a VectorSlice.slice list)
					      * (Word64.word
						 * (Word64.word
						    * 'a VectorSlice.slice
						    * 'a VectorSlice.slice list)
						 -> 'a
						    * (Word64.word
						       * 'a VectorSlice.slice
						       * 'a VectorSlice.slice list)) = 
				     (n, x_2545, x_2546)
				  val x_2573: 'a vector
					      * (Word64.word
						 * 'a VectorSlice.slice
						 * 'a VectorSlice.slice list) = 
				     unfoldi' (Word64.word
					       * 'a VectorSlice.slice
					       * 'a VectorSlice.slice list,
					       'a) x_2572
				  val x_2574: 'a vector = 
				     #0 x_2573
			       in
				  x_2574
			       end
		  in
		     x_2528
		  end
	 in
	    x_2524
	 end
   val rec 'a 
      isPrefix: ('a * 'a -> bool) -> 'a vector -> 'a VectorSlice.slice -> bool = 
	 fn x_2577: 'a * 'a -> bool => 
	 let
	    val x_2578: 'a vector -> 'a VectorSlice.slice -> bool = 
	       fn x_2579: 'a vector => 
	       let
		  val x_2580: 'a VectorSlice.slice -> bool = 
		     fn x_2581: 'a VectorSlice.slice => 
		     let
			val n: Word64.word = 
			   length_1 ('a) x_2579
			val n': Word64.word = 
			   length' ('a) x_2581
			val x_2582: Word64.word * Word64.word = 
			   (n, n')
			val x_2583: bool = 
			   <= x_2582
			val x_2584: bool = 
			   case x_2583 of
			   true => 
			      let
				 val rec 
				    loop: Word64.word -> bool = 
				       fn x_2586: Word64.word => 
				       let
					  val x_2587: Word64.word * Word64.word = 
					     (x_2586, n)
					  val x_2588: bool = 
					     >= x_2587
					  val x_2589: bool = 
					     case x_2588 of
					     true => 
						let
						   val x_2602: bool = 
						      true
						in
						   x_2602
						end
					     false => 
						let
						   val x_2590: 'a vector
							       * Word64.word = 
						      (x_2579, x_2586)
						   val x_2591: 'a = 
						      subUnsafe_0 ('a) x_2590
						   val x_2592: 'a VectorSlice.slice
							       * Word64.word = 
						      (x_2581, x_2586)
						   val x_2593: 'a = 
						      unsafeSub' ('a) x_2592
						   val x_2594: 'a * 'a = 
						      (x_2591, x_2593)
						   val x_2595: bool = 
						      x_2577 x_2594
						   val x_2596: bool = 
						      case x_2595 of
						      true => 
							 let
							    val x_2598: Word64.word = 
							       0x1
							    val x_2599: Word64.word
									* Word64.word = 
							       (x_2586, x_2598)
							    val x_2600: Word64.word = 
							       +? x_2599
							    val x_2601: bool = 
							       loop x_2600
							 in
							    x_2601
							 end
						      false => 
							 let
							    val x_2597: bool = 
							       false
							 in
							    x_2597
							 end
						in
						   x_2596
						end
				       in
					  x_2589
				       end
				 val x_2603: Word64.word = 
				    0x0
				 val x_2604: bool = 
				    loop x_2603
			      in
				 x_2604
			      end
			   false => 
			      let
				 val x_2585: bool = 
				    false
			      in
				 x_2585
			      end
		     in
			x_2584
		     end
	       in
		  x_2580
	       end
	 in
	    x_2578
	 end
   val rec 'a_2121 
      split': 'a_2121 VectorSlice.slice * Word64.word
	      -> 'a_2121 VectorSlice.slice * 'a_2121 VectorSlice.slice = 
	 fn x_2605: 'a_2121 VectorSlice.slice * Word64.word => 
	 let
	    val x_2606: Word64.word = 
	       #1 x_2605
	    val x_2607: 'a_2121 VectorSlice.slice = 
	       #0 x_2605
	    val x_2608: 'a_2121 VectorSlice.slice * 'a_2121 VectorSlice.slice = 
	       case x_2607 of
	       T['a_2121] x_2609: Word64.word * 'a_2121 vector * Word64.word => 
		  let
		     val x_2610: Word64.word = 
			#2 x_2609
		     val x_2611: 'a_2121 vector = 
			#1 x_2609
		     val x_2612: Word64.word = 
			#0 x_2609
		     val x_2613: Word64.word * Word64.word = 
			(x_2606, x_2610)
		     val x_2614: Word64.word = 
			-? x_2613
		     val x_2615: Word64.word option = 
			SOME[Word64.word] x_2614
		     val x_2616: 'a_2121 vector
				 * Word64.word
				 * Word64.word option = 
			(x_2611, x_2610, x_2615)
		     val x_2617: 'a_2121 VectorSlice.slice = 
			unsafeSlice' ('a_2121) x_2616
		     val x_2618: Word64.word * Word64.word = 
			(x_2606, x_2610)
		     val x_2619: Word64.word = 
			-? x_2618
		     val x_2620: Word64.word * Word64.word = 
			(x_2612, x_2619)
		     val x_2621: Word64.word = 
			-? x_2620
		     val x_2622: Word64.word option = 
			SOME[Word64.word] x_2621
		     val x_2623: 'a_2121 vector
				 * Word64.word
				 * Word64.word option = 
			(x_2611, x_2606, x_2622)
		     val x_2624: 'a_2121 VectorSlice.slice = 
			unsafeSlice' ('a_2121) x_2623
		     val x_2625: 'a_2121 VectorSlice.slice
				 * 'a_2121 VectorSlice.slice = 
			(x_2617, x_2624)
		  in
		     x_2625
		  end
	 in
	    x_2608
	 end
   val rec 'a_2122 
      splitl: ('a_2122 -> bool)
	      -> 'a_2122 VectorSlice.slice
		 -> 'a_2122 VectorSlice.slice * 'a_2122 VectorSlice.slice = 
	 fn x_2626: 'a_2122 -> bool => 
	 let
	    val x_2627: 'a_2122 VectorSlice.slice
			-> 'a_2122 VectorSlice.slice * 'a_2122 VectorSlice.slice = 
	       fn x_2628: 'a_2122 VectorSlice.slice => 
	       let
		  val x_2629: 'a_2122 VectorSlice.slice
			      * 'a_2122 VectorSlice.slice = 
		     case x_2628 of
		     T['a_2122] x_2630: Word64.word
					* 'a_2122 vector
					* Word64.word => 
			let
			   val x_2631: Word64.word = 
			      #2 x_2630
			   val x_2632: 'a_2122 vector = 
			      #1 x_2630
			   val x_2633: Word64.word = 
			      #0 x_2630
			   val x_2634: Word64.word * Word64.word = 
			      (x_2631, x_2633)
			   val stop: Word64.word = 
			      +? x_2634
			   val rec 
			      loop: Word64.word -> Word64.word = 
				 fn x_2635: Word64.word => 
				 let
				    val x_2636: Word64.word * Word64.word = 
				       (x_2635, stop)
				    val x_2637: bool = 
				       >= x_2636
				    val x_2638: Word64.word = 
				       case x_2637 of
				       true => 
					  let
					  in
					     x_2635
					  end
				       false => 
					  let
					     val x_2639: 'a_2122 vector
							 * Word64.word = 
						(x_2632, x_2635)
					     val x_2640: 'a_2122 = 
						subUnsafe_0 ('a_2122) x_2639
					     val x_2641: bool = 
						x_2626 x_2640
					     val x_2642: Word64.word = 
						case x_2641 of
						true => 
						   let
						      val x_2643: Word64.word = 
							 0x1
						      val x_2644: Word64.word
								  * Word64.word = 
							 (x_2635, x_2643)
						      val x_2645: Word64.word = 
							 +? x_2644
						      val x_2646: Word64.word = 
							 loop x_2645
						   in
						      x_2646
						   end
						false => 
						   let
						   in
						      x_2635
						   end
					  in
					     x_2642
					  end
				 in
				    x_2638
				 end
			   val x_2647: Word64.word = 
			      loop x_2631
			   val x_2648: 'a_2122 VectorSlice.slice * Word64.word = 
			      (x_2628, x_2647)
			   val x_2649: 'a_2122 VectorSlice.slice
				       * 'a_2122 VectorSlice.slice = 
			      split' ('a_2122) x_2648
			in
			   x_2649
			end
	       in
		  x_2629
	       end
	 in
	    x_2627
	 end
   val rec 'a_2123 
      splitr: ('a_2123 -> bool)
	      -> 'a_2123 VectorSlice.slice
		 -> 'a_2123 VectorSlice.slice * 'a_2123 VectorSlice.slice = 
	 fn x_2650: 'a_2123 -> bool => 
	 let
	    val x_2651: 'a_2123 VectorSlice.slice
			-> 'a_2123 VectorSlice.slice * 'a_2123 VectorSlice.slice = 
	       fn x_2652: 'a_2123 VectorSlice.slice => 
	       let
		  val x_2653: 'a_2123 VectorSlice.slice
			      * 'a_2123 VectorSlice.slice = 
		     case x_2652 of
		     T['a_2123] x_2654: Word64.word
					* 'a_2123 vector
					* Word64.word => 
			let
			   val x_2655: Word64.word = 
			      #2 x_2654
			   val x_2656: 'a_2123 vector = 
			      #1 x_2654
			   val x_2657: Word64.word = 
			      #0 x_2654
			   val rec 
			      loop: Word64.word -> Word64.word = 
				 fn x_2658: Word64.word => 
				 let
				    val x_2659: Word64.word * Word64.word = 
				       (x_2658, x_2655)
				    val x_2660: bool = 
				       < x_2659
				    val x_2661: Word64.word = 
				       case x_2660 of
				       true => 
					  let
					  in
					     x_2655
					  end
				       false => 
					  let
					     val x_2662: 'a_2123 vector
							 * Word64.word = 
						(x_2656, x_2658)
					     val x_2663: 'a_2123 = 
						subUnsafe_0 ('a_2123) x_2662
					     val x_2664: bool = 
						x_2650 x_2663
					     val x_2665: Word64.word = 
						case x_2664 of
						true => 
						   let
						      val x_2669: Word64.word = 
							 0x1
						      val x_2670: Word64.word
								  * Word64.word = 
							 (x_2658, x_2669)
						      val x_2671: Word64.word = 
							 -? x_2670
						      val x_2672: Word64.word = 
							 loop x_2671
						   in
						      x_2672
						   end
						false => 
						   let
						      val x_2666: Word64.word = 
							 0x1
						      val x_2667: Word64.word
								  * Word64.word = 
							 (x_2658, x_2666)
						      val x_2668: Word64.word = 
							 +? x_2667
						   in
						      x_2668
						   end
					  in
					     x_2665
					  end
				 in
				    x_2661
				 end
			   val x_2673: Word64.word * Word64.word = 
			      (x_2655, x_2657)
			   val x_2674: Word64.word = 
			      +? x_2673
			   val x_2675: Word64.word = 
			      0x1
			   val x_2676: Word64.word * Word64.word = 
			      (x_2674, x_2675)
			   val x_2677: Word64.word = 
			      -? x_2676
			   val x_2678: Word64.word = 
			      loop x_2677
			   val x_2679: 'a_2123 VectorSlice.slice * Word64.word = 
			      (x_2652, x_2678)
			   val x_2680: 'a_2123 VectorSlice.slice
				       * 'a_2123 VectorSlice.slice = 
			      split' ('a_2123) x_2679
			in
			   x_2680
			end
	       in
		  x_2653
	       end
	 in
	    x_2651
	 end
   val rec 'a_2127 
      dropr: ('a_2127 -> bool)
	     -> 'a_2127 VectorSlice.slice -> 'a_2127 VectorSlice.slice = 
	 fn x_2681: 'a_2127 -> bool => 
	 let
	    val x_2682: 'a_2127 VectorSlice.slice -> 'a_2127 VectorSlice.slice = 
	       fn x_2683: 'a_2127 VectorSlice.slice => 
	       let
		  val x_2684: 'a_2127 VectorSlice.slice
			      -> 'a_2127 VectorSlice.slice
				 * 'a_2127 VectorSlice.slice = 
		     splitr ('a_2127) x_2681
		  val x_2685: 'a_2127 VectorSlice.slice
			      * 'a_2127 VectorSlice.slice = 
		     x_2684 x_2683
		  val x_2686: 'a_2127 VectorSlice.slice = 
		     #0 x_2685
	       in
		  x_2686
	       end
	 in
	    x_2682
	 end
   val rec 'a_2128 
      takel: ('a_2128 -> bool)
	     -> 'a_2128 VectorSlice.slice -> 'a_2128 VectorSlice.slice = 
	 fn x_2687: 'a_2128 -> bool => 
	 let
	    val x_2688: 'a_2128 VectorSlice.slice -> 'a_2128 VectorSlice.slice = 
	       fn x_2689: 'a_2128 VectorSlice.slice => 
	       let
		  val x_2690: 'a_2128 VectorSlice.slice
			      -> 'a_2128 VectorSlice.slice
				 * 'a_2128 VectorSlice.slice = 
		     splitl ('a_2128) x_2687
		  val x_2691: 'a_2128 VectorSlice.slice
			      * 'a_2128 VectorSlice.slice = 
		     x_2690 x_2689
		  val x_2692: 'a_2128 VectorSlice.slice = 
		     #0 x_2691
	       in
		  x_2692
	       end
	 in
	    x_2688
	 end
   val rec 'a_2129 
      taker: ('a_2129 -> bool)
	     -> 'a_2129 VectorSlice.slice -> 'a_2129 VectorSlice.slice = 
	 fn x_2693: 'a_2129 -> bool => 
	 let
	    val x_2694: 'a_2129 VectorSlice.slice -> 'a_2129 VectorSlice.slice = 
	       fn x_2695: 'a_2129 VectorSlice.slice => 
	       let
		  val x_2696: 'a_2129 VectorSlice.slice
			      -> 'a_2129 VectorSlice.slice
				 * 'a_2129 VectorSlice.slice = 
		     splitr ('a_2129) x_2693
		  val x_2697: 'a_2129 VectorSlice.slice
			      * 'a_2129 VectorSlice.slice = 
		     x_2696 x_2695
		  val x_2698: 'a_2129 VectorSlice.slice = 
		     #1 x_2697
	       in
		  x_2698
	       end
	 in
	    x_2694
	 end
   val rec ('a_2130, 'a) 
      translate: ('a -> 'a_2130 vector)
		 -> 'a VectorSlice.slice -> 'a_2130 vector = 
	 fn x_2699: 'a -> 'a_2130 vector => 
	 let
	    val x_2700: 'a VectorSlice.slice -> 'a_2130 vector = 
	       fn x_2701: 'a VectorSlice.slice => 
	       let
		  val x_2702: 'a * 'a_2130 VectorSlice.slice list
			      -> 'a_2130 VectorSlice.slice list = 
		     fn x_2703: 'a * 'a_2130 VectorSlice.slice list => 
		     let
			val l: 'a_2130 VectorSlice.slice list = 
			   #1 x_2703
			val c: 'a = 
			   #0 x_2703
			val x_2704: 'a_2130 vector = 
			   x_2699 c
			val x_2705: 'a_2130 VectorSlice.slice = 
			   full ('a_2130) x_2704
			val x_2706: 'a_2130 VectorSlice.slice
				    * 'a_2130 VectorSlice.slice list = 
			   (x_2705, l)
			val x_2707: 'a_2130 VectorSlice.slice list = 
			   ::['a_2130 VectorSlice.slice] x_2706
		     in
			x_2707
		     end
		  val x_2708: 'a_2130 VectorSlice.slice list
			      -> 'a VectorSlice.slice
				 -> 'a_2130 VectorSlice.slice list = 
		     foldl ('a, 'a_2130 VectorSlice.slice list) x_2702
		  val x_2709: 'a_2130 VectorSlice.slice list = 
		     nil['a_2130 VectorSlice.slice]
		  val x_2710: 'a VectorSlice.slice
			      -> 'a_2130 VectorSlice.slice list = 
		     x_2708 x_2709
		  val x_2711: 'a_2130 VectorSlice.slice list = 
		     x_2710 x_2701
		  val x_2712: 'a_2130 VectorSlice.slice list = 
		     rev_0 ('a_2130 VectorSlice.slice) x_2711
		  val x_2713: 'a_2130 vector = 
		     concat ('a_2130) x_2712
	       in
		  x_2713
	       end
	 in
	    x_2700
	 end
   val rec ('a_2136, 'a_2135) 
      make: ('a_2136 VectorSlice.slice -> 'a_2135) -> 'a_2136 vector -> 'a_2135 = 
	 fn x_2714: 'a_2136 VectorSlice.slice -> 'a_2135 => 
	 let
	    val x_2715: 'a_2136 vector -> 'a_2135 = 
	       fn x_2716: 'a_2136 vector => 
	       let
		  val x_2717: 'a_2136 VectorSlice.slice = 
		     full ('a_2136) x_2716
		  val x_2718: 'a_2135 = 
		     x_2714 x_2717
	       in
		  x_2718
	       end
	 in
	    x_2715
	 end
   val rec ('a_2139, 'a_2138, 'a_2137) 
      make2: ('a_2139 VectorSlice.slice * 'a_2138 VectorSlice.slice -> 'a_2137)
	     -> 'a_2139 vector * 'a_2138 vector -> 'a_2137 = 
	 fn x_2719: 'a_2139 VectorSlice.slice * 'a_2138 VectorSlice.slice
		    -> 'a_2137 => 
	 let
	    val x_2720: 'a_2139 vector * 'a_2138 vector -> 'a_2137 = 
	       fn x_2721: 'a_2139 vector * 'a_2138 vector => 
	       let
		  val x_2722: 'a_2138 vector = 
		     #1 x_2721
		  val x_2723: 'a_2139 vector = 
		     #0 x_2721
		  val x_2724: 'a_2139 VectorSlice.slice = 
		     full ('a_2139) x_2723
		  val x_2725: 'a_2138 VectorSlice.slice = 
		     full ('a_2138) x_2722
		  val x_2726: 'a_2139 VectorSlice.slice
			      * 'a_2138 VectorSlice.slice = 
		     (x_2724, x_2725)
		  val x_2727: 'a_2137 = 
		     x_2719 x_2726
	       in
		  x_2727
	       end
	 in
	    x_2720
	 end
   val rec 'a_2140 
      sub: 'a_2140 vector * word -> 'a_2140 = 
	 fn x_2728: 'a_2140 vector * word => 
	 let
	    val i: word = 
	       #1 x_2728
	    val seq: 'a_2140 vector = 
	       #0 x_2728
	    val x_2729: 'a_2140 VectorSlice.slice = 
	       full ('a_2140) seq
	    val x_2730: 'a_2140 VectorSlice.slice * word = 
	       (x_2729, i)
	    val x_2731: 'a_2140 = 
	       sub ('a_2140) x_2730
	 in
	    x_2731
	 end
   val rec 'a_2156 
      append: 'a_2156 vector * 'a_2156 vector -> 'a_2156 vector = 
	 fn x_2732: 'a_2156 vector * 'a_2156 vector => 
	 let
	    val x_2733: 'a_2156 vector * 'a_2156 vector -> 'a_2156 vector = 
	       make2 ('a_2156, 'a_2156, 'a_2156 vector) append ('a_2156)
	    val x_2734: 'a_2156 vector = 
	       x_2733 x_2732
	 in
	    x_2734
	 end
   val rec 'a_2157 
      concat: 'a_2157 vector list -> 'a_2157 vector = 
	 fn x_2735: 'a_2157 vector list => 
	 let
	    val x_2736: 'a_2157 vector list -> 'a_2157 VectorSlice.slice list = 
	       map_1 ('a_2157 VectorSlice.slice, 'a_2157 vector) full ('a_2157)
	    val x_2737: 'a_2157 VectorSlice.slice list = 
	       x_2736 x_2735
	    val x_2738: 'a_2157 vector = 
	       concat ('a_2157) x_2737
	 in
	    x_2738
	 end
   val rec 'a_2191 
      isPrefix: ('a_2191 * 'a_2191 -> bool)
		-> 'a_2191 vector -> 'a_2191 vector -> bool = 
	 fn x_2739: 'a_2191 * 'a_2191 -> bool => 
	 let
	    val x_2740: 'a_2191 vector -> 'a_2191 vector -> bool = 
	       fn x_2741: 'a_2191 vector => 
	       let
		  val x_2742: 'a_2191 vector
			      -> 'a_2191 VectorSlice.slice -> bool = 
		     isPrefix ('a_2191) x_2739
		  val x_2743: 'a_2191 VectorSlice.slice -> bool = 
		     x_2742 x_2741
		  val x_2744: 'a_2191 vector -> bool = 
		     make ('a_2191, bool) x_2743
	       in
		  x_2744
	       end
	 in
	    x_2740
	 end
   val rec ('a_2195, 'a_2194) 
      translate: ('a_2194 -> 'a_2195 vector) -> 'a_2194 vector -> 'a_2195 vector = 
	 fn x_2745: 'a_2194 -> 'a_2195 vector => 
	 let
	    val x_2746: 'a_2194 VectorSlice.slice -> 'a_2195 vector = 
	       translate ('a_2195, 'a_2194) x_2745
	    val x_2747: 'a_2194 vector -> 'a_2195 vector = 
	       make ('a_2194, 'a_2195 vector) x_2746
	 in
	    x_2747
	 end
   val ('b, 'a) translate_0: ('a -> 'b vector) -> 'a vector -> 'b vector = 
      let
      in
	 translate ('b, 'a)
      end
   val 'a tabulate'_0: Word64.word * (Word64.word -> 'a) -> 'a vector = 
      let
      in
	 tabulate' ('a)
      end
   val 'a tabulate_0: word * (word -> 'a) -> 'a vector = 
      let
      in
	 tabulate ('a)
      end
   val 'a sub_0: 'a vector * word -> 'a = 
      let
      in
	 sub ('a)
      end
   val 'a new_0: word * 'a -> 'a vector = 
      let
      in
	 new ('a)
      end
   val 'a length_2: 'a vector -> word = 
      let
      in
	 length ('a)
      end
   val 'a isPrefix_0: ('a * 'a -> bool) -> 'a vector -> 'a vector -> bool = 
      let
      in
	 isPrefix ('a)
      end
   val 'a fromList_0: 'a list -> 'a vector = 
      let
      in
	 fromList ('a)
      end
   val 'a concat_0: 'a vector list -> 'a vector = 
      let
      in
	 concat ('a)
      end
   val 'a append_0: 'a vector * 'a vector -> 'a vector = 
      let
      in
	 append ('a)
      end
   val 'a taker_0: ('a -> bool) -> 'a VectorSlice.slice -> 'a VectorSlice.slice = 
      let
      in
	 taker ('a)
      end
   val 'a takel_0: ('a -> bool) -> 'a VectorSlice.slice -> 'a VectorSlice.slice = 
      let
      in
	 takel ('a)
      end
   val 'a slice_0: 'a vector * word * word option -> 'a VectorSlice.slice = 
      let
      in
	 slice ('a)
      end
   val 'a sequence_0: 'a VectorSlice.slice -> 'a vector = 
      let
      in
	 sequence ('a)
      end
   val 'a full_0: 'a vector -> 'a VectorSlice.slice = 
      let
      in
	 full ('a)
      end
   val 'a dropr_0: ('a -> bool) -> 'a VectorSlice.slice -> 'a VectorSlice.slice = 
      let
      in
	 dropr ('a)
      end
   val 'a_2220 vector: 'a_2220 VectorSlice.slice -> 'a_2220 vector = 
      let
      in
	 sequence_0 ('a_2220)
      end
   val 'a_2224 unsafeFromArray: 'a_2224 array -> 'a_2224 vector = 
      let
      in
	 fromArrayUnsafe ('a_2224)
      end
   val 'a_2225 vector: word * 'a_2225 -> 'a_2225 vector = 
      let
      in
	 new_0 ('a_2225)
      end
   val 'a vector_0: word * 'a -> 'a vector = 
      let
      in
	 vector ('a)
      end
   val 'a unsafeFromArray_0: 'a array -> 'a vector = 
      let
      in
	 unsafeFromArray ('a)
      end
   val ('b, 'a) translate_1: ('a -> 'b vector) -> 'a vector -> 'b vector = 
      let
      in
	 translate_0 ('b, 'a)
      end
   val 'a tabulate'_1: Word64.word * (Word64.word -> 'a) -> 'a vector = 
      let
      in
	 tabulate'_0 ('a)
      end
   val 'a tabulate_1: word * (word -> 'a) -> 'a vector = 
      let
      in
	 tabulate_0 ('a)
      end
   val 'a sub_1: 'a vector * word -> 'a = 
      let
      in
	 sub_0 ('a)
      end
   val 'a length_3: 'a vector -> word = 
      let
      in
	 length_2 ('a)
      end
   val 'a isPrefix_1: ('a * 'a -> bool) -> 'a vector -> 'a vector -> bool = 
      let
      in
	 isPrefix_0 ('a)
      end
   val 'a fromList_1: 'a list -> 'a vector = 
      let
      in
	 fromList_0 ('a)
      end
   val 'a concat_1: 'a vector list -> 'a vector = 
      let
      in
	 concat_0 ('a)
      end
   val 'a append_1: 'a vector * 'a vector -> 'a vector = 
      let
      in
	 append_0 ('a)
      end
   val 'a vector_1: 'a VectorSlice.slice -> 'a vector = 
      let
      in
	 vector ('a)
      end
   val 'a taker_1: ('a -> bool) -> 'a VectorSlice.slice -> 'a VectorSlice.slice = 
      let
      in
	 taker_0 ('a)
      end
   val 'a takel_1: ('a -> bool) -> 'a VectorSlice.slice -> 'a VectorSlice.slice = 
      let
      in
	 takel_0 ('a)
      end
   val 'a slice_1: 'a vector * word * word option -> 'a VectorSlice.slice = 
      let
      in
	 slice_0 ('a)
      end
   val 'a full_1: 'a vector -> 'a VectorSlice.slice = 
      let
      in
	 full_0 ('a)
      end
   val 'a dropr_1: ('a -> bool) -> 'a VectorSlice.slice -> 'a VectorSlice.slice = 
      let
      in
	 dropr_0 ('a)
      end
   val 'a_2240 fromArray: 'a_2240 -> 'a_2240 = 
      let
	 val x_2748: 'a_2240 -> 'a_2240 = 
	    fn x_2749: 'a_2240 => 
	    let
	    in
	       x_2749
	    end
      in
	 x_2748
      end
   val isMutable: bool = 
      true
   val 'a_2241 length: 'a_2241 array -> Word64.word = 
      let
      in
	 length ('a_2241)
      end
   val 'a_2242 subUnsafe: 'a_2242 array * Word64.word -> 'a_2242 = 
      let
      in
	 subUnsafe ('a_2242)
      end
   val 'a subUnsafe_1: 'a array * Word64.word -> 'a = 
      let
      in
	 subUnsafe ('a)
      end
   val 'a length_4: 'a array -> Word64.word = 
      let
      in
	 length ('a)
      end
   val 'a fromArray_1: 'a array -> 'a array = 
      let
      in
	 fromArray ('a array)
      end
   val rec ('a_2248, 'a_2247) 
      wrap2: (word * 'a_2248 -> 'a_2247) -> Word64.word * 'a_2248 -> 'a_2247 = 
	 fn x_2750: word * 'a_2248 -> 'a_2247 => 
	 let
	    val x_2751: Word64.word * 'a_2248 -> 'a_2247 = 
	       fn x_2752: Word64.word * 'a_2248 => 
	       let
		  val x: 'a_2248 = 
		     #1 x_2752
		  val i: Word64.word = 
		     #0 x_2752
		  val x_2753: word = 
		     sextdFromInt64ToInt32 i
		  val x_2754: word * 'a_2248 = 
		     (x_2753, x)
		  val x_2755: 'a_2247 = 
		     x_2750 x_2754
	       in
		  x_2755
	       end
	 in
	    x_2751
	 end
   val rec ('a_2251, 'a_2250, 'a_2249) 
      wrap3: (word * 'a_2251 * 'a_2250 -> 'a_2249)
	     -> Word64.word * 'a_2251 * 'a_2250 -> 'a_2249 = 
	 fn x_2756: word * 'a_2251 * 'a_2250 -> 'a_2249 => 
	 let
	    val x_2757: Word64.word * 'a_2251 * 'a_2250 -> 'a_2249 = 
	       fn x_2758: Word64.word * 'a_2251 * 'a_2250 => 
	       let
		  val y: 'a_2250 = 
		     #2 x_2758
		  val x: 'a_2251 = 
		     #1 x_2758
		  val i: Word64.word = 
		     #0 x_2758
		  val x_2759: word = 
		     sextdFromInt64ToInt32 i
		  val x_2760: word * 'a_2251 * 'a_2250 = 
		     (x_2759, x, y)
		  val x_2761: 'a_2249 = 
		     x_2756 x_2760
	       in
		  x_2761
	       end
	 in
	    x_2757
	 end
   val rec 'a_2255 
      doit: word * (Word64.word -> 'a_2255) * ('a_2255 -> Word64.word) * 'a_2255
	    -> Word64.word * 'a_2255 = 
	 fn x_2762: word
		    * (Word64.word -> 'a_2255)
		    * ('a_2255 -> Word64.word)
		    * 'a_2255 => 
	 let
	    val maxInt': 'a_2255 = 
	       #3 x_2762
	    val fromInt: 'a_2255 -> Word64.word = 
	       #2 x_2762
	    val toInt: Word64.word -> 'a_2255 = 
	       #1 x_2762
	    val precision: word = 
	       #0 x_2762
	    val x_2763: word = 
	       valOf_1 (word) precision
	    val x_2764: word * word = 
	       (x_2763, precision)
	    val x_2765: bool = 
	       >= x_2764
	    val x_2766: Word64.word * 'a_2255 = 
	       case x_2765 of
	       true => 
		  let
		     val x_2769: Word64.word = 
			fromInt maxInt'
		     val x_2770: Word64.word * 'a_2255 = 
			(x_2769, maxInt')
		  in
		     x_2770
		  end
	       false => 
		  let
		     val x_2767: 'a_2255 = 
			toInt maxInt'
		     val x_2768: Word64.word * 'a_2255 = 
			(maxInt', x_2767)
		  in
		     x_2768
		  end
	 in
	    x_2766
	 end
   val x_2771: word = 
      valOf_1 (word) precision
   val x_2772: word
	       * (Word64.word -> Word8.word)
	       * (Word8.word -> Word64.word)
	       * Word8.word = 
      (x_2771, schckFromInt64ToInt8, sextdFromInt8ToInt64, maxInt')
   val fInt8: Word64.word * Word8.word = 
      doit (Word8.word) x_2772
   val x_2773: word = 
      valOf_1 (word) precision
   val x_2774: word
	       * (Word64.word -> Word16.word)
	       * (Word16.word -> Word64.word)
	       * Word16.word = 
      (x_2773, schckFromInt64ToInt16, sextdFromInt16ToInt64, maxInt')
   val fInt16: Word64.word * Word16.word = 
      doit (Word16.word) x_2774
   val x_2775: word = 
      valOf_1 (word) precision
   val x_2776: word * (Word64.word -> word) * (word -> Word64.word) * word = 
      (x_2775, schckFromInt64ToInt32, sextdFromInt32ToInt64, maxInt')
   val fInt32: Word64.word * word = 
      doit (word) x_2776
   val x_2777: word = 
      valOf_1 (word) precision
   val x_2778: word
	       * (Word64.word -> Word64.word)
	       * (Word64.word -> Word64.word)
	       * Word64.word = 
      (x_2777, sextdFromInt64ToInt64, sextdFromInt64ToInt64, maxInt')
   val fInt64: Word64.word * Word64.word = 
      doit (Word64.word) x_2778
   val x_2779: IntInf.int = 
      sextdFromInt64 maxInt'
   val maxLen': Word64.word = 
      #0 fInt32
   val rec 
      fromIntForLength: word -> Word64.word = 
	 fn x_2780: word => 
	 let
	    val x_2781: Word64.word = 
	       let
		  val x_2782: Word64.word = 
		     sextdFromInt32ToInt64 x_2780
	       in
		  x_2782
	       end
	       handle x_2783 => let
				   val x_2784: Word64.word = 
				      case x_2783 of
				      Overflow => 
					 let
					    val x_2785: exn = 
					       Size
					    val x_2786: Word64.word = 
					       raise x_2785
					 in
					    x_2786
					 end
					_ => let
						val x_2787: Word64.word = 
						   raise x_2783
					     in
						x_2787
					     end
				in
				   x_2784
				end
	 in
	    x_2781
	 end
   val rec 'a_2258 
      length': 'a_2258 array -> Word64.word = 
	 fn x_2788: 'a_2258 array => 
	 let
	    val x_2789: Word64.word = 
	       length_4 ('a_2258) x_2788
	 in
	    x_2789
	 end
   val rec 'a_2259 
      length: 'a_2259 array -> word = 
	 fn x_2790: 'a_2259 array => 
	 let
	    val x_2791: word = 
	       let
		  val x_2792: Word64.word = 
		     length' ('a_2259) x_2790
		  val x_2793: word = 
		     schckFromInt64ToInt32 x_2792
	       in
		  x_2793
	       end
	       handle x_2794 => let
				   val x_2795: word = 
				      case x_2794 of
				      Overflow => 
					 let
					    val x_2796: Word8.word vector = 
					       "Sequence.length"
					    val x_2797: exn = 
					       Fail x_2796
					    val x_2798: word = 
					       raise x_2797
					 in
					    x_2798
					 end
					_ => let
						val x_2799: word = 
						   raise x_2794
					     in
						x_2799
					     end
				in
				   x_2795
				end
	 in
	    x_2791
	 end
   val rec 'a_2260 
      arrayUninit': Word64.word -> 'a_2260 array = 
	 fn x_2800: Word64.word => 
	 let
	    val x_2801: bool = 
	       not isMutable
	    val x_2802: bool = 
	       case x_2801 of
	       true => 
		  let
		     val x_2804: Word64.word = 
			0x0
		     val x_2805: Word64.word * Word64.word = 
			(x_2800, x_2804)
		     val x_2806: bool = 
			= (Word64.word) x_2805
		  in
		     x_2806
		  end
	       false => 
		  let
		     val x_2803: bool = 
			false
		  in
		     x_2803
		  end
	    val x_2807: 'a_2260 array = 
	       case x_2802 of
	       true => 
		  let
		     val x_2814: unit = 
			()
		     val x_2815: 'a_2260 array = 
			array0Const ('a_2260) x_2814
		  in
		     x_2815
		  end
	       false => 
		  let
		     val x_2808: Word64.word * Word64.word = 
			(x_2800, maxLen')
		     val x_2809: bool = 
			> x_2808
		     val x_2810: 'a_2260 array = 
			case x_2809 of
			true => 
			   let
			      val x_2812: exn = 
				 Size
			      val x_2813: 'a_2260 array = 
				 raise x_2812
			   in
			      x_2813
			   end
			false => 
			   let
			      val x_2811: 'a_2260 array = 
				 arrayUnsafe ('a_2260) x_2800
			   in
			      x_2811
			   end
		  in
		     x_2810
		  end
	 in
	    x_2807
	 end
   val rec 'a_2261 
      arrayUninit: word -> 'a_2261 array = 
	 fn x_2816: word => 
	 let
	    val x_2817: Word64.word = 
	       fromIntForLength x_2816
	    val x_2818: 'a_2261 array = 
	       arrayUninit' ('a_2261) x_2817
	 in
	    x_2818
	 end
   val rec 'a_2263 
      newUninit: word -> 'a_2263 array = 
	 fn x_2819: word => 
	 let
	    val x_2820: 'a_2263 array = 
	       arrayUninit ('a_2263) x_2819
	    val x_2821: 'a_2263 array = 
	       fromArray_1 ('a_2263) x_2820
	 in
	    x_2821
	 end
   val rec ('a_2267, 'a_2266) 
      unfoldi': Word64.word
		* 'a_2267
		* (Word64.word * 'a_2267 -> 'a_2266 * 'a_2267)
		-> 'a_2266 array * 'a_2267 = 
	 fn x_2822: Word64.word
		    * 'a_2267
		    * (Word64.word * 'a_2267 -> 'a_2266 * 'a_2267) => 
	 let
	    val f: Word64.word * 'a_2267 -> 'a_2266 * 'a_2267 = 
	       #2 x_2822
	    val b: 'a_2267 = 
	       #1 x_2822
	    val n: Word64.word = 
	       #0 x_2822
	    val a: 'a_2266 array = 
	       arrayUninit' ('a_2266) n
	    val rec 
	       loop: Word64.word * 'a_2267 -> 'a_2267 = 
		  fn x_2823: Word64.word * 'a_2267 => 
		  let
		     val b: 'a_2267 = 
			#1 x_2823
		     val i: Word64.word = 
			#0 x_2823
		     val x_2824: Word64.word * Word64.word = 
			(i, n)
		     val x_2825: bool = 
			>= x_2824
		     val x_2826: 'a_2267 = 
			case x_2825 of
			true => 
			   let
			   in
			      b
			   end
			false => 
			   let
			      val x_2827: Word64.word * 'a_2267 = 
				 (i, b)
			      val x_2828: 'a_2266 * 'a_2267 = 
				 f x_2827
			      val b': 'a_2267 = 
				 #1 x_2828
			      val x: 'a_2266 = 
				 #0 x_2828
			      val x_2829: 'a_2266 array * Word64.word * 'a_2266 = 
				 (a, i, x)
			      val x_2830: unit = 
				 updateUnsafe ('a_2266) x_2829
			      val x_2831: Word64.word = 
				 0x1
			      val x_2832: Word64.word * Word64.word = 
				 (i, x_2831)
			      val x_2833: Word64.word = 
				 +? x_2832
			      val x_2834: Word64.word * 'a_2267 = 
				 (x_2833, b')
			      val x_2835: 'a_2267 = 
				 loop x_2834
			   in
			      x_2835
			   end
		  in
		     x_2826
		  end
	    val x_2836: Word64.word = 
	       0x0
	    val x_2837: Word64.word * 'a_2267 = 
	       (x_2836, b)
	    val b: 'a_2267 = 
	       loop x_2837
	    val x_2838: 'a_2266 array = 
	       fromArray_1 ('a_2266) a
	    val x_2839: 'a_2266 array * 'a_2267 = 
	       (x_2838, b)
	 in
	    x_2839
	 end
   val rec ('a_2269, 'a_2268) 
      unfoldi: word * 'a_2268 * (word * 'a_2268 -> 'a_2269 * 'a_2268)
	       -> 'a_2269 array * 'a_2268 = 
	 fn x_2840: word * 'a_2268 * (word * 'a_2268 -> 'a_2269 * 'a_2268) => 
	 let
	    val f: word * 'a_2268 -> 'a_2269 * 'a_2268 = 
	       #2 x_2840
	    val b: 'a_2268 = 
	       #1 x_2840
	    val n: word = 
	       #0 x_2840
	    val x_2841: Word64.word = 
	       fromIntForLength n
	    val x_2842: Word64.word * 'a_2268 -> 'a_2269 * 'a_2268 = 
	       wrap2 ('a_2268, 'a_2269 * 'a_2268) f
	    val x_2843: Word64.word
			* 'a_2268
			* (Word64.word * 'a_2268 -> 'a_2269 * 'a_2268) = 
	       (x_2841, b, x_2842)
	    val x_2844: 'a_2269 array * 'a_2268 = 
	       unfoldi' ('a_2268, 'a_2269) x_2843
	 in
	    x_2844
	 end
   val rec 'a_2274 
      tabulate: word * (word -> 'a_2274) -> 'a_2274 array = 
	 fn x_2845: word * (word -> 'a_2274) => 
	 let
	    val f: word -> 'a_2274 = 
	       #1 x_2845
	    val n: word = 
	       #0 x_2845
	    val x_2846: unit = 
	       ()
	    val x_2847: word * unit -> 'a_2274 * unit = 
	       fn x_2848: word * unit => 
	       let
		  val x_2849: word = 
		     #0 x_2848
		  val x_2850: 'a_2274 = 
		     f x_2849
		  val x_2851: unit = 
		     ()
		  val x_2852: 'a_2274 * unit = 
		     (x_2850, x_2851)
	       in
		  x_2852
	       end
	    val x_2853: word * unit * (word * unit -> 'a_2274 * unit) = 
	       (n, x_2846, x_2847)
	    val x_2854: 'a_2274 array * unit = 
	       unfoldi ('a_2274, unit) x_2853
	    val x_2855: 'a_2274 array = 
	       #0 x_2854
	 in
	    x_2855
	 end
   val rec 'a_2276 
      new: word * 'a_2276 -> 'a_2276 array = 
	 fn x_2856: word * 'a_2276 => 
	 let
	    val x: 'a_2276 = 
	       #1 x_2856
	    val n: word = 
	       #0 x_2856
	    val x_2857: word -> 'a_2276 = 
	       fn x_2858: word => 
	       let
	       in
		  x
	       end
	    val x_2859: word * (word -> 'a_2276) = 
	       (n, x_2857)
	    val x_2860: 'a_2276 array = 
	       tabulate ('a_2276) x_2859
	 in
	    x_2860
	 end
   val rec 'a_2280 
      unsafeSub': 'a_2280 ArraySlice.slice * Word64.word -> 'a_2280 = 
	 fn x_2861: 'a_2280 ArraySlice.slice * Word64.word => 
	 let
	    val x_2862: Word64.word = 
	       #1 x_2861
	    val x_2863: 'a_2280 ArraySlice.slice = 
	       #0 x_2861
	    val x_2864: 'a_2280 = 
	       case x_2863 of
	       T['a_2280] x_2865: Word64.word * 'a_2280 array * Word64.word => 
		  let
		     val x_2866: Word64.word = 
			#2 x_2865
		     val x_2867: 'a_2280 array = 
			#1 x_2865
		     val x_2868: Word64.word * Word64.word = 
			(x_2866, x_2862)
		     val x_2869: Word64.word = 
			+? x_2868
		     val x_2870: 'a_2280 array * Word64.word = 
			(x_2867, x_2869)
		     val x_2871: 'a_2280 = 
			subUnsafe_1 ('a_2280) x_2870
		  in
		     x_2871
		  end
	 in
	    x_2864
	 end
   val rec 'a_2281 
      unsafeSub: 'a_2281 ArraySlice.slice * word -> 'a_2281 = 
	 fn x_2872: 'a_2281 ArraySlice.slice * word => 
	 let
	    val i: word = 
	       #1 x_2872
	    val sl: 'a_2281 ArraySlice.slice = 
	       #0 x_2872
	    val x_2873: Word64.word = 
	       sextdFromInt32ToInt64 i
	    val x_2874: 'a_2281 ArraySlice.slice * Word64.word = 
	       (sl, x_2873)
	    val x_2875: 'a_2281 = 
	       unsafeSub' ('a_2281) x_2874
	 in
	    x_2875
	 end
   val rec 'a_2282 
      sub': 'a_2282 ArraySlice.slice * Word64.word -> 'a_2282 = 
	 fn x_2876: 'a_2282 ArraySlice.slice * Word64.word => 
	 let
	    val x_2877: Word64.word = 
	       #1 x_2876
	    val x_2878: 'a_2282 ArraySlice.slice = 
	       #0 x_2876
	    val x_2879: 'a_2282 = 
	       case x_2878 of
	       T['a_2282] x_2880: Word64.word * 'a_2282 array * Word64.word => 
		  let
		     val x_2881: Word64.word = 
			#0 x_2880
		     val x_2882: Word64.word * Word64.word = 
			(x_2877, x_2881)
		     val x_2883: bool = 
			>= x_2882
		     val x_2884: 'a_2282 = 
			case x_2883 of
			true => 
			   let
			      val x_2887: exn = 
				 Subscript
			      val x_2888: 'a_2282 = 
				 raise x_2887
			   in
			      x_2888
			   end
			false => 
			   let
			      val x_2885: 'a_2282 ArraySlice.slice * Word64.word = 
				 (x_2878, x_2877)
			      val x_2886: 'a_2282 = 
				 unsafeSub' ('a_2282) x_2885
			   in
			      x_2886
			   end
		  in
		     x_2884
		  end
	 in
	    x_2879
	 end
   val rec 'a_2283 
      sub: 'a_2283 ArraySlice.slice * word -> 'a_2283 = 
	 fn x_2889: 'a_2283 ArraySlice.slice * word => 
	 let
	    val i: word = 
	       #1 x_2889
	    val sl: 'a_2283 ArraySlice.slice = 
	       #0 x_2889
	    val i: Word64.word = 
	       let
		  val x_2890: Word64.word = 
		     sextdFromInt32ToInt64 i
	       in
		  x_2890
	       end
	       handle x_2891 => let
				   val x_2892: Word64.word = 
				      case x_2891 of
				      Overflow => 
					 let
					    val x_2893: exn = 
					       Subscript
					    val x_2894: Word64.word = 
					       raise x_2893
					 in
					    x_2894
					 end
					_ => let
						val x_2895: Word64.word = 
						   raise x_2891
					     in
						x_2895
					     end
				in
				   x_2892
				end
	    val x_2896: 'a_2283 ArraySlice.slice * Word64.word = 
	       (sl, i)
	    val x_2897: 'a_2283 = 
	       sub' ('a_2283) x_2896
	 in
	    x_2897
	 end
   val rec ('a_2286, 'a_2285, 'a_2284) 
      unsafeUpdate'Mk: ('a_2286 array * Word64.word * 'a_2285 -> 'a_2284)
		       -> 'a_2286 ArraySlice.slice * Word64.word * 'a_2285
			  -> 'a_2284 = 
	 fn x_2898: 'a_2286 array * Word64.word * 'a_2285 -> 'a_2284 => 
	 let
	    val x_2899: 'a_2286 ArraySlice.slice * Word64.word * 'a_2285
			-> 'a_2284 = 
	       fn x_2900: 'a_2286 ArraySlice.slice * Word64.word * 'a_2285 => 
	       let
		  val x_2901: 'a_2285 = 
		     #2 x_2900
		  val x_2902: Word64.word = 
		     #1 x_2900
		  val x_2903: 'a_2286 ArraySlice.slice = 
		     #0 x_2900
		  val x_2904: 'a_2284 = 
		     case x_2903 of
		     T['a_2286] x_2905: Word64.word
					* 'a_2286 array
					* Word64.word => 
			let
			   val x_2906: Word64.word = 
			      #2 x_2905
			   val x_2907: 'a_2286 array = 
			      #1 x_2905
			   val x_2908: Word64.word * Word64.word = 
			      (x_2906, x_2902)
			   val x_2909: Word64.word = 
			      +? x_2908
			   val x_2910: 'a_2286 array * Word64.word * 'a_2285 = 
			      (x_2907, x_2909, x_2901)
			   val x_2911: 'a_2284 = 
			      x_2898 x_2910
			in
			   x_2911
			end
	       in
		  x_2904
	       end
	 in
	    x_2899
	 end
   val rec ('a_2289, 'a_2288, 'a_2287) 
      unsafeUpdateMk: ('a_2289 array * Word64.word * 'a_2288 -> 'a_2287)
		      -> 'a_2289 ArraySlice.slice * word * 'a_2288 -> 'a_2287 = 
	 fn x_2912: 'a_2289 array * Word64.word * 'a_2288 -> 'a_2287 => 
	 let
	    val x_2913: 'a_2289 ArraySlice.slice * word * 'a_2288 -> 'a_2287 = 
	       fn x_2914: 'a_2289 ArraySlice.slice * word * 'a_2288 => 
	       let
		  val x_2915: 'a_2288 = 
		     #2 x_2914
		  val x_2916: word = 
		     #1 x_2914
		  val x_2917: 'a_2289 ArraySlice.slice = 
		     #0 x_2914
		  val x_2918: 'a_2289 ArraySlice.slice * Word64.word * 'a_2288
			      -> 'a_2287 = 
		     unsafeUpdate'Mk ('a_2289, 'a_2288, 'a_2287) x_2912
		  val x_2919: Word64.word = 
		     sextdFromInt32ToInt64 x_2916
		  val x_2920: 'a_2289 ArraySlice.slice * Word64.word * 'a_2288 = 
		     (x_2917, x_2919, x_2915)
		  val x_2921: 'a_2287 = 
		     x_2918 x_2920
	       in
		  x_2921
	       end
	 in
	    x_2913
	 end
   val rec ('a_2292, 'a_2291, 'a_2290) 
      update'Mk: ('a_2292 array * Word64.word * 'a_2291 -> 'a_2290)
		 -> 'a_2292 ArraySlice.slice * Word64.word * 'a_2291 -> 'a_2290 = 
	 fn x_2922: 'a_2292 array * Word64.word * 'a_2291 -> 'a_2290 => 
	 let
	    val x_2923: 'a_2292 ArraySlice.slice * Word64.word * 'a_2291
			-> 'a_2290 = 
	       fn x_2924: 'a_2292 ArraySlice.slice * Word64.word * 'a_2291 => 
	       let
		  val x_2925: 'a_2291 = 
		     #2 x_2924
		  val x_2926: Word64.word = 
		     #1 x_2924
		  val x_2927: 'a_2292 ArraySlice.slice = 
		     #0 x_2924
		  val x_2928: 'a_2290 = 
		     case x_2927 of
		     T['a_2292] x_2929: Word64.word
					* 'a_2292 array
					* Word64.word => 
			let
			   val x_2930: Word64.word = 
			      #0 x_2929
			   val x_2931: Word64.word * Word64.word = 
			      (x_2926, x_2930)
			   val x_2932: bool = 
			      >= x_2931
			   val x_2933: 'a_2290 = 
			      case x_2932 of
			      true => 
				 let
				    val x_2937: exn = 
				       Subscript
				    val x_2938: 'a_2290 = 
				       raise x_2937
				 in
				    x_2938
				 end
			      false => 
				 let
				    val x_2934: 'a_2292 ArraySlice.slice
						* Word64.word
						* 'a_2291
						-> 'a_2290 = 
				       unsafeUpdate'Mk ('a_2292,
							'a_2291,
							'a_2290) x_2922
				    val x_2935: 'a_2292 ArraySlice.slice
						* Word64.word
						* 'a_2291 = 
				       (x_2927, x_2926, x_2925)
				    val x_2936: 'a_2290 = 
				       x_2934 x_2935
				 in
				    x_2936
				 end
			in
			   x_2933
			end
	       in
		  x_2928
	       end
	 in
	    x_2923
	 end
   val rec ('a_2295, 'a_2294, 'a_2293) 
      updateMk: ('a_2295 array * Word64.word * 'a_2294 -> 'a_2293)
		-> 'a_2295 ArraySlice.slice * word * 'a_2294 -> 'a_2293 = 
	 fn x_2939: 'a_2295 array * Word64.word * 'a_2294 -> 'a_2293 => 
	 let
	    val x_2940: 'a_2295 ArraySlice.slice * word * 'a_2294 -> 'a_2293 = 
	       fn x_2941: 'a_2295 ArraySlice.slice * word * 'a_2294 => 
	       let
		  val x_2942: 'a_2294 = 
		     #2 x_2941
		  val x_2943: word = 
		     #1 x_2941
		  val x_2944: 'a_2295 ArraySlice.slice = 
		     #0 x_2941
		  val i: Word64.word = 
		     let
			val x_2945: Word64.word = 
			   sextdFromInt32ToInt64 x_2943
		     in
			x_2945
		     end
		     handle x_2946 => let
					 val x_2947: Word64.word = 
					    case x_2946 of
					    Overflow => 
					       let
						  val x_2948: exn = 
						     Subscript
						  val x_2949: Word64.word = 
						     raise x_2948
					       in
						  x_2949
					       end
					      _ => let
						      val x_2950: Word64.word = 
							 raise x_2946
						   in
						      x_2950
						   end
				      in
					 x_2947
				      end
		  val x_2951: 'a_2295 ArraySlice.slice * Word64.word * 'a_2294
			      -> 'a_2293 = 
		     update'Mk ('a_2295, 'a_2294, 'a_2293) x_2939
		  val x_2952: 'a_2295 ArraySlice.slice * Word64.word * 'a_2294 = 
		     (x_2944, i, x_2942)
		  val x_2953: 'a_2293 = 
		     x_2951 x_2952
	       in
		  x_2953
	       end
	 in
	    x_2940
	 end
   val rec 'a 
      full: 'a array -> 'a ArraySlice.slice = 
	 fn x_2954: 'a array => 
	 let
	    val x_2955: Word64.word = 
	       0x0
	    val x_2956: Word64.word = 
	       length_4 ('a) x_2954
	    val x_2957: Word64.word * 'a array * Word64.word = 
	       (x_2956, x_2954, x_2955)
	    val x_2958: 'a ArraySlice.slice = 
	       T['a] x_2957
	 in
	    x_2958
	 end
   val rec 'a_2296 
      unsafeSubslice': 'a_2296 ArraySlice.slice
		       * Word64.word
		       * Word64.word option
		       -> 'a_2296 ArraySlice.slice = 
	 fn x_2959: 'a_2296 ArraySlice.slice * Word64.word * Word64.word option => 
	 let
	    val x_2960: Word64.word option = 
	       #2 x_2959
	    val x_2961: Word64.word = 
	       #1 x_2959
	    val x_2962: 'a_2296 ArraySlice.slice = 
	       #0 x_2959
	    val x_2963: 'a_2296 ArraySlice.slice = 
	       case x_2962 of
	       T['a_2296] x_2964: Word64.word * 'a_2296 array * Word64.word => 
		  let
		     val x_2965: Word64.word = 
			#2 x_2964
		     val x_2966: 'a_2296 array = 
			#1 x_2964
		     val x_2967: Word64.word = 
			#0 x_2964
		     val x_2968: Word64.word * Word64.word = 
			(x_2965, x_2961)
		     val x_2969: Word64.word = 
			+? x_2968
		     val x_2970: Word64.word = 
			case x_2960 of
			NONE[Word64.word] => 
			   let
			      val x_2972: Word64.word * Word64.word = 
				 (x_2967, x_2961)
			      val x_2973: Word64.word = 
				 -? x_2972
			   in
			      x_2973
			   end
			SOME[Word64.word] x_2971: Word64.word => 
			   let
			   in
			      x_2971
			   end
		     val x_2974: Word64.word * 'a_2296 array * Word64.word = 
			(x_2970, x_2966, x_2969)
		     val x_2975: 'a_2296 ArraySlice.slice = 
			T['a_2296] x_2974
		  in
		     x_2975
		  end
	 in
	    x_2963
	 end
   val rec 'a_2297 
      unsafeSubslice: 'a_2297 ArraySlice.slice * word * word option
		      -> 'a_2297 ArraySlice.slice = 
	 fn x_2976: 'a_2297 ArraySlice.slice * word * word option => 
	 let
	    val len: word option = 
	       #2 x_2976
	    val start: word = 
	       #1 x_2976
	    val sl: 'a_2297 ArraySlice.slice = 
	       #0 x_2976
	    val x_2977: Word64.word = 
	       sextdFromInt32ToInt64 start
	    val x_2978: word option -> Word64.word option = 
	       map_0 (Word64.word, word) sextdFromInt32ToInt64
	    val x_2979: Word64.word option = 
	       x_2978 len
	    val x_2980: 'a_2297 ArraySlice.slice
			* Word64.word
			* Word64.word option = 
	       (sl, x_2977, x_2979)
	    val x_2981: 'a_2297 ArraySlice.slice = 
	       unsafeSubslice' ('a_2297) x_2980
	 in
	    x_2981
	 end
   val rec 'a_2300 
      subslice': 'a_2300 ArraySlice.slice * Word64.word * Word64.word option
		 -> 'a_2300 ArraySlice.slice = 
	 fn x_2982: 'a_2300 ArraySlice.slice * Word64.word * Word64.word option => 
	 let
	    val x_2983: Word64.word option = 
	       #2 x_2982
	    val x_2984: Word64.word = 
	       #1 x_2982
	    val x_2985: 'a_2300 ArraySlice.slice = 
	       #0 x_2982
	    val x_2986: 'a_2300 ArraySlice.slice = 
	       case x_2985 of
	       T['a_2300] x_2987: Word64.word * 'a_2300 array * Word64.word => 
		  let
		     val x_2988: Word64.word = 
			#2 x_2987
		     val x_2989: 'a_2300 array = 
			#1 x_2987
		     val x_2990: Word64.word = 
			#0 x_2987
		     val x_2991: 'a_2300 ArraySlice.slice = 
			case x_2983 of
			NONE[Word64.word] => 
			   let
			      val x_3008: Word64.word * Word64.word = 
				 (x_2984, x_2990)
			      val x_3009: bool = 
				 > x_3008
			      val x_3010: 'a_2300 ArraySlice.slice = 
				 case x_3009 of
				 true => 
				    let
				       val x_3017: exn = 
					  Subscript
				       val x_3018: 'a_2300 ArraySlice.slice = 
					  raise x_3017
				    in
				       x_3018
				    end
				 false => 
				    let
				       val x_3011: Word64.word * Word64.word = 
					  (x_2988, x_2984)
				       val x_3012: Word64.word = 
					  +? x_3011
				       val x_3013: Word64.word * Word64.word = 
					  (x_2990, x_2984)
				       val x_3014: Word64.word = 
					  -? x_3013
				       val x_3015: Word64.word
						   * 'a_2300 array
						   * Word64.word = 
					  (x_3014, x_2989, x_3012)
				       val x_3016: 'a_2300 ArraySlice.slice = 
					  T['a_2300] x_3015
				    in
				       x_3016
				    end
			   in
			      x_3010
			   end
			SOME[Word64.word] x_2992: Word64.word => 
			   let
			      val x_2993: Word64.word * Word64.word = 
				 (x_2984, x_2990)
			      val x_2994: bool = 
				 > x_2993
			      val x_2995: bool = 
				 case x_2994 of
				 true => 
				    let
				       val x_3000: bool = 
					  true
				    in
				       x_3000
				    end
				 false => 
				    let
				       val x_2996: Word64.word * Word64.word = 
					  (x_2990, x_2984)
				       val x_2997: Word64.word = 
					  -? x_2996
				       val x_2998: Word64.word * Word64.word = 
					  (x_2992, x_2997)
				       val x_2999: bool = 
					  > x_2998
				    in
				       x_2999
				    end
			      val x_3001: 'a_2300 ArraySlice.slice = 
				 case x_2995 of
				 true => 
				    let
				       val x_3006: exn = 
					  Subscript
				       val x_3007: 'a_2300 ArraySlice.slice = 
					  raise x_3006
				    in
				       x_3007
				    end
				 false => 
				    let
				       val x_3002: Word64.word * Word64.word = 
					  (x_2988, x_2984)
				       val x_3003: Word64.word = 
					  +? x_3002
				       val x_3004: Word64.word
						   * 'a_2300 array
						   * Word64.word = 
					  (x_2992, x_2989, x_3003)
				       val x_3005: 'a_2300 ArraySlice.slice = 
					  T['a_2300] x_3004
				    in
				       x_3005
				    end
			   in
			      x_3001
			   end
		  in
		     x_2991
		  end
	 in
	    x_2986
	 end
   val rec 'a_2301 
      subslice: 'a_2301 ArraySlice.slice * word * word option
		-> 'a_2301 ArraySlice.slice = 
	 fn x_3019: 'a_2301 ArraySlice.slice * word * word option => 
	 let
	    val len: word option = 
	       #2 x_3019
	    val start: word = 
	       #1 x_3019
	    val sl: 'a_2301 ArraySlice.slice = 
	       #0 x_3019
	    val x_3020: 'a_2301 ArraySlice.slice = 
	       let
		  val x_3021: Word64.word = 
		     sextdFromInt32ToInt64 start
		  val x_3022: word option -> Word64.word option = 
		     map_0 (Word64.word, word) sextdFromInt32ToInt64
		  val x_3023: Word64.word option = 
		     x_3022 len
		  val x_3024: 'a_2301 ArraySlice.slice
			      * Word64.word
			      * Word64.word option = 
		     (sl, x_3021, x_3023)
		  val x_3025: 'a_2301 ArraySlice.slice = 
		     subslice' ('a_2301) x_3024
	       in
		  x_3025
	       end
	       handle x_3026 => let
				   val x_3027: 'a_2301 ArraySlice.slice = 
				      case x_3026 of
				      Overflow => 
					 let
					    val x_3028: exn = 
					       Subscript
					    val x_3029: 'a_2301 ArraySlice.slice = 
					       raise x_3028
					 in
					    x_3029
					 end
					_ => let
						val x_3030: 'a_2301 ArraySlice.slice = 
						   raise x_3026
					     in
						x_3030
					     end
				in
				   x_3027
				end
	 in
	    x_3020
	 end
   val rec 'a 
      slice: 'a array * word * word option -> 'a ArraySlice.slice = 
	 fn x_3031: 'a array * word * word option => 
	 let
	    val len: word option = 
	       #2 x_3031
	    val start: word = 
	       #1 x_3031
	    val seq: 'a array = 
	       #0 x_3031
	    val x_3032: 'a ArraySlice.slice = 
	       full ('a) seq
	    val x_3033: 'a ArraySlice.slice * word * word option = 
	       (x_3032, start, len)
	    val x_3034: 'a ArraySlice.slice = 
	       subslice ('a) x_3033
	 in
	    x_3034
	 end
   val rec ('a_2311, 'a_2310) 
      foldri': (Word64.word * 'a_2311 * 'a_2310 -> 'a_2310)
	       -> 'a_2310 -> 'a_2311 ArraySlice.slice -> 'a_2310 = 
	 fn x_3035: Word64.word * 'a_2311 * 'a_2310 -> 'a_2310 => 
	 let
	    val x_3036: 'a_2310 -> 'a_2311 ArraySlice.slice -> 'a_2310 = 
	       fn x_3037: 'a_2310 => 
	       let
		  val x_3038: 'a_2311 ArraySlice.slice -> 'a_2310 = 
		     fn x_3039: 'a_2311 ArraySlice.slice => 
		     let
			val x_3040: 'a_2310 = 
			   case x_3039 of
			   T['a_2311] x_3041: Word64.word
					      * 'a_2311 array
					      * Word64.word => 
			      let
				 val x_3042: Word64.word = 
				    #2 x_3041
				 val x_3043: 'a_2311 array = 
				    #1 x_3041
				 val x_3044: Word64.word = 
				    #0 x_3041
				 val x_3045: Word64.word = 
				    0x1
				 val x_3046: Word64.word * Word64.word = 
				    (x_3044, x_3045)
				 val len: Word64.word = 
				    -? x_3046
				 val x_3047: Word64.word * Word64.word = 
				    (x_3042, len)
				 val max: Word64.word = 
				    +? x_3047
				 val rec 
				    loop: Word64.word * 'a_2310 -> 'a_2310 = 
				       fn x_3048: Word64.word * 'a_2310 => 
				       let
					  val b: 'a_2310 = 
					     #1 x_3048
					  val i: Word64.word = 
					     #0 x_3048
					  val x_3049: Word64.word * Word64.word = 
					     (i, x_3042)
					  val x_3050: bool = 
					     < x_3049
					  val x_3051: 'a_2310 = 
					     case x_3050 of
					     true => 
						let
						in
						   b
						end
					     false => 
						let
						   val x_3052: Word64.word = 
						      0x1
						   val x_3053: Word64.word
							       * Word64.word = 
						      (i, x_3052)
						   val x_3054: Word64.word = 
						      -? x_3053
						   val x_3055: Word64.word
							       * Word64.word = 
						      (i, x_3042)
						   val x_3056: Word64.word = 
						      -? x_3055
						   val x_3057: 'a_2311 array
							       * Word64.word = 
						      (x_3043, i)
						   val x_3058: 'a_2311 = 
						      subUnsafe_1 ('a_2311) x_3057
						   val x_3059: Word64.word
							       * 'a_2311
							       * 'a_2310 = 
						      (x_3056, x_3058, b)
						   val x_3060: 'a_2310 = 
						      x_3035 x_3059
						   val x_3061: Word64.word
							       * 'a_2310 = 
						      (x_3054, x_3060)
						   val x_3062: 'a_2310 = 
						      loop x_3061
						in
						   x_3062
						end
				       in
					  x_3051
				       end
				 val x_3063: Word64.word * 'a_2310 = 
				    (max, x_3037)
				 val x_3064: 'a_2310 = 
				    loop x_3063
			      in
				 x_3064
			      end
		     in
			x_3040
		     end
	       in
		  x_3038
	       end
	 in
	    x_3036
	 end
   val rec ('a_2313, 'a_2312) 
      foldri: (word * 'a_2313 * 'a_2312 -> 'a_2312)
	      -> 'a_2312 -> 'a_2313 ArraySlice.slice -> 'a_2312 = 
	 fn x_3065: word * 'a_2313 * 'a_2312 -> 'a_2312 => 
	 let
	    val x_3066: 'a_2312 -> 'a_2313 ArraySlice.slice -> 'a_2312 = 
	       fn x_3067: 'a_2312 => 
	       let
		  val x_3068: 'a_2313 ArraySlice.slice -> 'a_2312 = 
		     fn x_3069: 'a_2313 ArraySlice.slice => 
		     let
			val x_3070: Word64.word * 'a_2313 * 'a_2312 -> 'a_2312 = 
			   wrap3 ('a_2313, 'a_2312, 'a_2312) x_3065
			val x_3071: 'a_2312
				    -> 'a_2313 ArraySlice.slice -> 'a_2312 = 
			   foldri' ('a_2313, 'a_2312) x_3070
			val x_3072: 'a_2313 ArraySlice.slice -> 'a_2312 = 
			   x_3071 x_3067
			val x_3073: 'a_2312 = 
			   x_3072 x_3069
		     in
			x_3073
		     end
	       in
		  x_3068
	       end
	 in
	    x_3066
	 end
   val rec ('a_2330, 'a_2329, 'a_2328) 
      createi': (Word64.word * (Word64.word -> 'a_2329) -> 'a_2328)
		-> (Word64.word * 'a_2330 -> 'a_2329)
		   -> 'a_2330 ArraySlice.slice -> 'a_2328 = 
	 fn x_3074: Word64.word * (Word64.word -> 'a_2329) -> 'a_2328 => 
	 let
	    val x_3075: (Word64.word * 'a_2330 -> 'a_2329)
			-> 'a_2330 ArraySlice.slice -> 'a_2328 = 
	       fn x_3076: Word64.word * 'a_2330 -> 'a_2329 => 
	       let
		  val x_3077: 'a_2330 ArraySlice.slice -> 'a_2328 = 
		     fn x_3078: 'a_2330 ArraySlice.slice => 
		     let
			val x_3079: 'a_2328 = 
			   case x_3078 of
			   T['a_2330] x_3080: Word64.word
					      * 'a_2330 array
					      * Word64.word => 
			      let
				 val x_3081: Word64.word = 
				    #2 x_3080
				 val x_3082: 'a_2330 array = 
				    #1 x_3080
				 val x_3083: Word64.word = 
				    #0 x_3080
				 val x_3084: Word64.word -> 'a_2329 = 
				    fn x_3085: Word64.word => 
				    let
				       val x_3086: Word64.word * Word64.word = 
					  (x_3081, x_3085)
				       val x_3087: Word64.word = 
					  +? x_3086
				       val x_3088: 'a_2330 array * Word64.word = 
					  (x_3082, x_3087)
				       val x_3089: 'a_2330 = 
					  subUnsafe_1 ('a_2330) x_3088
				       val x_3090: Word64.word * 'a_2330 = 
					  (x_3085, x_3089)
				       val x_3091: 'a_2329 = 
					  x_3076 x_3090
				    in
				       x_3091
				    end
				 val x_3092: Word64.word
					     * (Word64.word -> 'a_2329) = 
				    (x_3083, x_3084)
				 val x_3093: 'a_2328 = 
				    x_3074 x_3092
			      in
				 x_3093
			      end
		     in
			x_3079
		     end
	       in
		  x_3077
	       end
	 in
	    x_3075
	 end
   val rec ('a_2333, 'a_2332, 'a_2331) 
      createi: (Word64.word * (Word64.word -> 'a_2331) -> 'a_2333)
	       -> (word * 'a_2332 -> 'a_2331)
		  -> 'a_2332 ArraySlice.slice -> 'a_2333 = 
	 fn x_3094: Word64.word * (Word64.word -> 'a_2331) -> 'a_2333 => 
	 let
	    val x_3095: (word * 'a_2332 -> 'a_2331)
			-> 'a_2332 ArraySlice.slice -> 'a_2333 = 
	       fn x_3096: word * 'a_2332 -> 'a_2331 => 
	       let
		  val x_3097: 'a_2332 ArraySlice.slice -> 'a_2333 = 
		     fn x_3098: 'a_2332 ArraySlice.slice => 
		     let
			val x_3099: (Word64.word * 'a_2332 -> 'a_2331)
				    -> 'a_2332 ArraySlice.slice -> 'a_2333 = 
			   createi' ('a_2332, 'a_2331, 'a_2333) x_3094
			val x_3100: Word64.word * 'a_2332 -> 'a_2331 = 
			   wrap2 ('a_2332, 'a_2331) x_3096
			val x_3101: 'a_2332 ArraySlice.slice -> 'a_2333 = 
			   x_3099 x_3100
			val x_3102: 'a_2333 = 
			   x_3101 x_3098
		     in
			x_3102
		     end
	       in
		  x_3097
	       end
	 in
	    x_3095
	 end
   val rec ('a_2336, 'a_2335, 'a_2334) 
      create: (Word64.word * (Word64.word -> 'a_2335) -> 'a_2336)
	      -> ('a_2334 -> 'a_2335) -> 'a_2334 ArraySlice.slice -> 'a_2336 = 
	 fn x_3103: Word64.word * (Word64.word -> 'a_2335) -> 'a_2336 => 
	 let
	    val x_3104: ('a_2334 -> 'a_2335)
			-> 'a_2334 ArraySlice.slice -> 'a_2336 = 
	       fn x_3105: 'a_2334 -> 'a_2335 => 
	       let
		  val x_3106: 'a_2334 ArraySlice.slice -> 'a_2336 = 
		     fn x_3107: 'a_2334 ArraySlice.slice => 
		     let
			val x_3108: (word * 'a_2334 -> 'a_2335)
				    -> 'a_2334 ArraySlice.slice -> 'a_2336 = 
			   createi ('a_2336, 'a_2334, 'a_2335) x_3103
			val x_3109: word * 'a_2334 -> 'a_2334 = 
			   fn x_3110: word * 'a_2334 => 
			   let
			      val x_3111: 'a_2334 = 
				 #1 x_3110
			   in
			      x_3111
			   end
			val x_3112: ('a_2334 -> 'a_2335)
				    * (word * 'a_2334 -> 'a_2334) = 
			   (x_3105, x_3109)
			val x_3113: word * 'a_2334 -> 'a_2335 = 
			   o_1 (word * 'a_2334, 'a_2335, 'a_2334) x_3112
			val x_3114: 'a_2334 ArraySlice.slice -> 'a_2336 = 
			   x_3108 x_3113
			val x_3115: 'a_2336 = 
			   x_3114 x_3107
		     in
			x_3115
		     end
	       in
		  x_3106
	       end
	 in
	    x_3104
	 end
   val rec ('a_2372, 'a_2371) 
      make: ('a_2372 ArraySlice.slice -> 'a_2371) -> 'a_2372 array -> 'a_2371 = 
	 fn x_3116: 'a_2372 ArraySlice.slice -> 'a_2371 => 
	 let
	    val x_3117: 'a_2372 array -> 'a_2371 = 
	       fn x_3118: 'a_2372 array => 
	       let
		  val x_3119: 'a_2372 ArraySlice.slice = 
		     full ('a_2372) x_3118
		  val x_3120: 'a_2371 = 
		     x_3116 x_3119
	       in
		  x_3120
	       end
	 in
	    x_3117
	 end
   val rec 'a_2376 
      sub: 'a_2376 array * word -> 'a_2376 = 
	 fn x_3121: 'a_2376 array * word => 
	 let
	    val i: word = 
	       #1 x_3121
	    val seq: 'a_2376 array = 
	       #0 x_3121
	    val x_3122: 'a_2376 ArraySlice.slice = 
	       full ('a_2376) seq
	    val x_3123: 'a_2376 ArraySlice.slice * word = 
	       (x_3122, i)
	    val x_3124: 'a_2376 = 
	       sub ('a_2376) x_3123
	 in
	    x_3124
	 end
   val rec ('a_2382, 'a_2381, 'a_2380) 
      updateMk: ('a_2380 array * Word64.word * 'a_2382 -> 'a_2381)
		-> 'a_2380 array * word * 'a_2382 -> 'a_2381 = 
	 fn x_3125: 'a_2380 array * Word64.word * 'a_2382 -> 'a_2381 => 
	 let
	    val x_3126: 'a_2380 array * word * 'a_2382 -> 'a_2381 = 
	       fn x_3127: 'a_2380 array * word * 'a_2382 => 
	       let
		  val x_3128: 'a_2382 = 
		     #2 x_3127
		  val x_3129: word = 
		     #1 x_3127
		  val x_3130: 'a_2380 array = 
		     #0 x_3127
		  val x_3131: 'a_2380 ArraySlice.slice * word * 'a_2382
			      -> 'a_2381 = 
		     updateMk ('a_2380, 'a_2382, 'a_2381) x_3125
		  val x_3132: 'a_2380 ArraySlice.slice = 
		     full ('a_2380) x_3130
		  val x_3133: 'a_2380 ArraySlice.slice * word * 'a_2382 = 
		     (x_3132, x_3129, x_3128)
		  val x_3134: 'a_2381 = 
		     x_3131 x_3133
	       in
		  x_3134
	       end
	 in
	    x_3126
	 end
   val rec ('a_2412, 'a_2411) 
      foldri: (word * 'a_2412 * 'a_2411 -> 'a_2411)
	      -> 'a_2411 -> 'a_2412 array -> 'a_2411 = 
	 fn x_3135: word * 'a_2412 * 'a_2411 -> 'a_2411 => 
	 let
	    val x_3136: 'a_2411 -> 'a_2412 array -> 'a_2411 = 
	       fn x_3137: 'a_2411 => 
	       let
		  val x_3138: 'a_2411 -> 'a_2412 ArraySlice.slice -> 'a_2411 = 
		     foldri ('a_2412, 'a_2411) x_3135
		  val x_3139: 'a_2412 ArraySlice.slice -> 'a_2411 = 
		     x_3138 x_3137
		  val x_3140: 'a_2412 array -> 'a_2411 = 
		     make ('a_2412, 'a_2411) x_3139
	       in
		  x_3140
	       end
	 in
	    x_3136
	 end
   val 'a updateMk_0: ('a array * Word64.word * 'a -> unit)
		      -> 'a array * word * 'a -> unit = 
      let
      in
	 updateMk ('a, unit, 'a)
      end
   val ('a, 'b) unfoldi_0: word * 'b * (word * 'b -> 'a * 'b) -> 'a array * 'b = 
      let
      in
	 unfoldi ('a, 'b)
      end
   val 'a tabulate_2: word * (word -> 'a) -> 'a array = 
      let
      in
	 tabulate ('a)
      end
   val 'a sub_2: 'a array * word -> 'a = 
      let
      in
	 sub ('a)
      end
   val 'a newUninit_0: word -> 'a array = 
      let
      in
	 newUninit ('a)
      end
   val 'a new_1: word * 'a -> 'a array = 
      let
      in
	 new ('a)
      end
   val 'a length_5: 'a array -> word = 
      let
      in
	 length ('a)
      end
   val ('b, 'a) foldri_0: (word * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b = 
      let
      in
	 foldri ('a, 'b)
      end
   val 'a slice_2: 'a array * word * word option -> 'a ArraySlice.slice = 
      let
      in
	 slice ('a)
      end
   val ('a, 'c, 'b) create_0: (Word64.word * (Word64.word -> 'b) -> 'c)
			      -> ('a -> 'b) -> 'a ArraySlice.slice -> 'c = 
      let
      in
	 create ('c, 'b, 'a)
      end
   val rec 'a_2462 
      vector: 'a_2462 ArraySlice.slice -> 'a_2462 vector = 
	 fn x_3141: 'a_2462 ArraySlice.slice => 
	 let
	    val x_3142: ('a_2462 -> 'a_2462)
			-> 'a_2462 ArraySlice.slice -> 'a_2462 vector = 
	       create_0 ('a_2462, 'a_2462 vector, 'a_2462) tabulate'_1 ('a_2462)
	    val x_3143: 'a_2462 -> 'a_2462 = 
	       fn x_3144: 'a_2462 => 
	       let
	       in
		  x_3144
	       end
	    val x_3145: 'a_2462 ArraySlice.slice -> 'a_2462 vector = 
	       x_3142 x_3143
	    val x_3146: 'a_2462 vector = 
	       x_3145 x_3141
	 in
	    x_3146
	 end
   val 'a_2478 arrayUninit: word -> 'a_2478 array = 
      let
      in
	 newUninit_0 ('a_2478)
      end
   val 'a_2480 array: word * 'a_2480 -> 'a_2480 array = 
      let
      in
	 new_1 ('a_2480)
      end
   val rec 'a_2481 
      update: 'a_2481 array * word * 'a_2481 -> unit = 
	 fn x_3147: 'a_2481 array * word * 'a_2481 => 
	 let
	    val x: 'a_2481 = 
	       #2 x_3147
	    val i: word = 
	       #1 x_3147
	    val arr: 'a_2481 array = 
	       #0 x_3147
	    val x_3148: 'a_2481 array * word * 'a_2481 -> unit = 
	       updateMk_0 ('a_2481) updateUnsafe ('a_2481)
	    val x_3149: 'a_2481 array * word * 'a_2481 = 
	       (arr, i, x)
	    val x_3150: unit = 
	       x_3148 x_3149
	 in
	    x_3150
	 end
   val 'a update_0: 'a array * word * 'a -> unit = 
      let
      in
	 update ('a)
      end
   val ('a, 'b) unfoldi_1: word * 'b * (word * 'b -> 'a * 'b) -> 'a array * 'b = 
      let
      in
	 unfoldi_0 ('a, 'b)
      end
   val 'a tabulate_3: word * (word -> 'a) -> 'a array = 
      let
      in
	 tabulate_2 ('a)
      end
   val 'a sub_3: 'a array * word -> 'a = 
      let
      in
	 sub_2 ('a)
      end
   val 'a length_6: 'a array -> word = 
      let
      in
	 length_5 ('a)
      end
   val ('b, 'a) foldri_1: (word * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b = 
      let
      in
	 foldri_0 ('b, 'a)
      end
   val 'a arrayUninit_0: word -> 'a array = 
      let
      in
	 arrayUninit ('a)
      end
   val 'a array_0: word * 'a -> 'a array = 
      let
      in
	 array ('a)
      end
   val 'a vector_2: 'a ArraySlice.slice -> 'a vector = 
      let
      in
	 vector ('a)
      end
   val 'a slice_3: 'a array * word * word option -> 'a ArraySlice.slice = 
      let
      in
	 slice_2 ('a)
      end
   val 'a_2613 fromPoly: 'a_2613 -> 'a_2613 = 
      let
	 val x_3151: 'a_2613 -> 'a_2613 = 
	    fn x_3152: 'a_2613 => 
	    let
	    in
	       x_3152
	    end
      in
	 x_3151
      end
   val x_3153: (Word8.word -> Word8.word) * (word -> Word8.word) = 
      (idFromWord8, sextdFromInt32ToWord8)
   val x_3154: word -> Word8.word = 
      o_1 (word, Word8.word, Word8.word) x_3153
   val x_3155: (Word8.word -> word) * (Word8.word -> Word8.word) = 
      (zextdFromWord8ToInt32, idToWord8)
   val x_3156: Word8.word -> word = 
      o_1 (Word8.word, word, Word8.word) x_3155
   val x_3157: word = 
      0x100
   val x_3158: (Word16.word -> Word16.word) * (word -> Word16.word) = 
      (idFromWord16, sextdFromInt32ToWord16)
   val x_3159: word -> Word16.word = 
      o_1 (word, Word16.word, Word16.word) x_3158
   val x_3160: (Word16.word -> word) * (Word16.word -> Word16.word) = 
      (zextdFromWord16ToInt32, idToWord16)
   val x_3161: Word16.word -> word = 
      o_1 (Word16.word, word, Word16.word) x_3160
   val x_3162: (word -> word) * (word -> word) = 
      (idFromWord32, sextdFromInt32ToWord32)
   val x_3163: word -> word = 
      o_1 (word, word, word) x_3162
   val x_3164: (word -> word) * (word -> word) = 
      (zextdFromWord32ToInt32, idToWord32)
   val x_3165: word -> word = 
      o_1 (word, word, word) x_3164
   val rec ('b, 'a) 
      readerN: ('b -> ('a * 'b) option) * word -> 'b -> ('a list * 'b) option = 
	 fn x_3166: ('b -> ('a * 'b) option) * word => 
	 let
	    val n: word = 
	       #1 x_3166
	    val reader: 'b -> ('a * 'b) option = 
	       #0 x_3166
	    val x_3167: 'b -> ('a list * 'b) option = 
	       fn x_3168: 'b => 
	       let
		  val rec 
		     loop: word * 'b * 'a list -> ('a list * 'b) option = 
			fn x_3169: word * 'b * 'a list => 
			let
			   val accum: 'a list = 
			      #2 x_3169
			   val state: 'b = 
			      #1 x_3169
			   val n: word = 
			      #0 x_3169
			   val x_3170: word = 
			      0x0
			   val x_3171: word * word = 
			      (n, x_3170)
			   val x_3172: bool = 
			      <= x_3171
			   val x_3173: ('a list * 'b) option = 
			      case x_3172 of
			      true => 
				 let
				    val x_3187: 'a list = 
				       rev_1 ('a) accum
				    val x_3188: 'a list * 'b = 
				       (x_3187, state)
				    val x_3189: ('a list * 'b) option = 
				       SOME['a list * 'b] x_3188
				 in
				    x_3189
				 end
			      false => 
				 let
				    val x_3174: ('a * 'b) option = 
				       reader state
				    val x_3175: ('a list * 'b) option = 
				       case x_3174 of
				       NONE['a * 'b] => 
					  let
					     val x_3186: ('a list * 'b) option = 
						NONE['a list * 'b]
					  in
					     x_3186
					  end
				       SOME['a * 'b] x_3176: 'a * 'b => 
					  let
					     val x_3177: 'b = 
						#1 x_3176
					     val x_3178: 'a = 
						#0 x_3176
					     val x_3179: word = 
						0x1
					     val x_3180: word * word = 
						(n, x_3179)
					     val x_3181: word = 
						-! x_3180
					     val x_3182: 'a * 'a list = 
						(x_3178, accum)
					     val x_3183: 'a list = 
						::['a] x_3182
					     val x_3184: word * 'b * 'a list = 
						(x_3181, x_3177, x_3183)
					     val x_3185: ('a list * 'b) option = 
						loop x_3184
					  in
					     x_3185
					  end
				 in
				    x_3175
				 end
			in
			   x_3173
			end
		  val x_3190: 'a list = 
		     nil['a]
		  val x_3191: word * 'b * 'a list = 
		     (n, x_3168, x_3190)
		  val x_3192: ('a list * 'b) option = 
		     loop x_3191
	       in
		  x_3192
	       end
	 in
	    x_3167
	 end
   val rec ('a_2663, 'a_2662) 
      ignore: ('a_2663 -> bool)
	      -> ('a_2662 -> ('a_2663 * 'a_2662) option)
		 -> 'a_2662 -> ('a_2663 * 'a_2662) option = 
	 fn x_3193: 'a_2663 -> bool => 
	 let
	    val x_3194: ('a_2662 -> ('a_2663 * 'a_2662) option)
			-> 'a_2662 -> ('a_2663 * 'a_2662) option = 
	       fn x_3195: 'a_2662 -> ('a_2663 * 'a_2662) option => 
	       let
		  val rec 
		     loop: 'a_2662 -> ('a_2663 * 'a_2662) option = 
			fn x_3196: 'a_2662 => 
			let
			   val x_3197: ('a_2663 * 'a_2662) option = 
			      x_3195 x_3196
			   val x_3198: ('a_2663 * 'a_2662) option = 
			      case x_3197 of
			      NONE['a_2663 * 'a_2662] => 
				 let
				    val x_3207: ('a_2663 * 'a_2662) option = 
				       NONE['a_2663 * 'a_2662]
				 in
				    x_3207
				 end
			      SOME['a_2663 * 'a_2662] x_3199: 'a_2663 * 'a_2662 => 
				 let
				    val x_3200: 'a_2662 = 
				       #1 x_3199
				    val x_3201: 'a_2663 = 
				       #0 x_3199
				    val x_3202: bool = 
				       x_3193 x_3201
				    val x_3203: ('a_2663 * 'a_2662) option = 
				       case x_3202 of
				       true => 
					  let
					     val x_3206: ('a_2663 * 'a_2662) option = 
						loop x_3200
					  in
					     x_3206
					  end
				       false => 
					  let
					     val x_3204: 'a_2663 * 'a_2662 = 
						(x_3201, x_3200)
					     val x_3205: ('a_2663 * 'a_2662) option = 
						SOME['a_2663 * 'a_2662] x_3204
					  in
					     x_3205
					  end
				 in
				    x_3203
				 end
			in
			   x_3198
			end
	       in
		  loop
	       end
	 in
	    x_3194
	 end
   val ('a_2665, 'a_2664) x_3208: ('a_2665 -> bool)
				  -> ('a_2664 -> ('a_2665 * 'a_2664) option)
				     -> 'a_2664 -> ('a_2665 * 'a_2664) option = 
      let
      in
	 ignore ('a_2665, 'a_2664)
      end
   val rec ('b, 'c, 'a) 
      map: ('a -> 'c) -> ('b -> ('a * 'b) option) -> 'b -> ('c * 'b) option = 
	 fn x_3209: 'a -> 'c => 
	 let
	    val x_3210: ('b -> ('a * 'b) option) -> 'b -> ('c * 'b) option = 
	       fn x_3211: 'b -> ('a * 'b) option => 
	       let
		  val x_3212: 'b -> ('c * 'b) option = 
		     fn x_3213: 'b => 
		     let
			val x_3214: ('a * 'b) option = 
			   x_3211 x_3213
			val x_3215: ('c * 'b) option = 
			   case x_3214 of
			   NONE['a * 'b] => 
			      let
				 val x_3222: ('c * 'b) option = 
				    NONE['c * 'b]
			      in
				 x_3222
			      end
			   SOME['a * 'b] x_3216: 'a * 'b => 
			      let
				 val x_3217: 'b = 
				    #1 x_3216
				 val x_3218: 'a = 
				    #0 x_3216
				 val x_3219: 'c = 
				    x_3209 x_3218
				 val x_3220: 'c * 'b = 
				    (x_3219, x_3217)
				 val x_3221: ('c * 'b) option = 
				    SOME['c * 'b] x_3220
			      in
				 x_3221
			      end
		     in
			x_3215
		     end
	       in
		  x_3212
	       end
	 in
	    x_3210
	 end
   val rec ('a_2667, 'a_2666) 
      reader2: ('a_2667 -> ('a_2666 * 'a_2667) option)
	       -> 'a_2667 -> (('a_2666 * 'a_2666) * 'a_2667) option = 
	 fn x_3223: 'a_2667 -> ('a_2666 * 'a_2667) option => 
	 let
	    val x_3224: 'a_2666 list -> 'a_2666 * 'a_2666 = 
	       fn x_3225: 'a_2666 list => 
	       let
		  val x_3226: unit -> 'a_2666 * 'a_2666 = 
		     fn x_3227: unit => 
		     let
			val x_3228: Word8.word vector = 
			   "Reader.reader2"
			val x_3229: exn = 
			   Fail x_3228
			val x_3230: 'a_2666 * 'a_2666 = 
			   raise x_3229
		     in
			x_3230
		     end
		  val x_3231: 'a_2666 * 'a_2666 = 
		     case x_3225 of
		     ::['a_2666] x_3232: 'a_2666 * 'a_2666 list => 
			let
			   val x_3233: 'a_2666 list = 
			      #1 x_3232
			   val x_3234: 'a_2666 = 
			      #0 x_3232
			   val x_3235: 'a_2666 * 'a_2666 = 
			      case x_3233 of
			      ::['a_2666] x_3236: 'a_2666 * 'a_2666 list => 
				 let
				    val x_3237: 'a_2666 list = 
				       #1 x_3236
				    val x_3238: 'a_2666 = 
				       #0 x_3236
				    val x_3239: 'a_2666 * 'a_2666 = 
				       case x_3237 of
				       nil['a_2666] => 
					  let
					     val x_3240: 'a_2666 * 'a_2666 = 
						(x_3234, x_3238)
					  in
					     x_3240
					  end
					 _ => let
						 val x_3241: unit = 
						    ()
						 val x_3242: 'a_2666 * 'a_2666 = 
						    x_3226 x_3241
					      in
						 x_3242
					      end
				 in
				    x_3239
				 end
				_ => let
					val x_3243: unit = 
					   ()
					val x_3244: 'a_2666 * 'a_2666 = 
					   x_3226 x_3243
				     in
					x_3244
				     end
			in
			   x_3235
			end
		       _ => let
			       val x_3245: unit = 
				  ()
			       val x_3246: 'a_2666 * 'a_2666 = 
				  x_3226 x_3245
			    in
			       x_3246
			    end
	       in
		  x_3231
	       end
	    val x_3247: ('a_2667 -> ('a_2666 list * 'a_2667) option)
			-> 'a_2667 -> (('a_2666 * 'a_2666) * 'a_2667) option = 
	       map ('a_2667, 'a_2666 * 'a_2666, 'a_2666 list) x_3224
	    val x_3248: word = 
	       0x2
	    val x_3249: ('a_2667 -> ('a_2666 * 'a_2667) option) * word = 
	       (x_3223, x_3248)
	    val x_3250: 'a_2667 -> ('a_2666 list * 'a_2667) option = 
	       readerN ('a_2667, 'a_2666) x_3249
	    val x_3251: 'a_2667 -> (('a_2666 * 'a_2666) * 'a_2667) option = 
	       x_3247 x_3250
	 in
	    x_3251
	 end
   val ('a_2669, 'a_2668) x_3252: ('a_2669 -> ('a_2668 * 'a_2669) option)
				  -> 'a_2669
				     -> (('a_2668 * 'a_2668) * 'a_2669) option = 
      let
      in
	 reader2 ('a_2669, 'a_2668)
      end
   val radixToInt: StringCvt.radix -> word = 
      fn x_3253: StringCvt.radix => 
      let
	 val x_3254: word = 
	    case x_3253 of
	    BIN => 
	       let
		  val x_3258: word = 
		     0x2
	       in
		  x_3258
	       end
	    DEC => 
	       let
		  val x_3257: word = 
		     0xA
	       in
		  x_3257
	       end
	    HEX => 
	       let
		  val x_3256: word = 
		     0x10
	       in
		  x_3256
	       end
	    OCT => 
	       let
		  val x_3255: word = 
		     0x8
	       in
		  x_3255
	       end
      in
	 x_3254
      end
   val rec 'a_2676 
      splitl: (Word8.word -> bool)
	      -> ('a_2676 -> (Word8.word * 'a_2676) option)
		 -> 'a_2676 -> Word8.word vector * 'a_2676 = 
	 fn x_3259: Word8.word -> bool => 
	 let
	    val x_3260: ('a_2676 -> (Word8.word * 'a_2676) option)
			-> 'a_2676 -> Word8.word vector * 'a_2676 = 
	       fn x_3261: 'a_2676 -> (Word8.word * 'a_2676) option => 
	       let
		  val x_3262: 'a_2676 -> Word8.word vector * 'a_2676 = 
		     fn x_3263: 'a_2676 => 
		     let
			val rec 
			   done: Word8.word list -> Word8.word vector = 
			      fn x_3264: Word8.word list => 
			      let
				 val x_3265: Word8.word list = 
				    rev_1 (Word8.word) x_3264
				 val x_3266: Word8.word vector = 
				    fromList_1 (Word8.word) x_3265
			      in
				 x_3266
			      end
			val rec 
			   loop: 'a_2676 * Word8.word list
				 -> Word8.word vector * 'a_2676 = 
			      fn x_3267: 'a_2676 * Word8.word list => 
			      let
				 val chars: Word8.word list = 
				    #1 x_3267
				 val src: 'a_2676 = 
				    #0 x_3267
				 val x_3268: (Word8.word * 'a_2676) option = 
				    x_3261 src
				 val x_3269: Word8.word vector * 'a_2676 = 
				    case x_3268 of
				    NONE[Word8.word * 'a_2676] => 
				       let
					  val x_3281: Word8.word vector = 
					     done chars
					  val x_3282: Word8.word vector
						      * 'a_2676 = 
					     (x_3281, src)
				       in
					  x_3282
				       end
				    SOME[Word8.word * 'a_2676] x_3270: Word8.word
								       * 'a_2676 => 
				       let
					  val x_3271: 'a_2676 = 
					     #1 x_3270
					  val x_3272: Word8.word = 
					     #0 x_3270
					  val x_3273: bool = 
					     x_3259 x_3272
					  val x_3274: Word8.word vector
						      * 'a_2676 = 
					     case x_3273 of
					     true => 
						let
						   val x_3277: Word8.word
							       * Word8.word list = 
						      (x_3272, chars)
						   val x_3278: Word8.word list = 
						      ::[Word8.word] x_3277
						   val x_3279: 'a_2676
							       * Word8.word list = 
						      (x_3271, x_3278)
						   val x_3280: Word8.word vector
							       * 'a_2676 = 
						      loop x_3279
						in
						   x_3280
						end
					     false => 
						let
						   val x_3275: Word8.word vector = 
						      done chars
						   val x_3276: Word8.word vector
							       * 'a_2676 = 
						      (x_3275, src)
						in
						   x_3276
						end
				       in
					  x_3274
				       end
			      in
				 x_3269
			      end
			val x_3283: Word8.word list = 
			   nil[Word8.word]
			val x_3284: 'a_2676 * Word8.word list = 
			   (x_3263, x_3283)
			val x_3285: Word8.word vector * 'a_2676 = 
			   loop x_3284
		     in
			x_3285
		     end
	       in
		  x_3262
	       end
	 in
	    x_3260
	 end
   val rec 'a_2678 
      dropl: (Word8.word -> bool)
	     -> ('a_2678 -> (Word8.word * 'a_2678) option) -> 'a_2678 -> 'a_2678 = 
	 fn x_3286: Word8.word -> bool => 
	 let
	    val x_3287: ('a_2678 -> (Word8.word * 'a_2678) option)
			-> 'a_2678 -> 'a_2678 = 
	       fn x_3288: 'a_2678 -> (Word8.word * 'a_2678) option => 
	       let
		  val x_3289: 'a_2678 -> 'a_2678 = 
		     fn x_3290: 'a_2678 => 
		     let
			val x_3291: ('a_2678 -> (Word8.word * 'a_2678) option)
				    -> 'a_2678 -> Word8.word vector * 'a_2678 = 
			   splitl ('a_2678) x_3286
			val x_3292: 'a_2678 -> Word8.word vector * 'a_2678 = 
			   x_3291 x_3288
			val x_3293: Word8.word vector * 'a_2678 = 
			   x_3292 x_3290
			val x_3294: 'a_2678 = 
			   #1 x_3293
		     in
			x_3294
		     end
	       in
		  x_3289
	       end
	 in
	    x_3287
	 end
   val rec 'a 
      scanString: ((word -> (Word8.word * word) option)
		   -> word -> ('a * word) option)
		  -> Word8.word vector -> 'a option = 
	 fn x_3295: (word -> (Word8.word * word) option)
		    -> word -> ('a * word) option => 
	 let
	    val x_3296: Word8.word vector -> 'a option = 
	       fn x_3297: Word8.word vector => 
	       let
		  val x_3298: word -> (Word8.word * word) option = 
		     fn x_3299: word => 
		     let
			val x_3300: word = 
			   length_3 (Word8.word) x_3297
			val x_3301: word * word = 
			   (x_3299, x_3300)
			val x_3302: bool = 
			   >= x_3301
			val x_3303: (Word8.word * word) option = 
			   case x_3302 of
			   true => 
			      let
				 val x_3311: (Word8.word * word) option = 
				    NONE[Word8.word * word]
			      in
				 x_3311
			      end
			   false => 
			      let
				 val x_3304: Word8.word vector * word = 
				    (x_3297, x_3299)
				 val x_3305: Word8.word = 
				    sub_1 (Word8.word) x_3304
				 val x_3306: word = 
				    0x1
				 val x_3307: word * word = 
				    (x_3299, x_3306)
				 val x_3308: word = 
				    +! x_3307
				 val x_3309: Word8.word * word = 
				    (x_3305, x_3308)
				 val x_3310: (Word8.word * word) option = 
				    SOME[Word8.word * word] x_3309
			      in
				 x_3310
			      end
		     in
			x_3303
		     end
		  val x_3312: word -> ('a * word) option = 
		     x_3295 x_3298
		  val x_3313: word = 
		     0x0
		  val x_3314: ('a * word) option = 
		     x_3312 x_3313
		  val x_3315: 'a option = 
		     case x_3314 of
		     NONE['a * word] => 
			let
			   val x_3319: 'a option = 
			      NONE['a]
			in
			   x_3319
			end
		     SOME['a * word] x_3316: 'a * word => 
			let
			   val x_3317: 'a = 
			      #0 x_3316
			   val x_3318: 'a option = 
			      SOME['a] x_3317
			in
			   x_3318
			end
	       in
		  x_3315
	       end
	 in
	    x_3296
	 end
   val rec 'a 
      memoize: (Word8.word -> 'a) -> Word8.word -> 'a = 
	 fn x_3320: Word8.word -> 'a => 
	 let
	    val x_3321: (Word8.word -> 'a) * (word -> Word8.word) = 
	       (x_3320, x_3154)
	    val x_3322: word -> 'a = 
	       o_1 (word, 'a, Word8.word) x_3321
	    val x_3323: word * (word -> 'a) = 
	       (x_3157, x_3322)
	    val a: 'a array = 
	       tabulate_3 ('a) x_3323
	    val x_3324: Word8.word -> 'a = 
	       fn x_3325: Word8.word => 
	       let
		  val x_3326: word = 
		     x_3156 x_3325
		  val x_3327: 'a array * word = 
		     (a, x_3326)
		  val x_3328: 'a = 
		     sub_3 ('a) x_3327
	       in
		  x_3328
	       end
	 in
	    x_3324
	 end
   val rec 
      range: word * Word8.word * Word8.word -> Word8.word -> word option = 
	 fn x_3329: word * Word8.word * Word8.word => 
	 let
	    val cmax: Word8.word = 
	       #2 x_3329
	    val cmin: Word8.word = 
	       #1 x_3329
	    val add: word = 
	       #0 x_3329
	    val min: word = 
	       x_3156 cmin
	    val x_3330: Word8.word -> word option = 
	       fn x_3331: Word8.word => 
	       let
		  val x_3332: Word8.word * Word8.word = 
		     (cmin, x_3331)
		  val x_3333: bool = 
		     <= x_3332
		  val x_3334: bool = 
		     case x_3333 of
		     true => 
			let
			   val x_3336: Word8.word * Word8.word = 
			      (x_3331, cmax)
			   val x_3337: bool = 
			      <= x_3336
			in
			   x_3337
			end
		     false => 
			let
			   val x_3335: bool = 
			      false
			in
			   x_3335
			end
		  val x_3338: word option = 
		     case x_3334 of
		     true => 
			let
			   val x_3340: word = 
			      x_3156 x_3331
			   val x_3341: word * word = 
			      (add, x_3340)
			   val x_3342: word = 
			      +? x_3341
			   val x_3343: word * word = 
			      (x_3342, min)
			   val x_3344: word = 
			      -? x_3343
			   val x_3345: word option = 
			      SOME[word] x_3344
			in
			   x_3345
			end
		     false => 
			let
			   val x_3339: word option = 
			      NONE[word]
			in
			   x_3339
			end
	       in
		  x_3338
	       end
	 in
	    x_3330
	 end
   val rec 'a 
      combine: (Word8.word -> 'a option) list -> Word8.word -> 'a option = 
	 fn x_3346: (Word8.word -> 'a option) list => 
	 let
	    val x_3347: Word8.word -> 'a option = 
	       fn x_3348: Word8.word => 
	       let
		  val rec 'a_2679 
		     loop: (Word8.word -> 'a_2679 option) list -> 'a_2679 option = 
			fn x_3349: (Word8.word -> 'a_2679 option) list => 
			let
			   val x_3350: 'a_2679 option = 
			      case x_3349 of
			      nil[Word8.word -> 'a_2679 option] => 
				 let
				    val x_3357: 'a_2679 option = 
				       NONE['a_2679]
				 in
				    x_3357
				 end
			      ::[Word8.word -> 'a_2679 option] x_3351: (Word8.word
									-> 'a_2679 option)
								       * (Word8.word
									  -> 'a_2679 option) list => 
				 let
				    val x_3352: (Word8.word -> 'a_2679 option) list = 
				       #1 x_3351
				    val x_3353: Word8.word -> 'a_2679 option = 
				       #0 x_3351
				    val x_3354: 'a_2679 option = 
				       x_3353 x_3348
				    val x_3355: 'a_2679 option = 
				       case x_3354 of
				       NONE['a_2679] => 
					  let
					     val x_3356: 'a_2679 option = 
						loop ('a_2679) x_3352
					  in
					     x_3356
					  end
					 _ => let
					      in
						 x_3354
					      end
				 in
				    x_3355
				 end
			in
			   x_3350
			end
		  val x_3358: 'a option = 
		     loop ('a) x_3346
	       in
		  x_3358
	       end
	    val x_3359: Word8.word -> 'a option = 
	       memoize ('a option) x_3347
	 in
	    x_3359
	 end
   val x_3360: word = 
      0x0
   val x_3361: Word8.word = 
      0x30
   val x_3362: Word8.word = 
      0x31
   val x_3363: word * Word8.word * Word8.word = 
      (x_3360, x_3361, x_3362)
   val x_3364: Word8.word -> word option = 
      range x_3363
   val bin: Word8.word -> word option = 
      memoize (word option) x_3364
   val x_3365: word = 
      0x0
   val x_3366: Word8.word = 
      0x30
   val x_3367: Word8.word = 
      0x37
   val x_3368: word * Word8.word * Word8.word = 
      (x_3365, x_3366, x_3367)
   val x_3369: Word8.word -> word option = 
      range x_3368
   val oct: Word8.word -> word option = 
      memoize (word option) x_3369
   val x_3370: word = 
      0x0
   val x_3371: Word8.word = 
      0x30
   val x_3372: Word8.word = 
      0x39
   val x_3373: word * Word8.word * Word8.word = 
      (x_3370, x_3371, x_3372)
   val x_3374: Word8.word -> word option = 
      range x_3373
   val dec: Word8.word -> word option = 
      memoize (word option) x_3374
   val x_3375: word = 
      0x0
   val x_3376: Word8.word = 
      0x30
   val x_3377: Word8.word = 
      0x39
   val x_3378: word * Word8.word * Word8.word = 
      (x_3375, x_3376, x_3377)
   val x_3379: Word8.word -> word option = 
      range x_3378
   val x_3380: word = 
      0xA
   val x_3381: Word8.word = 
      0x61
   val x_3382: Word8.word = 
      0x66
   val x_3383: word * Word8.word * Word8.word = 
      (x_3380, x_3381, x_3382)
   val x_3384: Word8.word -> word option = 
      range x_3383
   val x_3385: word = 
      0xA
   val x_3386: Word8.word = 
      0x41
   val x_3387: Word8.word = 
      0x46
   val x_3388: word * Word8.word * Word8.word = 
      (x_3385, x_3386, x_3387)
   val x_3389: Word8.word -> word option = 
      range x_3388
   val x_3390: (Word8.word -> word option) list = 
      nil[Word8.word -> word option]
   val x_3391: (Word8.word -> word option) * (Word8.word -> word option) list = 
      (x_3389, x_3390)
   val x_3392: (Word8.word -> word option) list = 
      ::[Word8.word -> word option] x_3391
   val x_3393: (Word8.word -> word option) * (Word8.word -> word option) list = 
      (x_3384, x_3392)
   val x_3394: (Word8.word -> word option) list = 
      ::[Word8.word -> word option] x_3393
   val x_3395: (Word8.word -> word option) * (Word8.word -> word option) list = 
      (x_3379, x_3394)
   val x_3396: (Word8.word -> word option) list = 
      ::[Word8.word -> word option] x_3395
   val hex: Word8.word -> word option = 
      combine (word) x_3396
   val rec 
      isSpace: Word8.word -> bool = 
	 fn x_3397: Word8.word => 
	 let
	    val x_3398: Word8.word = 
	       0x20
	    val x_3399: Word8.word * Word8.word = 
	       (x_3397, x_3398)
	    val x_3400: bool = 
	       = (Word8.word) x_3399
	    val x_3401: bool = 
	       case x_3400 of
	       true => 
		  let
		     val x_3405: bool = 
			true
		  in
		     x_3405
		  end
	       false => 
		  let
		     val x_3402: Word8.word = 
			0x9
		     val x_3403: Word8.word * Word8.word = 
			(x_3397, x_3402)
		     val x_3404: bool = 
			= (Word8.word) x_3403
		  in
		     x_3404
		  end
	    val x_3406: bool = 
	       case x_3401 of
	       true => 
		  let
		     val x_3410: bool = 
			true
		  in
		     x_3410
		  end
	       false => 
		  let
		     val x_3407: Word8.word = 
			0xD
		     val x_3408: Word8.word * Word8.word = 
			(x_3397, x_3407)
		     val x_3409: bool = 
			= (Word8.word) x_3408
		  in
		     x_3409
		  end
	    val x_3411: bool = 
	       case x_3406 of
	       true => 
		  let
		     val x_3415: bool = 
			true
		  in
		     x_3415
		  end
	       false => 
		  let
		     val x_3412: Word8.word = 
			0xA
		     val x_3413: Word8.word * Word8.word = 
			(x_3397, x_3412)
		     val x_3414: bool = 
			= (Word8.word) x_3413
		  in
		     x_3414
		  end
	    val x_3416: bool = 
	       case x_3411 of
	       true => 
		  let
		     val x_3420: bool = 
			true
		  in
		     x_3420
		  end
	       false => 
		  let
		     val x_3417: Word8.word = 
			0xB
		     val x_3418: Word8.word * Word8.word = 
			(x_3397, x_3417)
		     val x_3419: bool = 
			= (Word8.word) x_3418
		  in
		     x_3419
		  end
	    val x_3421: bool = 
	       case x_3416 of
	       true => 
		  let
		     val x_3425: bool = 
			true
		  in
		     x_3425
		  end
	       false => 
		  let
		     val x_3422: Word8.word = 
			0xC
		     val x_3423: Word8.word * Word8.word = 
			(x_3397, x_3422)
		     val x_3424: bool = 
			= (Word8.word) x_3423
		  in
		     x_3424
		  end
	 in
	    x_3421
	 end
   val isSpace: Word8.word -> bool = 
      memoize (bool) isSpace
   val rec 'a_2680 
      skipWS: ('a_2680 -> (Word8.word * 'a_2680) option) -> 'a_2680 -> 'a_2680 = 
	 fn x_3426: 'a_2680 -> (Word8.word * 'a_2680) option => 
	 let
	    val x_3427: ('a_2680 -> (Word8.word * 'a_2680) option)
			-> 'a_2680 -> 'a_2680 = 
	       dropl ('a_2680) isSpace
	    val x_3428: 'a_2680 -> 'a_2680 = 
	       x_3427 x_3426
	 in
	    x_3428
	 end
   val rec 
      digitToChar: word -> Word8.word = 
	 fn x_3429: word => 
	 let
	    val x_3430: Word8.word vector = 
	       "0123456789ABCDEF"
	    val x_3431: Word8.word vector * word = 
	       (x_3430, x_3429)
	    val x_3432: Word8.word = 
	       sub_1 (Word8.word) x_3431
	 in
	    x_3432
	 end
   val 'a skipWS_0: ('a -> (Word8.word * 'a) option) -> 'a -> 'a = 
      let
      in
	 skipWS ('a)
      end
   val 'a scanString_0: ((word -> (Word8.word * word) option)
			 -> word -> ('a * word) option)
			-> Word8.word vector -> 'a option = 
      let
      in
	 scanString ('a)
      end
   val precision': word = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: Word8.word * word -> Word8.word = 
	 fn x_3433: Word8.word * word => 
	 let
	    val n: word = 
	       #1 x_3433
	    val i: Word8.word = 
	       #0 x_3433
	    val x_3434: word * word = 
	       (n, sizeInBitsWord)
	    val x_3435: bool = 
	       >= x_3434
	    val x_3436: Word8.word = 
	       case x_3435 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3437: word = 
			zextdFromWord32ToWord32 n
		     val x_3438: Word8.word * word = 
			(i, x_3437)
		     val x_3439: Word8.word = 
			<<? x_3438
		  in
		     x_3439
		  end
	 in
	    x_3436
	 end
   val rec 
      >>: Word8.word * word -> Word8.word = 
	 fn x_3440: Word8.word * word => 
	 let
	    val n: word = 
	       #1 x_3440
	    val i: Word8.word = 
	       #0 x_3440
	    val x_3441: word * word = 
	       (n, sizeInBitsWord)
	    val x_3442: bool = 
	       >= x_3441
	    val x_3443: Word8.word = 
	       case x_3442 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3444: word = 
			zextdFromWord32ToWord32 n
		     val x_3445: Word8.word * word = 
			(i, x_3444)
		     val x_3446: Word8.word = 
			>>? x_3445
		  in
		     x_3446
		  end
	 in
	    x_3443
	 end
   val precision': word = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: Word16.word * word -> Word16.word = 
	 fn x_3447: Word16.word * word => 
	 let
	    val n: word = 
	       #1 x_3447
	    val i: Word16.word = 
	       #0 x_3447
	    val x_3448: word * word = 
	       (n, sizeInBitsWord)
	    val x_3449: bool = 
	       >= x_3448
	    val x_3450: Word16.word = 
	       case x_3449 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3451: word = 
			zextdFromWord32ToWord32 n
		     val x_3452: Word16.word * word = 
			(i, x_3451)
		     val x_3453: Word16.word = 
			<<? x_3452
		  in
		     x_3453
		  end
	 in
	    x_3450
	 end
   val rec 
      >>: Word16.word * word -> Word16.word = 
	 fn x_3454: Word16.word * word => 
	 let
	    val n: word = 
	       #1 x_3454
	    val i: Word16.word = 
	       #0 x_3454
	    val x_3455: word * word = 
	       (n, sizeInBitsWord)
	    val x_3456: bool = 
	       >= x_3455
	    val x_3457: Word16.word = 
	       case x_3456 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3458: word = 
			zextdFromWord32ToWord32 n
		     val x_3459: Word16.word * word = 
			(i, x_3458)
		     val x_3460: Word16.word = 
			>>? x_3459
		  in
		     x_3460
		  end
	 in
	    x_3457
	 end
   val precision': word = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: word * word -> word = 
	 fn x_3461: word * word => 
	 let
	    val n: word = 
	       #1 x_3461
	    val i: word = 
	       #0 x_3461
	    val x_3462: word * word = 
	       (n, sizeInBitsWord)
	    val x_3463: bool = 
	       >= x_3462
	    val x_3464: word = 
	       case x_3463 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3465: word = 
			zextdFromWord32ToWord32 n
		     val x_3466: word * word = 
			(i, x_3465)
		     val x_3467: word = 
			<<? x_3466
		  in
		     x_3467
		  end
	 in
	    x_3464
	 end
   val rec 
      >>: word * word -> word = 
	 fn x_3468: word * word => 
	 let
	    val n: word = 
	       #1 x_3468
	    val i: word = 
	       #0 x_3468
	    val x_3469: word * word = 
	       (n, sizeInBitsWord)
	    val x_3470: bool = 
	       >= x_3469
	    val x_3471: word = 
	       case x_3470 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3472: word = 
			zextdFromWord32ToWord32 n
		     val x_3473: word * word = 
			(i, x_3472)
		     val x_3474: word = 
			>>? x_3473
		  in
		     x_3474
		  end
	 in
	    x_3471
	 end
   val x_3475: word = 
      0x1
   val x_3476: word * word = 
      (precision', x_3475)
   val maxNumDigits: word = 
      +! x_3476
   val x_3477: unit -> Word8.word array = 
      fn x_3478: unit => 
      let
	 val x_3479: Word8.word = 
	    0x0
	 val x_3480: word * Word8.word = 
	    (maxNumDigits, x_3479)
	 val x_3481: Word8.word array = 
	    array_0 (Word8.word) x_3480
      in
	 x_3481
      end
   val oneBuf: Word8.word array One.t = 
      make_0 (Word8.word array) x_3477
   val x_3482: StringCvt.radix = 
      DEC
   val rec 'a_2692 
      scan: StringCvt.radix
	    -> ('a_2692 -> (Word8.word * 'a_2692) option)
	       -> 'a_2692 -> (word * 'a_2692) option = 
	 fn x_3483: StringCvt.radix => 
	 let
	    val x_3484: ('a_2692 -> (Word8.word * 'a_2692) option)
			-> 'a_2692 -> (word * 'a_2692) option = 
	       fn x_3485: 'a_2692 -> (Word8.word * 'a_2692) option => 
	       let
		  val x_3486: 'a_2692 -> (word * 'a_2692) option = 
		     fn x_3487: 'a_2692 => 
		     let
			val x_3488: 'a_2692 -> 'a_2692 = 
			   skipWS_0 ('a_2692) x_3485
			val s: 'a_2692 = 
			   x_3488 x_3487
			val rec 
			   charToDigit: Word8.word -> word option = 
			      fn x_3489: Word8.word => 
			      let
				 val x_3490: Word8.word -> word option = 
				    case x_3483 of
				    BIN => 
				       let
				       in
					  bin
				       end
				    DEC => 
				       let
				       in
					  dec
				       end
				    HEX => 
				       let
				       in
					  hex
				       end
				    OCT => 
				       let
				       in
					  oct
				       end
				 val x_3491: word option = 
				    x_3490 x_3489
				 val x_3492: word option = 
				    case x_3491 of
				    NONE[word] => 
				       let
					  val x_3496: word option = 
					     NONE[word]
				       in
					  x_3496
				       end
				    SOME[word] x_3493: word => 
				       let
					  val x_3494: word = 
					     sextdFromInt32ToInt32 x_3493
					  val x_3495: word option = 
					     SOME[word] x_3494
				       in
					  x_3495
				       end
			      in
				 x_3492
			      end
			val x_3497: word = 
			   radixToInt x_3483
			val radixInt: word = 
			   sextdFromInt32ToInt32 x_3497
			val rec 
			   finishNum: 'a_2692 * word -> (word * 'a_2692) option = 
			      fn x_3498: 'a_2692 * word => 
			      let
				 val n: word = 
				    #1 x_3498
				 val s: 'a_2692 = 
				    #0 x_3498
				 val x_3499: (Word8.word * 'a_2692) option = 
				    x_3485 s
				 val x_3500: (word * 'a_2692) option = 
				    case x_3499 of
				    NONE[Word8.word * 'a_2692] => 
				       let
					  val x_3515: word * 'a_2692 = 
					     (n, s)
					  val x_3516: (word * 'a_2692) option = 
					     SOME[word * 'a_2692] x_3515
				       in
					  x_3516
				       end
				    SOME[Word8.word * 'a_2692] x_3501: Word8.word
								       * 'a_2692 => 
				       let
					  val x_3502: 'a_2692 = 
					     #1 x_3501
					  val x_3503: Word8.word = 
					     #0 x_3501
					  val x_3504: word option = 
					     charToDigit x_3503
					  val x_3505: (word * 'a_2692) option = 
					     case x_3504 of
					     NONE[word] => 
						let
						   val x_3513: word * 'a_2692 = 
						      (n, s)
						   val x_3514: (word * 'a_2692) option = 
						      SOME[word * 'a_2692] x_3513
						in
						   x_3514
						end
					     SOME[word] x_3506: word => 
						let
						   val x_3507: word * word = 
						      (n, radixInt)
						   val x_3508: word = 
						      *! x_3507
						   val x_3509: word * word = 
						      (x_3508, x_3506)
						   val x_3510: word = 
						      -! x_3509
						   val x_3511: 'a_2692 * word = 
						      (x_3502, x_3510)
						   val x_3512: (word * 'a_2692) option = 
						      finishNum x_3511
						in
						   x_3512
						end
				       in
					  x_3505
				       end
			      in
				 x_3500
			      end
			val rec 
			   num: 'a_2692 -> (word * 'a_2692) option = 
			      fn x_3517: 'a_2692 => 
			      let
				 val x_3518: (Word8.word * 'a_2692) option = 
				    x_3485 x_3517
				 val x_3519: 'a_2692 * Word8.word
					     -> (word * 'a_2692) option = 
				    fn x_3520: 'a_2692 * Word8.word => 
				    let
				       val c: Word8.word = 
					  #1 x_3520
				       val s: 'a_2692 = 
					  #0 x_3520
				       val x_3521: word option = 
					  charToDigit c
				       val x_3522: (word * 'a_2692) option = 
					  case x_3521 of
					  NONE[word] => 
					     let
						val x_3527: (word * 'a_2692) option = 
						   NONE[word * 'a_2692]
					     in
						x_3527
					     end
					  SOME[word] x_3523: word => 
					     let
						val x_3524: word = 
						   ~? x_3523
						val x_3525: 'a_2692 * word = 
						   (s, x_3524)
						val x_3526: (word * 'a_2692) option = 
						   finishNum x_3525
					     in
						x_3526
					     end
				    in
				       x_3522
				    end
				 val x_3528: (word * 'a_2692) option = 
				    case x_3518 of
				    NONE[Word8.word * 'a_2692] => 
				       let
					  val x_3577: (word * 'a_2692) option = 
					     NONE[word * 'a_2692]
				       in
					  x_3577
				       end
				    SOME[Word8.word * 'a_2692] x_3529: Word8.word
								       * 'a_2692 => 
				       let
					  val x_3530: 'a_2692 = 
					     #1 x_3529
					  val x_3531: Word8.word = 
					     #0 x_3529
					  val x_3532: (word * 'a_2692) option = 
					     case x_3531 of
					     0x30 => 
						let
						   val x_3533: (word * 'a_2692) option = 
						      case x_3483 of
						      HEX => 
							 let
							    val x_3534: (Word8.word
									 * 'a_2692) option = 
							       x_3485 x_3530
							    val x_3535: (word
									 * 'a_2692) option = 
							       case x_3534 of
							       NONE[Word8.word
								    * 'a_2692] => 
								  let
								     val x_3571: word
										 * 'a_2692 = 
									(zero,
									 x_3530)
								     val x_3572: (word
										  * 'a_2692) option = 
									SOME[word
									     * 'a_2692] x_3571
								  in
								     x_3572
								  end
							       SOME[Word8.word
								    * 'a_2692] x_3536: Word8.word
										       * 'a_2692 => 
								  let
								     val x_3537: 'a_2692 = 
									#1 x_3536
								     val x_3538: Word8.word = 
									#0 x_3536
								     val x_3539: Word8.word = 
									0x78
								     val x_3540: Word8.word
										 * Word8.word = 
									(x_3538,
									 x_3539)
								     val x_3541: bool = 
									= (Word8.word) x_3540
								     val x_3542: bool = 
									case x_3541 of
									true => 
									   let
									      val x_3546: bool = 
										 true
									   in
									      x_3546
									   end
									false => 
									   let
									      val x_3543: Word8.word = 
										 0x58
									      val x_3544: Word8.word
											  * Word8.word = 
										 (x_3538,
										  x_3543)
									      val x_3545: bool = 
										 = (Word8.word) x_3544
									   in
									      x_3545
									   end
								     val x_3547: (word
										  * 'a_2692) option = 
									case x_3542 of
									true => 
									   let
									      val x_3556: (Word8.word
											   * 'a_2692) option = 
										 x_3485 x_3537
									      val x_3557: (word
											   * 'a_2692) option = 
										 case x_3556 of
										 NONE[Word8.word
										      * 'a_2692] => 
										    let
										       val x_3569: word
												   * 'a_2692 = 
											  (zero,
											   x_3530)
										       val x_3570: (word
												    * 'a_2692) option = 
											  SOME[word
											       * 'a_2692] x_3569
										    in
										       x_3570
										    end
										 SOME[Word8.word
										      * 'a_2692] x_3558: Word8.word
													 * 'a_2692 => 
										    let
										       val x_3559: 'a_2692 = 
											  #1 x_3558
										       val x_3560: Word8.word = 
											  #0 x_3558
										       val x_3561: word option = 
											  charToDigit x_3560
										       val x_3562: (word
												    * 'a_2692) option = 
											  case x_3561 of
											  NONE[word] => 
											     let
												val x_3567: word
													    * 'a_2692 = 
												   (zero,
												    x_3530)
												val x_3568: (word
													     * 'a_2692) option = 
												   SOME[word
													* 'a_2692] x_3567
											     in
												x_3568
											     end
											  SOME[word] x_3563: word => 
											     let
												val x_3564: word = 
												   ~? x_3563
												val x_3565: 'a_2692
													    * word = 
												   (x_3559,
												    x_3564)
												val x_3566: (word
													     * 'a_2692) option = 
												   finishNum x_3565
											     in
												x_3566
											     end
										    in
										       x_3562
										    end
									   in
									      x_3557
									   end
									false => 
									   let
									      val x_3548: word option = 
										 charToDigit x_3538
									      val x_3549: (word
											   * 'a_2692) option = 
										 case x_3548 of
										 NONE[word] => 
										    let
										       val x_3554: word
												   * 'a_2692 = 
											  (zero,
											   x_3530)
										       val x_3555: (word
												    * 'a_2692) option = 
											  SOME[word
											       * 'a_2692] x_3554
										    in
										       x_3555
										    end
										 SOME[word] x_3550: word => 
										    let
										       val x_3551: word = 
											  ~? x_3550
										       val x_3552: 'a_2692
												   * word = 
											  (x_3537,
											   x_3551)
										       val x_3553: (word
												    * 'a_2692) option = 
											  finishNum x_3552
										    in
										       x_3553
										    end
									   in
									      x_3549
									   end
								  in
								     x_3547
								  end
							 in
							    x_3535
							 end
							_ => let
								val x_3573: 'a_2692
									    * Word8.word = 
								   (x_3530,
								    x_3531)
								val x_3574: (word
									     * 'a_2692) option = 
								   x_3519 x_3573
							     in
								x_3574
							     end
						in
						   x_3533
						end
					       _ => let
						       val x_3575: 'a_2692
								   * Word8.word = 
							  (x_3530, x_3531)
						       val x_3576: (word
								    * 'a_2692) option = 
							  x_3519 x_3575
						    in
						       x_3576
						    end
				       in
					  x_3532
				       end
			      in
				 x_3528
			      end
			val rec 
			   negate: 'a_2692 -> (word * 'a_2692) option = 
			      fn x_3578: 'a_2692 => 
			      let
				 val x_3579: (word * 'a_2692) option = 
				    num x_3578
				 val x_3580: (word * 'a_2692) option = 
				    case x_3579 of
				    NONE[word * 'a_2692] => 
				       let
					  val x_3587: (word * 'a_2692) option = 
					     NONE[word * 'a_2692]
				       in
					  x_3587
				       end
				    SOME[word * 'a_2692] x_3581: word * 'a_2692 => 
				       let
					  val x_3582: 'a_2692 = 
					     #1 x_3581
					  val x_3583: word = 
					     #0 x_3581
					  val x_3584: word = 
					     ~! x_3583
					  val x_3585: word * 'a_2692 = 
					     (x_3584, x_3582)
					  val x_3586: (word * 'a_2692) option = 
					     SOME[word * 'a_2692] x_3585
				       in
					  x_3586
				       end
			      in
				 x_3580
			      end
			val x_3588: (Word8.word * 'a_2692) option = 
			   x_3485 s
			val x_3589: (word * 'a_2692) option = 
			   case x_3588 of
			   NONE[Word8.word * 'a_2692] => 
			      let
				 val x_3598: (word * 'a_2692) option = 
				    NONE[word * 'a_2692]
			      in
				 x_3598
			      end
			   SOME[Word8.word * 'a_2692] x_3590: Word8.word
							      * 'a_2692 => 
			      let
				 val x_3591: 'a_2692 = 
				    #1 x_3590
				 val x_3592: Word8.word = 
				    #0 x_3590
				 val x_3593: (word * 'a_2692) option = 
				    case x_3592 of
				    0x7E => 
				       let
					  val x_3596: (word * 'a_2692) option = 
					     num x_3591
				       in
					  x_3596
				       end
				    0x2B => 
				       let
					  val x_3595: (word * 'a_2692) option = 
					     negate x_3591
				       in
					  x_3595
				       end
				    0x2D => 
				       let
					  val x_3594: (word * 'a_2692) option = 
					     num x_3591
				       in
					  x_3594
				       end
				      _ => let
					      val x_3597: (word * 'a_2692) option = 
						 negate s
					   in
					      x_3597
					   end
			      in
				 x_3593
			      end
		     in
			x_3589
		     end
	       in
		  x_3486
	       end
	 in
	    x_3484
	 end
   val x_3599: StringCvt.radix = 
      DEC
   val x_3600: (word -> (Word8.word * word) option)
	       -> word -> (word * word) option = 
      scan (word) x_3599
   val fromString: Word8.word vector -> word option = 
      scanString_0 (word) x_3600
   val precision': word = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: Word64.word * word -> Word64.word = 
	 fn x_3601: Word64.word * word => 
	 let
	    val n: word = 
	       #1 x_3601
	    val i: Word64.word = 
	       #0 x_3601
	    val x_3602: word * word = 
	       (n, sizeInBitsWord)
	    val x_3603: bool = 
	       >= x_3602
	    val x_3604: Word64.word = 
	       case x_3603 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3605: word = 
			zextdFromWord32ToWord32 n
		     val x_3606: Word64.word * word = 
			(i, x_3605)
		     val x_3607: Word64.word = 
			<<? x_3606
		  in
		     x_3607
		  end
	 in
	    x_3604
	 end
   val rec 
      >>: Word64.word * word -> Word64.word = 
	 fn x_3608: Word64.word * word => 
	 let
	    val n: word = 
	       #1 x_3608
	    val i: Word64.word = 
	       #0 x_3608
	    val x_3609: word * word = 
	       (n, sizeInBitsWord)
	    val x_3610: bool = 
	       >= x_3609
	    val x_3611: Word64.word = 
	       case x_3610 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3612: word = 
			zextdFromWord32ToWord32 n
		     val x_3613: Word64.word * word = 
			(i, x_3612)
		     val x_3614: Word64.word = 
			>>? x_3613
		  in
		     x_3614
		  end
	 in
	    x_3611
	 end
   val x_3615: word = 
      0x1
   val x_3616: word * word = 
      (precision', x_3615)
   val maxNumDigits: word = 
      +! x_3616
   val x_3617: unit -> Word8.word array = 
      fn x_3618: unit => 
      let
	 val x_3619: Word8.word = 
	    0x0
	 val x_3620: word * Word8.word = 
	    (maxNumDigits, x_3619)
	 val x_3621: Word8.word array = 
	    array_0 (Word8.word) x_3620
      in
	 x_3621
      end
   val oneBuf: Word8.word array One.t = 
      make_0 (Word8.word array) x_3617
   val rec 
      fmt: StringCvt.radix -> Word64.word -> Word8.word vector = 
	 fn x_3622: StringCvt.radix => 
	 let
	    val x_3623: Word64.word -> Word8.word vector = 
	       fn x_3624: Word64.word => 
	       let
		  val x_3625: Word8.word array -> Word8.word vector = 
		     fn x_3626: Word8.word array => 
		     let
			val x_3627: word = 
			   radixToInt x_3622
			val radix: Word64.word = 
			   sextdFromInt32ToInt64 x_3627
			val rec 
			   loop: Word64.word * word -> Word8.word vector = 
			      fn x_3628: Word64.word * word => 
			      let
				 val i: word = 
				    #1 x_3628
				 val q: Word64.word = 
				    #0 x_3628
				 val x_3629: Word64.word * Word64.word = 
				    (radix, zero)
				 val x_3630: bool = 
				    = (Word64.word) x_3629
				 val x_3631: Word64.word = 
				    case x_3630 of
				    true => 
				       let
					  val x_3641: exn = 
					     Div
					  val x_3642: Word64.word = 
					     raise x_3641
				       in
					  x_3642
				       end
				    false => 
				       let
					  val x_3632: Word64.word * Word64.word = 
					     (q, minInt')
					  val x_3633: bool = 
					     = (Word64.word) x_3632
					  val x_3634: bool = 
					     case x_3633 of
					     true => 
						let
						   val x_3636: Word64.word = 
						      ~! one
						   val x_3637: Word64.word
							       * Word64.word = 
						      (radix, x_3636)
						   val x_3638: bool = 
						      = (Word64.word) x_3637
						in
						   x_3638
						end
					     false => 
						let
						   val x_3635: bool = 
						      false
						in
						   x_3635
						end
					  val x_3639: Word64.word = 
					     case x_3634 of
					     true => 
						let
						in
						   zero
						end
					     false => 
						let
						   val x_3640: Word64.word = 
						      WordS64_rem (q, radix)
						in
						   x_3640
						end
				       in
					  x_3639
				       end
				 val x_3643: Word64.word = 
				    ~? x_3631
				 val x_3644: word = 
				    schckFromInt64ToInt32 x_3643
				 val x_3645: Word8.word = 
				    digitToChar x_3644
				 val x_3646: Word8.word array
					     * word
					     * Word8.word = 
				    (x_3626, i, x_3645)
				 val x_3647: unit = 
				    update_0 (Word8.word) x_3646
				 val x_3648: Word64.word * Word64.word = 
				    (radix, zero)
				 val x_3649: bool = 
				    = (Word64.word) x_3648
				 val x_3650: Word64.word = 
				    case x_3649 of
				    true => 
				       let
					  val x_3662: exn = 
					     Div
					  val x_3663: Word64.word = 
					     raise x_3662
				       in
					  x_3663
				       end
				    false => 
				       let
					  val x_3651: Word64.word * Word64.word = 
					     (q, minInt')
					  val x_3652: bool = 
					     = (Word64.word) x_3651
					  val x_3653: bool = 
					     case x_3652 of
					     true => 
						let
						   val x_3655: Word64.word = 
						      ~! one
						   val x_3656: Word64.word
							       * Word64.word = 
						      (radix, x_3655)
						   val x_3657: bool = 
						      = (Word64.word) x_3656
						in
						   x_3657
						end
					     false => 
						let
						   val x_3654: bool = 
						      false
						in
						   x_3654
						end
					  val x_3658: Word64.word = 
					     case x_3653 of
					     true => 
						let
						   val x_3660: exn = 
						      Overflow
						   val x_3661: Word64.word = 
						      raise x_3660
						in
						   x_3661
						end
					     false => 
						let
						   val x_3659: Word64.word = 
						      WordS64_quot (q, radix)
						in
						   x_3659
						end
				       in
					  x_3658
				       end
				 val x_3664: Word64.word * Word64.word = 
				    (x_3650, zero)
				 val x_3665: bool = 
				    = (Word64.word) x_3664
				 val x_3666: Word8.word vector = 
				    case x_3665 of
				    true => 
				       let
					  val x_3672: Word64.word * Word64.word = 
					     (x_3624, zero)
					  val x_3673: bool = 
					     < x_3672
					  val x_3674: word = 
					     case x_3673 of
					     true => 
						let
						   val x_3675: word = 
						      0x1
						   val x_3676: word * word = 
						      (i, x_3675)
						   val i: word = 
						      -! x_3676
						   val x_3677: Word8.word = 
						      0x7E
						   val x_3678: Word8.word array
							       * word
							       * Word8.word = 
						      (x_3626, i, x_3677)
						   val x_3679: unit = 
						      update_0 (Word8.word) x_3678
						in
						   i
						end
					     false => 
						let
						in
						   i
						end
					  val x_3680: word option = 
					     NONE[word]
					  val x_3681: Word8.word array
						      * word
						      * word option = 
					     (x_3626, x_3674, x_3680)
					  val x_3682: Word8.word ArraySlice.slice = 
					     slice_3 (Word8.word) x_3681
					  val x_3683: Word8.word vector = 
					     vector_2 (Word8.word) x_3682
				       in
					  x_3683
				       end
				    false => 
				       let
					  val x_3667: word = 
					     0x1
					  val x_3668: word * word = 
					     (i, x_3667)
					  val x_3669: word = 
					     -! x_3668
					  val x_3670: Word64.word * word = 
					     (x_3650, x_3669)
					  val x_3671: Word8.word vector = 
					     loop x_3670
				       in
					  x_3671
				       end
			      in
				 x_3666
			      end
			val x_3684: Word64.word * Word64.word = 
			   (x_3624, zero)
			val x_3685: bool = 
			   < x_3684
			val x_3686: Word64.word = 
			   case x_3685 of
			   true => 
			      let
			      in
				 x_3624
			      end
			   false => 
			      let
				 val x_3687: Word64.word = 
				    ~? x_3624
			      in
				 x_3687
			      end
			val x_3688: word = 
			   0x1
			val x_3689: word * word = 
			   (maxNumDigits, x_3688)
			val x_3690: word = 
			   -! x_3689
			val x_3691: Word64.word * word = 
			   (x_3686, x_3690)
			val x_3692: Word8.word vector = 
			   loop x_3691
		     in
			x_3692
		     end
		  val x_3693: Word8.word array One.t
			      * (Word8.word array -> Word8.word vector) = 
		     (oneBuf, x_3625)
		  val x_3694: Word8.word vector = 
		     use_0 (Word8.word vector, Word8.word array) x_3693
	       in
		  x_3694
	       end
	 in
	    x_3623
	 end
   val wordSize: word = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: Word8.word * word -> Word8.word = 
	 fn x_3695: Word8.word * word => 
	 let
	    val n: word = 
	       #1 x_3695
	    val i: Word8.word = 
	       #0 x_3695
	    val x_3696: word * word = 
	       (n, sizeInBitsWord)
	    val x_3697: bool = 
	       >= x_3696
	    val x_3698: Word8.word = 
	       case x_3697 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3699: word = 
			zextdFromWord32ToWord32 n
		     val x_3700: Word8.word * word = 
			(i, x_3699)
		     val x_3701: Word8.word = 
			<<? x_3700
		  in
		     x_3701
		  end
	 in
	    x_3698
	 end
   val rec 
      >>: Word8.word * word -> Word8.word = 
	 fn x_3702: Word8.word * word => 
	 let
	    val n: word = 
	       #1 x_3702
	    val i: Word8.word = 
	       #0 x_3702
	    val x_3703: word * word = 
	       (n, sizeInBitsWord)
	    val x_3704: bool = 
	       >= x_3703
	    val x_3705: Word8.word = 
	       case x_3704 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3706: word = 
			zextdFromWord32ToWord32 n
		     val x_3707: Word8.word * word = 
			(i, x_3706)
		     val x_3708: Word8.word = 
			>>? x_3707
		  in
		     x_3708
		  end
	 in
	    x_3705
	 end
   val wordSize: word = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: Word16.word * word -> Word16.word = 
	 fn x_3709: Word16.word * word => 
	 let
	    val n: word = 
	       #1 x_3709
	    val i: Word16.word = 
	       #0 x_3709
	    val x_3710: word * word = 
	       (n, sizeInBitsWord)
	    val x_3711: bool = 
	       >= x_3710
	    val x_3712: Word16.word = 
	       case x_3711 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3713: word = 
			zextdFromWord32ToWord32 n
		     val x_3714: Word16.word * word = 
			(i, x_3713)
		     val x_3715: Word16.word = 
			<<? x_3714
		  in
		     x_3715
		  end
	 in
	    x_3712
	 end
   val rec 
      >>: Word16.word * word -> Word16.word = 
	 fn x_3716: Word16.word * word => 
	 let
	    val n: word = 
	       #1 x_3716
	    val i: Word16.word = 
	       #0 x_3716
	    val x_3717: word * word = 
	       (n, sizeInBitsWord)
	    val x_3718: bool = 
	       >= x_3717
	    val x_3719: Word16.word = 
	       case x_3718 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3720: word = 
			zextdFromWord32ToWord32 n
		     val x_3721: Word16.word * word = 
			(i, x_3720)
		     val x_3722: Word16.word = 
			>>? x_3721
		  in
		     x_3722
		  end
	 in
	    x_3719
	 end
   val wordSize: word = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: word * word -> word = 
	 fn x_3723: word * word => 
	 let
	    val n: word = 
	       #1 x_3723
	    val i: word = 
	       #0 x_3723
	    val x_3724: word * word = 
	       (n, sizeInBitsWord)
	    val x_3725: bool = 
	       >= x_3724
	    val x_3726: word = 
	       case x_3725 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3727: word = 
			zextdFromWord32ToWord32 n
		     val x_3728: word * word = 
			(i, x_3727)
		     val x_3729: word = 
			<<? x_3728
		  in
		     x_3729
		  end
	 in
	    x_3726
	 end
   val rec 
      >>: word * word -> word = 
	 fn x_3730: word * word => 
	 let
	    val n: word = 
	       #1 x_3730
	    val i: word = 
	       #0 x_3730
	    val x_3731: word * word = 
	       (n, sizeInBitsWord)
	    val x_3732: bool = 
	       >= x_3731
	    val x_3733: word = 
	       case x_3732 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3734: word = 
			zextdFromWord32ToWord32 n
		     val x_3735: word * word = 
			(i, x_3734)
		     val x_3736: word = 
			>>? x_3735
		  in
		     x_3736
		  end
	 in
	    x_3733
	 end
   val rec 
      st: word * word * word -> word * word * word = 
	 fn x_3737: word * word * word => 
	 let
	    val sft: word = 
	       #2 x_3737
	    val msk: word = 
	       #1 x_3737
	    val w: word = 
	       #0 x_3737
	    val x_3738: word * word = 
	       (w, msk)
	    val odd: word = 
	       andb x_3738
	    val x_3739: word * word = 
	       (w, odd)
	    val evn: word = 
	       xorb x_3739
	    val x_3740: word * word = 
	       (odd, sft)
	    val x_3741: word = 
	       <<? x_3740
	    val x_3742: word * word = 
	       (evn, sft)
	    val x_3743: word = 
	       >>? x_3742
	    val x_3744: word * word = 
	       (x_3741, x_3743)
	    val x_3745: word = 
	       xorb x_3744
	    val x_3746: word = 
	       0x1
	    val x_3747: word * word = 
	       (sft, x_3746)
	    val x_3748: word = 
	       >>? x_3747
	    val x_3749: word * word = 
	       (msk, x_3748)
	    val x_3750: word = 
	       <<? x_3749
	    val x_3751: word * word = 
	       (msk, x_3750)
	    val x_3752: word = 
	       xorb x_3751
	    val x_3753: word = 
	       0x1
	    val x_3754: word * word = 
	       (sft, x_3753)
	    val x_3755: word = 
	       >>? x_3754
	    val x_3756: word * word * word = 
	       (x_3745, x_3752, x_3755)
	 in
	    x_3756
	 end
   val x_3757: (word * word * word -> word * word * word) * word = 
      case sizeInBitsWord of
      0x8 => 
	 let
	    val x_3770: word * word * word -> word * word * word = 
	       fn x_3771: word * word * word => 
	       let
	       in
		  x_3771
	       end
	    val x_3772: word = 
	       0x4
	    val x_3773: (word * word * word -> word * word * word) * word = 
	       (x_3770, x_3772)
	 in
	    x_3773
	 end
      0x20 => 
	 let
	    val x_3766: (word * word * word -> word * word * word)
			* (word * word * word -> word * word * word) = 
	       (st, st)
	    val x_3767: word * word * word -> word * word * word = 
	       o_1 (word * word * word, word * word * word, word * word * word) x_3766
	    val x_3768: word = 
	       0x10
	    val x_3769: (word * word * word -> word * word * word) * word = 
	       (x_3767, x_3768)
	 in
	    x_3769
	 end
      0x40 => 
	 let
	    val x_3760: (word * word * word -> word * word * word)
			* (word * word * word -> word * word * word) = 
	       (st, st)
	    val x_3761: word * word * word -> word * word * word = 
	       o_1 (word * word * word, word * word * word, word * word * word) x_3760
	    val x_3762: (word * word * word -> word * word * word)
			* (word * word * word -> word * word * word) = 
	       (x_3761, st)
	    val x_3763: word * word * word -> word * word * word = 
	       o_1 (word * word * word, word * word * word, word * word * word) x_3762
	    val x_3764: word = 
	       0x20
	    val x_3765: (word * word * word -> word * word * word) * word = 
	       (x_3763, x_3764)
	 in
	    x_3765
	 end
      0x10 => 
	 let
	    val x_3758: word = 
	       0x8
	    val x_3759: (word * word * word -> word * word * word) * word = 
	       (st, x_3758)
	 in
	    x_3759
	 end
	_ => let
		val x_3774: Word8.word vector = 
		   "Word.bswap"
		val x_3775: exn = 
		   Fail x_3774
		val x_3776: (word * word * word -> word * word * word) * word = 
		   raise x_3775
	     in
		x_3776
	     end
   val sft: word = 
      #1 x_3757
   val f: word * word * word -> word * word * word = 
      #0 x_3757
   val rec 
      bswap: word -> word = 
	 fn x_3777: word => 
	 let
	    val x_3778: word * word = 
	       (one, sft)
	    val x_3779: word = 
	       <<? x_3778
	    val x_3780: word * word = 
	       (x_3779, one)
	    val x_3781: word = 
	       - x_3780
	    val x_3782: word * word * word = 
	       (x_3777, x_3781, sft)
	    val x_3783: word * word * word = 
	       f x_3782
	    val x_3784: word = 
	       #0 x_3783
	 in
	    x_3784
	 end
   val wordSize: word = 
      zextdFromInt32ToInt32 sizeInBits
   val sizeInBitsWord: word = 
      zextdFromWord32ToWord32 sizeInBitsWord
   val rec 
      <<: Word64.word * word -> Word64.word = 
	 fn x_3785: Word64.word * word => 
	 let
	    val n: word = 
	       #1 x_3785
	    val i: Word64.word = 
	       #0 x_3785
	    val x_3786: word * word = 
	       (n, sizeInBitsWord)
	    val x_3787: bool = 
	       >= x_3786
	    val x_3788: Word64.word = 
	       case x_3787 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3789: word = 
			zextdFromWord32ToWord32 n
		     val x_3790: Word64.word * word = 
			(i, x_3789)
		     val x_3791: Word64.word = 
			<<? x_3790
		  in
		     x_3791
		  end
	 in
	    x_3788
	 end
   val rec 
      >>: Word64.word * word -> Word64.word = 
	 fn x_3792: Word64.word * word => 
	 let
	    val n: word = 
	       #1 x_3792
	    val i: Word64.word = 
	       #0 x_3792
	    val x_3793: word * word = 
	       (n, sizeInBitsWord)
	    val x_3794: bool = 
	       >= x_3793
	    val x_3795: Word64.word = 
	       case x_3794 of
	       true => 
		  let
		  in
		     zero
		  end
	       false => 
		  let
		     val x_3796: word = 
			zextdFromWord32ToWord32 n
		     val x_3797: Word64.word * word = 
			(i, x_3796)
		     val x_3798: Word64.word = 
			>>? x_3797
		  in
		     x_3798
		  end
	 in
	    x_3795
	 end
   val x_3799: word = 
      0x2
   val x_3800: StringCvt.radix = 
      BIN
   val x_3801: Word64.word -> Word8.word vector = 
      fmt x_3800
   val x_3802: word * (Word64.word -> Word8.word vector) = 
      (x_3799, x_3801)
   val binCvt: IntInf.int -> Word8.word vector = 
      mkBigCvt x_3802
   val x_3803: word = 
      0x8
   val x_3804: StringCvt.radix = 
      OCT
   val x_3805: Word64.word -> Word8.word vector = 
      fmt x_3804
   val x_3806: word * (Word64.word -> Word8.word vector) = 
      (x_3803, x_3805)
   val octCvt: IntInf.int -> Word8.word vector = 
      mkBigCvt x_3806
   val x_3807: word = 
      0xA
   val x_3808: StringCvt.radix = 
      DEC
   val x_3809: Word64.word -> Word8.word vector = 
      fmt x_3808
   val x_3810: word * (Word64.word -> Word8.word vector) = 
      (x_3807, x_3809)
   val decCvt: IntInf.int -> Word8.word vector = 
      mkBigCvt x_3810
   val x_3811: word = 
      0x10
   val x_3812: StringCvt.radix = 
      HEX
   val x_3813: Word64.word -> Word8.word vector = 
      fmt x_3812
   val x_3814: word * (Word64.word -> Word8.word vector) = 
      (x_3811, x_3813)
   val hexCvt: IntInf.int -> Word8.word vector = 
      mkBigCvt x_3814
   val rec 
      binDig: Word8.word -> Word64.word option = 
	 fn x_3815: Word8.word => 
	 let
	    val x_3816: Word64.word option = 
	       case x_3815 of
	       0x30 => 
		  let
		     val x_3819: Word64.word = 
			0x0
		     val x_3820: Word64.word option = 
			SOME[Word64.word] x_3819
		  in
		     x_3820
		  end
	       0x31 => 
		  let
		     val x_3817: Word64.word = 
			0x1
		     val x_3818: Word64.word option = 
			SOME[Word64.word] x_3817
		  in
		     x_3818
		  end
		 _ => let
			 val x_3821: Word64.word option = 
			    NONE[Word64.word]
		      in
			 x_3821
		      end
	 in
	    x_3816
	 end
   val rec 
      octDig: Word8.word -> Word64.word option = 
	 fn x_3822: Word8.word => 
	 let
	    val x_3823: Word8.word = 
	       0x30
	    val x_3824: Word8.word * Word8.word = 
	       (x_3823, x_3822)
	    val x_3825: bool = 
	       <= x_3824
	    val x_3826: bool = 
	       case x_3825 of
	       true => 
		  let
		     val x_3828: Word8.word = 
			0x37
		     val x_3829: Word8.word * Word8.word = 
			(x_3822, x_3828)
		     val x_3830: bool = 
			<= x_3829
		  in
		     x_3830
		  end
	       false => 
		  let
		     val x_3827: bool = 
			false
		  in
		     x_3827
		  end
	    val x_3831: Word64.word option = 
	       case x_3826 of
	       true => 
		  let
		     val x_3833: word = 
			x_3156 x_3822
		     val x_3834: Word8.word = 
			0x30
		     val x_3835: word = 
			x_3156 x_3834
		     val x_3836: word * word = 
			(x_3833, x_3835)
		     val x_3837: word = 
			-! x_3836
		     val x_3838: Word64.word = 
			sextdFromInt32ToWord64 x_3837
		     val x_3839: Word64.word option = 
			SOME[Word64.word] x_3838
		  in
		     x_3839
		  end
	       false => 
		  let
		     val x_3832: Word64.word option = 
			NONE[Word64.word]
		  in
		     x_3832
		  end
	 in
	    x_3831
	 end
   val rec 
      decDig: Word8.word -> Word64.word option = 
	 fn x_3840: Word8.word => 
	 let
	    val x_3841: Word8.word = 
	       0x30
	    val x_3842: Word8.word * Word8.word = 
	       (x_3841, x_3840)
	    val x_3843: bool = 
	       <= x_3842
	    val x_3844: bool = 
	       case x_3843 of
	       true => 
		  let
		     val x_3846: Word8.word = 
			0x39
		     val x_3847: Word8.word * Word8.word = 
			(x_3840, x_3846)
		     val x_3848: bool = 
			<= x_3847
		  in
		     x_3848
		  end
	       false => 
		  let
		     val x_3845: bool = 
			false
		  in
		     x_3845
		  end
	    val x_3849: Word64.word option = 
	       case x_3844 of
	       true => 
		  let
		     val x_3851: word = 
			x_3156 x_3840
		     val x_3852: Word8.word = 
			0x30
		     val x_3853: word = 
			x_3156 x_3852
		     val x_3854: word * word = 
			(x_3851, x_3853)
		     val x_3855: word = 
			-! x_3854
		     val x_3856: Word64.word = 
			sextdFromInt32ToWord64 x_3855
		     val x_3857: Word64.word option = 
			SOME[Word64.word] x_3856
		  in
		     x_3857
		  end
	       false => 
		  let
		     val x_3850: Word64.word option = 
			NONE[Word64.word]
		  in
		     x_3850
		  end
	 in
	    x_3849
	 end
   val rec 
      hexDig: Word8.word -> Word64.word option = 
	 fn x_3858: Word8.word => 
	 let
	    val x_3859: Word8.word = 
	       0x30
	    val x_3860: Word8.word * Word8.word = 
	       (x_3859, x_3858)
	    val x_3861: bool = 
	       <= x_3860
	    val x_3862: bool = 
	       case x_3861 of
	       true => 
		  let
		     val x_3864: Word8.word = 
			0x39
		     val x_3865: Word8.word * Word8.word = 
			(x_3858, x_3864)
		     val x_3866: bool = 
			<= x_3865
		  in
		     x_3866
		  end
	       false => 
		  let
		     val x_3863: bool = 
			false
		  in
		     x_3863
		  end
	    val x_3867: Word64.word option = 
	       case x_3862 of
	       true => 
		  let
		     val x_3907: word = 
			x_3156 x_3858
		     val x_3908: Word8.word = 
			0x30
		     val x_3909: word = 
			x_3156 x_3908
		     val x_3910: word * word = 
			(x_3907, x_3909)
		     val x_3911: word = 
			-! x_3910
		     val x_3912: Word64.word = 
			sextdFromInt32ToWord64 x_3911
		     val x_3913: Word64.word option = 
			SOME[Word64.word] x_3912
		  in
		     x_3913
		  end
	       false => 
		  let
		     val x_3868: Word8.word = 
			0x61
		     val x_3869: Word8.word * Word8.word = 
			(x_3868, x_3858)
		     val x_3870: bool = 
			<= x_3869
		     val x_3871: bool = 
			case x_3870 of
			true => 
			   let
			      val x_3873: Word8.word = 
				 0x66
			      val x_3874: Word8.word * Word8.word = 
				 (x_3858, x_3873)
			      val x_3875: bool = 
				 <= x_3874
			   in
			      x_3875
			   end
			false => 
			   let
			      val x_3872: bool = 
				 false
			   in
			      x_3872
			   end
		     val x_3876: Word64.word option = 
			case x_3871 of
			true => 
			   let
			      val x_3897: word = 
				 x_3156 x_3858
			      val x_3898: Word8.word = 
				 0x61
			      val x_3899: word = 
				 x_3156 x_3898
			      val x_3900: word = 
				 0xA
			      val x_3901: word * word = 
				 (x_3899, x_3900)
			      val x_3902: word = 
				 -! x_3901
			      val x_3903: word * word = 
				 (x_3897, x_3902)
			      val x_3904: word = 
				 -! x_3903
			      val x_3905: Word64.word = 
				 sextdFromInt32ToWord64 x_3904
			      val x_3906: Word64.word option = 
				 SOME[Word64.word] x_3905
			   in
			      x_3906
			   end
			false => 
			   let
			      val x_3877: Word8.word = 
				 0x41
			      val x_3878: Word8.word * Word8.word = 
				 (x_3877, x_3858)
			      val x_3879: bool = 
				 <= x_3878
			      val x_3880: bool = 
				 case x_3879 of
				 true => 
				    let
				       val x_3882: Word8.word = 
					  0x46
				       val x_3883: Word8.word * Word8.word = 
					  (x_3858, x_3882)
				       val x_3884: bool = 
					  <= x_3883
				    in
				       x_3884
				    end
				 false => 
				    let
				       val x_3881: bool = 
					  false
				    in
				       x_3881
				    end
			      val x_3885: Word64.word option = 
				 case x_3880 of
				 true => 
				    let
				       val x_3887: word = 
					  x_3156 x_3858
				       val x_3888: Word8.word = 
					  0x41
				       val x_3889: word = 
					  x_3156 x_3888
				       val x_3890: word = 
					  0xA
				       val x_3891: word * word = 
					  (x_3889, x_3890)
				       val x_3892: word = 
					  -! x_3891
				       val x_3893: word * word = 
					  (x_3887, x_3892)
				       val x_3894: word = 
					  -! x_3893
				       val x_3895: Word64.word = 
					  sextdFromInt32ToWord64 x_3894
				       val x_3896: Word64.word option = 
					  SOME[Word64.word] x_3895
				    in
				       x_3896
				    end
				 false => 
				    let
				       val x_3886: Word64.word option = 
					  NONE[Word64.word]
				    in
				       x_3886
				    end
			   in
			      x_3885
			   end
		  in
		     x_3876
		  end
	 in
	    x_3867
	 end
   val rec 'a 
      toDigR: (Word8.word -> Word64.word option)
	      * ('a -> (Word8.word * 'a) option)
	      -> 'a -> (Word64.word * 'a) option = 
	 fn x_3914: (Word8.word -> Word64.word option)
		    * ('a -> (Word8.word * 'a) option) => 
	 let
	    val x_3915: 'a -> (Word64.word * 'a) option = 
	       fn x_3916: 'a => 
	       let
		  val x_3917: 'a -> (Word8.word * 'a) option = 
		     #1 x_3914
		  val x_3918: Word8.word -> Word64.word option = 
		     #0 x_3914
		  val x_3919: (Word8.word * 'a) option = 
		     x_3917 x_3916
		  val x_3920: (Word64.word * 'a) option = 
		     case x_3919 of
		     NONE[Word8.word * 'a] => 
			let
			   val x_3930: (Word64.word * 'a) option = 
			      NONE[Word64.word * 'a]
			in
			   x_3930
			end
		     SOME[Word8.word * 'a] x_3921: Word8.word * 'a => 
			let
			   val x_3922: 'a = 
			      #1 x_3921
			   val x_3923: Word8.word = 
			      #0 x_3921
			   val x_3924: Word64.word option = 
			      x_3918 x_3923
			   val x_3925: (Word64.word * 'a) option = 
			      case x_3924 of
			      NONE[Word64.word] => 
				 let
				    val x_3929: (Word64.word * 'a) option = 
				       NONE[Word64.word * 'a]
				 in
				    x_3929
				 end
			      SOME[Word64.word] x_3926: Word64.word => 
				 let
				    val x_3927: Word64.word * 'a = 
				       (x_3926, x_3922)
				    val x_3928: (Word64.word * 'a) option = 
				       SOME[Word64.word * 'a] x_3927
				 in
				    x_3928
				 end
			in
			   x_3925
			end
	       in
		  x_3920
	       end
	 in
	    x_3915
	 end
   val rec 'a 
      toChunkR: Word64.word * ('a -> (Word64.word * 'a) option)
		-> 'a -> ((Word64.word * bool * Word64.word) * 'a) option = 
	 fn x_3931: Word64.word * ('a -> (Word64.word * 'a) option) => 
	 let
	    val dread: 'a -> (Word64.word * 'a) option = 
	       #1 x_3931
	    val base: Word64.word = 
	       #0 x_3931
	    val rec 
	       loop: Word64.word * word * 'a * Word64.word
		     -> (Word64.word * bool * Word64.word) * 'a = 
		  fn x_3932: Word64.word * word * 'a * Word64.word => 
		  let
		     val shift: Word64.word = 
			#3 x_3932
		     val s: 'a = 
			#2 x_3932
		     val left: word = 
			#1 x_3932
		     val chunk: Word64.word = 
			#0 x_3932
		     val x_3933: word = 
			0x0
		     val x_3934: word * word = 
			(left, x_3933)
		     val x_3935: bool = 
			<= x_3934
		     val x_3936: (Word64.word * bool * Word64.word) * 'a = 
			case x_3935 of
			true => 
			   let
			      val x_3956: bool = 
				 true
			      val x_3957: Word64.word * bool * Word64.word = 
				 (chunk, x_3956, shift)
			      val x_3958: (Word64.word * bool * Word64.word)
					  * 'a = 
				 (x_3957, s)
			   in
			      x_3958
			   end
			false => 
			   let
			      val x_3937: (Word64.word * 'a) option = 
				 dread s
			      val x_3938: (Word64.word * bool * Word64.word)
					  * 'a = 
				 case x_3937 of
				 NONE[Word64.word * 'a] => 
				    let
				       val x_3953: bool = 
					  false
				       val x_3954: Word64.word
						   * bool
						   * Word64.word = 
					  (chunk, x_3953, shift)
				       val x_3955: (Word64.word
						    * bool
						    * Word64.word)
						   * 'a = 
					  (x_3954, s)
				    in
				       x_3955
				    end
				 SOME[Word64.word * 'a] x_3939: Word64.word * 'a => 
				    let
				       val x_3940: 'a = 
					  #1 x_3939
				       val x_3941: Word64.word = 
					  #0 x_3939
				       val x_3942: word = 
					  0x1
				       val x_3943: word * word = 
					  (left, x_3942)
				       val x_3944: word = 
					  -! x_3943
				       val x_3945: Word64.word * Word64.word = 
					  (base, shift)
				       val x_3946: Word64.word = 
					  * x_3945
				       val x_3947: Word64.word * Word64.word = 
					  (base, chunk)
				       val x_3948: Word64.word = 
					  * x_3947
				       val x_3949: Word64.word * Word64.word = 
					  (x_3948, x_3941)
				       val x_3950: Word64.word = 
					  + x_3949
				       val x_3951: Word64.word
						   * word
						   * 'a
						   * Word64.word = 
					  (x_3950, x_3944, x_3940, x_3946)
				       val x_3952: (Word64.word
						    * bool
						    * Word64.word)
						   * 'a = 
					  loop x_3951
				    in
				       x_3952
				    end
			   in
			      x_3938
			   end
		  in
		     x_3936
		  end
	    val x_3959: unit -> word = 
	       fn x_3960: unit => 
	       let
		  val x_3961: Word8.word vector = 
		     "IntInf.scan:digitsPerChunk"
		  val x_3962: exn = 
		     Fail x_3961
		  val x_3963: word = 
		     raise x_3962
	       in
		  x_3963
	       end
	    val x_3964: word = 
	       case wordSize of
	       0x40 => 
		  let
		     val x_3983: Word64.word = 
			0xA
		     val x_3984: bool = 
			MLton_equal[Word64.word] (base, x_3983)
		     val x_3985: word = 
			case x_3984 of
			true => 
			   let
			      val x_4000: word = 
				 0x12
			   in
			      x_4000
			   end
			false => 
			   let
			      val x_3986: Word64.word = 
				 0x2
			      val x_3987: bool = 
				 MLton_equal[Word64.word] (base, x_3986)
			      val x_3988: word = 
				 case x_3987 of
				 true => 
				    let
				       val x_3999: word = 
					  0x3D
				    in
				       x_3999
				    end
				 false => 
				    let
				       val x_3989: Word64.word = 
					  0x8
				       val x_3990: bool = 
					  MLton_equal[Word64.word] (base, x_3989)
				       val x_3991: word = 
					  case x_3990 of
					  true => 
					     let
						val x_3998: word = 
						   0x14
					     in
						x_3998
					     end
					  false => 
					     let
						val x_3992: Word64.word = 
						   0x10
						val x_3993: bool = 
						   MLton_equal[Word64.word] (base,
									     x_3992)
						val x_3994: word = 
						   case x_3993 of
						   true => 
						      let
							 val x_3997: word = 
							    0xF
						      in
							 x_3997
						      end
						   false => 
						      let
							 val x_3995: unit = 
							    ()
							 val x_3996: word = 
							    x_3959 x_3995
						      in
							 x_3996
						      end
					     in
						x_3994
					     end
				    in
				       x_3991
				    end
			   in
			      x_3988
			   end
		  in
		     x_3985
		  end
	       0x20 => 
		  let
		     val x_3965: Word64.word = 
			0xA
		     val x_3966: bool = 
			MLton_equal[Word64.word] (base, x_3965)
		     val x_3967: word = 
			case x_3966 of
			true => 
			   let
			      val x_3982: word = 
				 0x8
			   in
			      x_3982
			   end
			false => 
			   let
			      val x_3968: Word64.word = 
				 0x2
			      val x_3969: bool = 
				 MLton_equal[Word64.word] (base, x_3968)
			      val x_3970: word = 
				 case x_3969 of
				 true => 
				    let
				       val x_3981: word = 
					  0x1D
				    in
				       x_3981
				    end
				 false => 
				    let
				       val x_3971: Word64.word = 
					  0x8
				       val x_3972: bool = 
					  MLton_equal[Word64.word] (base, x_3971)
				       val x_3973: word = 
					  case x_3972 of
					  true => 
					     let
						val x_3980: word = 
						   0x9
					     in
						x_3980
					     end
					  false => 
					     let
						val x_3974: Word64.word = 
						   0x10
						val x_3975: bool = 
						   MLton_equal[Word64.word] (base,
									     x_3974)
						val x_3976: word = 
						   case x_3975 of
						   true => 
						      let
							 val x_3979: word = 
							    0x7
						      in
							 x_3979
						      end
						   false => 
						      let
							 val x_3977: unit = 
							    ()
							 val x_3978: word = 
							    x_3959 x_3977
						      in
							 x_3978
						      end
					     in
						x_3976
					     end
				    in
				       x_3973
				    end
			   in
			      x_3970
			   end
		  in
		     x_3967
		  end
		 _ => let
			 val x_4001: unit = 
			    ()
			 val x_4002: word = 
			    x_3959 x_4001
		      in
			 x_4002
		      end
	    val rec 
	       reader: 'a -> ((Word64.word * bool * Word64.word) * 'a) option = 
		  fn x_4003: 'a => 
		  let
		     val x_4004: (Word64.word * 'a) option = 
			dread x_4003
		     val x_4005: ((Word64.word * bool * Word64.word) * 'a) option = 
			case x_4004 of
			NONE[Word64.word * 'a] => 
			   let
			      val x_4015: ((Word64.word * bool * Word64.word)
					   * 'a) option = 
				 NONE[(Word64.word * bool * Word64.word) * 'a]
			   in
			      x_4015
			   end
			SOME[Word64.word * 'a] x_4006: Word64.word * 'a => 
			   let
			      val x_4007: 'a = 
				 #1 x_4006
			      val x_4008: Word64.word = 
				 #0 x_4006
			      val x_4009: word = 
				 0x1
			      val x_4010: word * word = 
				 (x_3964, x_4009)
			      val x_4011: word = 
				 -! x_4010
			      val x_4012: Word64.word * word * 'a * Word64.word = 
				 (x_4008, x_4011, x_4007, base)
			      val x_4013: (Word64.word * bool * Word64.word)
					  * 'a = 
				 loop x_4012
			      val x_4014: ((Word64.word * bool * Word64.word)
					   * 'a) option = 
				 SOME[(Word64.word * bool * Word64.word) * 'a] x_4013
			   in
			      x_4014
			   end
		  in
		     x_4005
		  end
	 in
	    reader
	 end
   val rec 'a 
      toUnsR: ('a -> ((Word64.word * bool * Word64.word) * 'a) option)
	      -> 'a -> (IntInf.int * 'a) option = 
	 fn x_4016: 'a -> ((Word64.word * bool * Word64.word) * 'a) option => 
	 let
	    val rec 
	       loop: bool * IntInf.int * 'a -> IntInf.int * 'a = 
		  fn x_4017: bool * IntInf.int * 'a => 
		  let
		     val s: 'a = 
			#2 x_4017
		     val acc: IntInf.int = 
			#1 x_4017
		     val more: bool = 
			#0 x_4017
		     val x_4018: IntInf.int * 'a = 
			case more of
			true => 
			   let
			      val x_4020: ((Word64.word * bool * Word64.word)
					   * 'a) option = 
				 x_4016 s
			      val x_4021: IntInf.int * 'a = 
				 case x_4020 of
				 NONE[(Word64.word * bool * Word64.word) * 'a] => 
				    let
				       val x_4036: IntInf.int * 'a = 
					  (acc, s)
				    in
				       x_4036
				    end
				 SOME[(Word64.word * bool * Word64.word) * 'a] x_4022: (Word64.word
											* bool
											* Word64.word)
										       * 'a => 
				    let
				       val x_4023: 'a = 
					  #1 x_4022
				       val x_4024: Word64.word
						   * bool
						   * Word64.word = 
					  #0 x_4022
				       val x_4025: Word64.word = 
					  #2 x_4024
				       val x_4026: bool = 
					  #1 x_4024
				       val x_4027: Word64.word = 
					  #0 x_4024
				       val x_4028: IntInf.int = 
					  addTagCoerce x_4025
				       val x_4029: IntInf.int * IntInf.int = 
					  (x_4028, acc)
				       val x_4030: IntInf.int = 
					  bigMul x_4029
				       val x_4031: IntInf.int = 
					  addTagCoerce x_4027
				       val x_4032: IntInf.int * IntInf.int = 
					  (x_4030, x_4031)
				       val x_4033: IntInf.int = 
					  bigAdd x_4032
				       val x_4034: bool * IntInf.int * 'a = 
					  (x_4026, x_4033, x_4023)
				       val x_4035: IntInf.int * 'a = 
					  loop x_4034
				    in
				       x_4035
				    end
			   in
			      x_4021
			   end
			false => 
			   let
			      val x_4019: IntInf.int * 'a = 
				 (acc, s)
			   in
			      x_4019
			   end
		  in
		     x_4018
		  end
	    val rec 
	       reader: 'a -> (IntInf.int * 'a) option = 
		  fn x_4037: 'a => 
		  let
		     val x_4038: ((Word64.word * bool * Word64.word) * 'a) option = 
			x_4016 x_4037
		     val x_4039: (IntInf.int * 'a) option = 
			case x_4038 of
			NONE[(Word64.word * bool * Word64.word) * 'a] => 
			   let
			      val x_4049: (IntInf.int * 'a) option = 
				 NONE[IntInf.int * 'a]
			   in
			      x_4049
			   end
			SOME[(Word64.word * bool * Word64.word) * 'a] x_4040: (Word64.word
									       * bool
									       * Word64.word)
									      * 'a => 
			   let
			      val x_4041: 'a = 
				 #1 x_4040
			      val x_4042: Word64.word * bool * Word64.word = 
				 #0 x_4040
			      val x_4043: bool = 
				 #1 x_4042
			      val x_4044: Word64.word = 
				 #0 x_4042
			      val x_4045: IntInf.int = 
				 addTagCoerce x_4044
			      val x_4046: bool * IntInf.int * 'a = 
				 (x_4043, x_4045, x_4041)
			      val x_4047: IntInf.int * 'a = 
				 loop x_4046
			      val x_4048: (IntInf.int * 'a) option = 
				 SOME[IntInf.int * 'a] x_4047
			   in
			      x_4048
			   end
		  in
		     x_4039
		  end
	 in
	    reader
	 end
   val rec 'a 
      toHexR: ('a -> (Word8.word * 'a) option)
	      * ('a -> (IntInf.int * 'a) option)
	      -> 'a -> (IntInf.int * 'a) option = 
	 fn x_4050: ('a -> (Word8.word * 'a) option)
		    * ('a -> (IntInf.int * 'a) option) => 
	 let
	    val x_4051: 'a -> (IntInf.int * 'a) option = 
	       fn x_4052: 'a => 
	       let
		  val x_4053: 'a -> (IntInf.int * 'a) option = 
		     #1 x_4050
		  val x_4054: 'a -> (Word8.word * 'a) option = 
		     #0 x_4050
		  val x_4055: (Word8.word * 'a) option = 
		     x_4054 x_4052
		  val x_4056: (IntInf.int * 'a) option = 
		     case x_4055 of
		     NONE[Word8.word * 'a] => 
			let
			   val x_4088: (IntInf.int * 'a) option = 
			      NONE[IntInf.int * 'a]
			in
			   x_4088
			end
		     SOME[Word8.word * 'a] x_4057: Word8.word * 'a => 
			let
			   val x_4058: 'a = 
			      #1 x_4057
			   val x_4059: Word8.word = 
			      #0 x_4057
			   val x_4060: Word8.word = 
			      0x30
			   val x_4061: Word8.word * Word8.word = 
			      (x_4059, x_4060)
			   val x_4062: bool = 
			      = (Word8.word) x_4061
			   val x_4063: (IntInf.int * 'a) option = 
			      case x_4062 of
			      true => 
				 let
				    val x_4065: (Word8.word * 'a) option = 
				       x_4054 x_4058
				    val x_4066: (IntInf.int * 'a) option = 
				       case x_4065 of
				       NONE[Word8.word * 'a] => 
					  let
					     val x_4086: IntInf.int * 'a = 
						(zero, x_4058)
					     val x_4087: (IntInf.int * 'a) option = 
						SOME[IntInf.int * 'a] x_4086
					  in
					     x_4087
					  end
				       SOME[Word8.word * 'a] x_4067: Word8.word
								     * 'a => 
					  let
					     val x_4068: 'a = 
						#1 x_4067
					     val x_4069: Word8.word = 
						#0 x_4067
					     val x_4070: Word8.word = 
						0x78
					     val x_4071: Word8.word * Word8.word = 
						(x_4069, x_4070)
					     val x_4072: bool = 
						= (Word8.word) x_4071
					     val x_4073: bool = 
						case x_4072 of
						true => 
						   let
						      val x_4077: bool = 
							 true
						   in
						      x_4077
						   end
						false => 
						   let
						      val x_4074: Word8.word = 
							 0x58
						      val x_4075: Word8.word
								  * Word8.word = 
							 (x_4069, x_4074)
						      val x_4076: bool = 
							 = (Word8.word) x_4075
						   in
						      x_4076
						   end
					     val x_4078: (IntInf.int * 'a) option = 
						case x_4073 of
						true => 
						   let
						      val x_4080: (IntInf.int
								   * 'a) option = 
							 x_4053 x_4068
						      val x_4081: (IntInf.int
								   * 'a) option = 
							 case x_4080 of
							 NONE[IntInf.int * 'a] => 
							    let
							       val x_4084: IntInf.int
									   * 'a = 
								  (zero, x_4058)
							       val x_4085: (IntInf.int
									    * 'a) option = 
								  SOME[IntInf.int
								       * 'a] x_4084
							    in
							       x_4085
							    end
							 SOME[IntInf.int * 'a] x_4082: IntInf.int
										       * 'a => 
							    let
							       val x_4083: (IntInf.int
									    * 'a) option = 
								  SOME[IntInf.int
								       * 'a] x_4082
							    in
							       x_4083
							    end
						   in
						      x_4081
						   end
						false => 
						   let
						      val x_4079: (IntInf.int
								   * 'a) option = 
							 x_4053 x_4052
						   in
						      x_4079
						   end
					  in
					     x_4078
					  end
				 in
				    x_4066
				 end
			      false => 
				 let
				    val x_4064: (IntInf.int * 'a) option = 
				       x_4053 x_4052
				 in
				    x_4064
				 end
			in
			   x_4063
			end
	       in
		  x_4056
	       end
	 in
	    x_4051
	 end
   val rec 'a 
      toSign: ('a -> (Word8.word * 'a) option)
	      * ('a -> (IntInf.int * 'a) option)
	      -> 'a -> (IntInf.int * 'a) option = 
	 fn x_4089: ('a -> (Word8.word * 'a) option)
		    * ('a -> (IntInf.int * 'a) option) => 
	 let
	    val uread: 'a -> (IntInf.int * 'a) option = 
	       #1 x_4089
	    val cread: 'a -> (Word8.word * 'a) option = 
	       #0 x_4089
	    val rec 
	       reader: 'a -> (IntInf.int * 'a) option = 
		  fn x_4090: 'a => 
		  let
		     val x_4091: 'a -> 'a = 
			skipWS_0 ('a) cread
		     val s: 'a = 
			x_4091 x_4090
		     val x_4092: (Word8.word * 'a) option = 
			cread s
		     val x_4093: (IntInf.int * 'a) option = 
			case x_4092 of
			NONE[Word8.word * 'a] => 
			   let
			      val x_4130: (IntInf.int * 'a) option = 
				 NONE[IntInf.int * 'a]
			   in
			      x_4130
			   end
			SOME[Word8.word * 'a] x_4094: Word8.word * 'a => 
			   let
			      val x_4095: 'a = 
				 #1 x_4094
			      val x_4096: Word8.word = 
				 #0 x_4094
			      val x_4097: bool * 'a = 
				 case x_4096 of
				 0x2B => 
				    let
				       val x_4102: bool = 
					  false
				       val x_4103: bool * 'a = 
					  (x_4102, x_4095)
				    in
				       x_4103
				    end
				 0x7E => 
				    let
				       val x_4100: bool = 
					  true
				       val x_4101: bool * 'a = 
					  (x_4100, x_4095)
				    in
				       x_4101
				    end
				 0x2D => 
				    let
				       val x_4098: bool = 
					  true
				       val x_4099: bool * 'a = 
					  (x_4098, x_4095)
				    in
				       x_4099
				    end
				   _ => let
					   val x_4104: bool = 
					      false
					   val x_4105: bool * 'a = 
					      (x_4104, s)
					in
					   x_4105
					end
			      val s'': 'a = 
				 #1 x_4097
			      val isNeg: bool = 
				 #0 x_4097
			      val x_4106: (IntInf.int * 'a) option = 
				 case isNeg of
				 true => 
				    let
				       val x_4108: (IntInf.int * 'a) option = 
					  uread s''
				       val x_4109: (IntInf.int * 'a) option = 
					  case x_4108 of
					  NONE[IntInf.int * 'a] => 
					     let
						val x_4129: (IntInf.int * 'a) option = 
						   NONE[IntInf.int * 'a]
					     in
						x_4129
					     end
					  SOME[IntInf.int * 'a] x_4110: IntInf.int
									* 'a => 
					     let
						val x_4111: 'a = 
						   #1 x_4110
						val x_4112: IntInf.int = 
						   #0 x_4110
						val x_4113: bool = 
						   isSmall x_4112
						val x_4114: IntInf.int = 
						   case x_4113 of
						   true => 
						      let
							 val argw: Word64.word = 
							    toWord x_4112
							 val x_4120: Word64.word
								     * Word64.word = 
							    (argw,
							     badObjptrWordTagged)
							 val x_4121: bool = 
							    = (Word64.word) x_4120
							 val x_4122: IntInf.int = 
							    case x_4121 of
							    true => 
							       let
							       in
								  negBadIntInf
							       end
							    false => 
							       let
								  val x_4123: Word64.word = 
								     0x2
								  val x_4124: Word64.word
									      * Word64.word = 
								     (x_4123,
								      argw)
								  val x_4125: Word64.word = 
								     - x_4124
								  val x_4126: IntInf.int = 
								     fromWord x_4125
							       in
								  x_4126
							       end
						      in
							 x_4122
						      end
						   false => 
						      let
							 val x_4115: Word64.word = 
							    numLimbs x_4112
							 val x_4116: Word64.word = 
							    0x1
							 val x_4117: Word64.word
								     * Word64.word = 
							    (x_4115, x_4116)
							 val x_4118: Word64.word = 
							    reserve x_4117
							 val x_4119: IntInf.int = 
							    IntInf_neg (x_4112,
									x_4118)
						      in
							 x_4119
						      end
						val x_4127: IntInf.int * 'a = 
						   (x_4114, x_4111)
						val x_4128: (IntInf.int * 'a) option = 
						   SOME[IntInf.int * 'a] x_4127
					     in
						x_4128
					     end
				    in
				       x_4109
				    end
				 false => 
				    let
				       val x_4107: (IntInf.int * 'a) option = 
					  uread s''
				    in
				       x_4107
				    end
			   in
			      x_4106
			   end
		  in
		     x_4093
		  end
	 in
	    reader
	 end
   val rec 'a 
      reader: Word64.word * (Word8.word -> Word64.word option)
	      -> ('a -> (Word8.word * 'a) option)
		 -> 'a -> (IntInf.int * 'a) option = 
	 fn x_4131: Word64.word * (Word8.word -> Word64.word option) => 
	 let
	    val x_4132: ('a -> (Word8.word * 'a) option)
			-> 'a -> (IntInf.int * 'a) option = 
	       fn x_4133: 'a -> (Word8.word * 'a) option => 
	       let
		  val x_4134: Word8.word -> Word64.word option = 
		     #1 x_4131
		  val x_4135: Word64.word = 
		     #0 x_4131
		  val x_4136: (Word8.word -> Word64.word option)
			      * ('a -> (Word8.word * 'a) option) = 
		     (x_4134, x_4133)
		  val dread: 'a -> (Word64.word * 'a) option = 
		     toDigR ('a) x_4136
		  val x_4137: Word64.word * ('a -> (Word64.word * 'a) option) = 
		     (x_4135, dread)
		  val ckread: 'a
			      -> ((Word64.word * bool * Word64.word) * 'a) option = 
		     toChunkR ('a) x_4137
		  val uread: 'a -> (IntInf.int * 'a) option = 
		     toUnsR ('a) ckread
		  val x_4138: Word64.word = 
		     0x10
		  val x_4139: Word64.word * Word64.word = 
		     (x_4135, x_4138)
		  val x_4140: bool = 
		     = (Word64.word) x_4139
		  val x_4141: 'a -> (IntInf.int * 'a) option = 
		     case x_4140 of
		     true => 
			let
			   val x_4142: ('a -> (Word8.word * 'a) option)
				       * ('a -> (IntInf.int * 'a) option) = 
			      (x_4133, uread)
			   val x_4143: 'a -> (IntInf.int * 'a) option = 
			      toHexR ('a) x_4142
			in
			   x_4143
			end
		     false => 
			let
			in
			   uread
			end
		  val x_4144: ('a -> (Word8.word * 'a) option)
			      * ('a -> (IntInf.int * 'a) option) = 
		     (x_4133, x_4141)
		  val reader: 'a -> (IntInf.int * 'a) option = 
		     toSign ('a) x_4144
	       in
		  reader
	       end
	 in
	    x_4132
	 end
   val rec 'a_2865 
      binReader: ('a_2865 -> (Word8.word * 'a_2865) option)
		 -> 'a_2865 -> (IntInf.int * 'a_2865) option = 
	 fn x_4145: 'a_2865 -> (Word8.word * 'a_2865) option => 
	 let
	    val x_4146: Word64.word = 
	       0x2
	    val x_4147: Word64.word * (Word8.word -> Word64.word option) = 
	       (x_4146, binDig)
	    val x_4148: ('a_2865 -> (Word8.word * 'a_2865) option)
			-> 'a_2865 -> (IntInf.int * 'a_2865) option = 
	       reader ('a_2865) x_4147
	    val x_4149: 'a_2865 -> (IntInf.int * 'a_2865) option = 
	       x_4148 x_4145
	 in
	    x_4149
	 end
   val rec 'a_2866 
      octReader: ('a_2866 -> (Word8.word * 'a_2866) option)
		 -> 'a_2866 -> (IntInf.int * 'a_2866) option = 
	 fn x_4150: 'a_2866 -> (Word8.word * 'a_2866) option => 
	 let
	    val x_4151: Word64.word = 
	       0x8
	    val x_4152: Word64.word * (Word8.word -> Word64.word option) = 
	       (x_4151, octDig)
	    val x_4153: ('a_2866 -> (Word8.word * 'a_2866) option)
			-> 'a_2866 -> (IntInf.int * 'a_2866) option = 
	       reader ('a_2866) x_4152
	    val x_4154: 'a_2866 -> (IntInf.int * 'a_2866) option = 
	       x_4153 x_4150
	 in
	    x_4154
	 end
   val rec 'a_2867 
      decReader: ('a_2867 -> (Word8.word * 'a_2867) option)
		 -> 'a_2867 -> (IntInf.int * 'a_2867) option = 
	 fn x_4155: 'a_2867 -> (Word8.word * 'a_2867) option => 
	 let
	    val x_4156: Word64.word = 
	       0xA
	    val x_4157: Word64.word * (Word8.word -> Word64.word option) = 
	       (x_4156, decDig)
	    val x_4158: ('a_2867 -> (Word8.word * 'a_2867) option)
			-> 'a_2867 -> (IntInf.int * 'a_2867) option = 
	       reader ('a_2867) x_4157
	    val x_4159: 'a_2867 -> (IntInf.int * 'a_2867) option = 
	       x_4158 x_4155
	 in
	    x_4159
	 end
   val rec 'a_2868 
      hexReader: ('a_2868 -> (Word8.word * 'a_2868) option)
		 -> 'a_2868 -> (IntInf.int * 'a_2868) option = 
	 fn x_4160: 'a_2868 -> (Word8.word * 'a_2868) option => 
	 let
	    val x_4161: Word64.word = 
	       0x10
	    val x_4162: Word64.word * (Word8.word -> Word64.word option) = 
	       (x_4161, hexDig)
	    val x_4163: ('a_2868 -> (Word8.word * 'a_2868) option)
			-> 'a_2868 -> (IntInf.int * 'a_2868) option = 
	       reader ('a_2868) x_4162
	    val x_4164: 'a_2868 -> (IntInf.int * 'a_2868) option = 
	       x_4163 x_4160
	 in
	    x_4164
	 end
   val rec 'a_2869 
      scan: StringCvt.radix
	    -> ('a_2869 -> (Word8.word * 'a_2869) option)
	       -> 'a_2869 -> (IntInf.int * 'a_2869) option = 
	 fn x_4165: StringCvt.radix => 
	 let
	    val x_4166: ('a_2869 -> (Word8.word * 'a_2869) option)
			-> 'a_2869 -> (IntInf.int * 'a_2869) option = 
	       case x_4165 of
	       BIN => 
		  let
		  in
		     binReader ('a_2869)
		  end
	       DEC => 
		  let
		  in
		     decReader ('a_2869)
		  end
	       HEX => 
		  let
		  in
		     hexReader ('a_2869)
		  end
	       OCT => 
		  let
		  in
		     octReader ('a_2869)
		  end
	 in
	    x_4166
	 end
   val x_4167: StringCvt.radix = 
      DEC
   val x_4168: (word -> (Word8.word * word) option)
	       -> word -> (IntInf.int * word) option = 
      scan (word) x_4167
   val fromString: Word8.word vector -> IntInf.int option = 
      scanString_0 (IntInf.int) x_4168
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4169: word * word = 
      (precision', precision')
   val x_4170: bool = 
      < x_4169
   val x_4171: unit = 
      case x_4170 of
      true => 
	 let
	    val x_4175: unit = 
	       ()
	 in
	    x_4175
	 end
      false => 
	 let
	    val x_4172: Word8.word vector = 
	       "EmbedWord"
	    val x_4173: exn = 
	       Fail x_4172
	    val x_4174: unit = 
	       raise x_4173
	 in
	    x_4174
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4176: word * word = 
      (precision', precision')
   val x_4177: bool = 
      < x_4176
   val x_4178: unit = 
      case x_4177 of
      true => 
	 let
	    val x_4182: unit = 
	       ()
	 in
	    x_4182
	 end
      false => 
	 let
	    val x_4179: Word8.word vector = 
	       "EmbedWord"
	    val x_4180: exn = 
	       Fail x_4179
	    val x_4181: unit = 
	       raise x_4180
	 in
	    x_4181
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4183: word * word = 
      (precision', precision')
   val x_4184: bool = 
      < x_4183
   val x_4185: unit = 
      case x_4184 of
      true => 
	 let
	    val x_4189: unit = 
	       ()
	 in
	    x_4189
	 end
      false => 
	 let
	    val x_4186: Word8.word vector = 
	       "EmbedWord"
	    val x_4187: exn = 
	       Fail x_4186
	    val x_4188: unit = 
	       raise x_4187
	 in
	    x_4188
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4190: word * word = 
      (precision', precision')
   val x_4191: bool = 
      < x_4190
   val x_4192: unit = 
      case x_4191 of
      true => 
	 let
	    val x_4196: unit = 
	       ()
	 in
	    x_4196
	 end
      false => 
	 let
	    val x_4193: Word8.word vector = 
	       "EmbedWord"
	    val x_4194: exn = 
	       Fail x_4193
	    val x_4195: unit = 
	       raise x_4194
	 in
	    x_4195
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4197: word * word = 
      (precision', precision')
   val x_4198: bool = 
      < x_4197
   val x_4199: unit = 
      case x_4198 of
      true => 
	 let
	    val x_4203: unit = 
	       ()
	 in
	    x_4203
	 end
      false => 
	 let
	    val x_4200: Word8.word vector = 
	       "EmbedWord"
	    val x_4201: exn = 
	       Fail x_4200
	    val x_4202: unit = 
	       raise x_4201
	 in
	    x_4202
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4204: word * word = 
      (precision', precision')
   val x_4205: bool = 
      < x_4204
   val x_4206: unit = 
      case x_4205 of
      true => 
	 let
	    val x_4210: unit = 
	       ()
	 in
	    x_4210
	 end
      false => 
	 let
	    val x_4207: Word8.word vector = 
	       "EmbedWord"
	    val x_4208: exn = 
	       Fail x_4207
	    val x_4209: unit = 
	       raise x_4208
	 in
	    x_4209
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4211: word * word = 
      (precision', precision')
   val x_4212: bool = 
      < x_4211
   val x_4213: unit = 
      case x_4212 of
      true => 
	 let
	    val x_4217: unit = 
	       ()
	 in
	    x_4217
	 end
      false => 
	 let
	    val x_4214: Word8.word vector = 
	       "EmbedWord"
	    val x_4215: exn = 
	       Fail x_4214
	    val x_4216: unit = 
	       raise x_4215
	 in
	    x_4216
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4218: word * word = 
      (precision', precision')
   val x_4219: bool = 
      < x_4218
   val x_4220: unit = 
      case x_4219 of
      true => 
	 let
	    val x_4224: unit = 
	       ()
	 in
	    x_4224
	 end
      false => 
	 let
	    val x_4221: Word8.word vector = 
	       "EmbedWord"
	    val x_4222: exn = 
	       Fail x_4221
	    val x_4223: unit = 
	       raise x_4222
	 in
	    x_4223
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4225: word * word = 
      (precision', precision')
   val x_4226: bool = 
      < x_4225
   val x_4227: unit = 
      case x_4226 of
      true => 
	 let
	    val x_4231: unit = 
	       ()
	 in
	    x_4231
	 end
      false => 
	 let
	    val x_4228: Word8.word vector = 
	       "EmbedWord"
	    val x_4229: exn = 
	       Fail x_4228
	    val x_4230: unit = 
	       raise x_4229
	 in
	    x_4230
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4232: word * word = 
      (precision', precision')
   val x_4233: bool = 
      < x_4232
   val x_4234: unit = 
      case x_4233 of
      true => 
	 let
	    val x_4238: unit = 
	       ()
	 in
	    x_4238
	 end
      false => 
	 let
	    val x_4235: Word8.word vector = 
	       "EmbedWord"
	    val x_4236: exn = 
	       Fail x_4235
	    val x_4237: unit = 
	       raise x_4236
	 in
	    x_4237
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4239: word * word = 
      (precision', precision')
   val x_4240: bool = 
      < x_4239
   val x_4241: unit = 
      case x_4240 of
      true => 
	 let
	    val x_4245: unit = 
	       ()
	 in
	    x_4245
	 end
      false => 
	 let
	    val x_4242: Word8.word vector = 
	       "EmbedWord"
	    val x_4243: exn = 
	       Fail x_4242
	    val x_4244: unit = 
	       raise x_4243
	 in
	    x_4244
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4246: word * word = 
      (precision', precision')
   val x_4247: bool = 
      < x_4246
   val x_4248: unit = 
      case x_4247 of
      true => 
	 let
	    val x_4252: unit = 
	       ()
	 in
	    x_4252
	 end
      false => 
	 let
	    val x_4249: Word8.word vector = 
	       "EmbedWord"
	    val x_4250: exn = 
	       Fail x_4249
	    val x_4251: unit = 
	       raise x_4250
	 in
	    x_4251
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4253: word * word = 
      (precision', precision')
   val x_4254: bool = 
      < x_4253
   val x_4255: unit = 
      case x_4254 of
      true => 
	 let
	    val x_4259: unit = 
	       ()
	 in
	    x_4259
	 end
      false => 
	 let
	    val x_4256: Word8.word vector = 
	       "EmbedWord"
	    val x_4257: exn = 
	       Fail x_4256
	    val x_4258: unit = 
	       raise x_4257
	 in
	    x_4258
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4260: word * word = 
      (precision', precision')
   val x_4261: bool = 
      < x_4260
   val x_4262: unit = 
      case x_4261 of
      true => 
	 let
	    val x_4266: unit = 
	       ()
	 in
	    x_4266
	 end
      false => 
	 let
	    val x_4263: Word8.word vector = 
	       "EmbedWord"
	    val x_4264: exn = 
	       Fail x_4263
	    val x_4265: unit = 
	       raise x_4264
	 in
	    x_4265
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4267: word * word = 
      (precision', precision')
   val x_4268: bool = 
      < x_4267
   val x_4269: unit = 
      case x_4268 of
      true => 
	 let
	    val x_4273: unit = 
	       ()
	 in
	    x_4273
	 end
      false => 
	 let
	    val x_4270: Word8.word vector = 
	       "EmbedWord"
	    val x_4271: exn = 
	       Fail x_4270
	    val x_4272: unit = 
	       raise x_4271
	 in
	    x_4272
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4274: word * word = 
      (precision', precision')
   val x_4275: bool = 
      < x_4274
   val x_4276: unit = 
      case x_4275 of
      true => 
	 let
	    val x_4280: unit = 
	       ()
	 in
	    x_4280
	 end
      false => 
	 let
	    val x_4277: Word8.word vector = 
	       "EmbedWord"
	    val x_4278: exn = 
	       Fail x_4277
	    val x_4279: unit = 
	       raise x_4278
	 in
	    x_4279
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4281: word * word = 
      (precision', precision')
   val x_4282: bool = 
      < x_4281
   val x_4283: unit = 
      case x_4282 of
      true => 
	 let
	    val x_4287: unit = 
	       ()
	 in
	    x_4287
	 end
      false => 
	 let
	    val x_4284: Word8.word vector = 
	       "EmbedWord"
	    val x_4285: exn = 
	       Fail x_4284
	    val x_4286: unit = 
	       raise x_4285
	 in
	    x_4286
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4288: word * word = 
      (precision', precision')
   val x_4289: bool = 
      < x_4288
   val x_4290: unit = 
      case x_4289 of
      true => 
	 let
	    val x_4294: unit = 
	       ()
	 in
	    x_4294
	 end
      false => 
	 let
	    val x_4291: Word8.word vector = 
	       "EmbedWord"
	    val x_4292: exn = 
	       Fail x_4291
	    val x_4293: unit = 
	       raise x_4292
	 in
	    x_4293
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4295: word * word = 
      (precision', precision')
   val x_4296: bool = 
      < x_4295
   val x_4297: unit = 
      case x_4296 of
      true => 
	 let
	    val x_4301: unit = 
	       ()
	 in
	    x_4301
	 end
      false => 
	 let
	    val x_4298: Word8.word vector = 
	       "EmbedWord"
	    val x_4299: exn = 
	       Fail x_4298
	    val x_4300: unit = 
	       raise x_4299
	 in
	    x_4300
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4302: word * word = 
      (precision', precision')
   val x_4303: bool = 
      < x_4302
   val x_4304: unit = 
      case x_4303 of
      true => 
	 let
	    val x_4308: unit = 
	       ()
	 in
	    x_4308
	 end
      false => 
	 let
	    val x_4305: Word8.word vector = 
	       "EmbedWord"
	    val x_4306: exn = 
	       Fail x_4305
	    val x_4307: unit = 
	       raise x_4306
	 in
	    x_4307
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4309: word * word = 
      (precision', precision')
   val x_4310: bool = 
      < x_4309
   val x_4311: unit = 
      case x_4310 of
      true => 
	 let
	    val x_4315: unit = 
	       ()
	 in
	    x_4315
	 end
      false => 
	 let
	    val x_4312: Word8.word vector = 
	       "EmbedWord"
	    val x_4313: exn = 
	       Fail x_4312
	    val x_4314: unit = 
	       raise x_4313
	 in
	    x_4314
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4316: word * word = 
      (precision', precision')
   val x_4317: bool = 
      < x_4316
   val x_4318: unit = 
      case x_4317 of
      true => 
	 let
	    val x_4322: unit = 
	       ()
	 in
	    x_4322
	 end
      false => 
	 let
	    val x_4319: Word8.word vector = 
	       "EmbedWord"
	    val x_4320: exn = 
	       Fail x_4319
	    val x_4321: unit = 
	       raise x_4320
	 in
	    x_4321
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4323: word * word = 
      (precision', precision')
   val x_4324: bool = 
      < x_4323
   val x_4325: unit = 
      case x_4324 of
      true => 
	 let
	    val x_4329: unit = 
	       ()
	 in
	    x_4329
	 end
      false => 
	 let
	    val x_4326: Word8.word vector = 
	       "EmbedWord"
	    val x_4327: exn = 
	       Fail x_4326
	    val x_4328: unit = 
	       raise x_4327
	 in
	    x_4328
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4330: word * word = 
      (precision', precision')
   val x_4331: bool = 
      < x_4330
   val x_4332: unit = 
      case x_4331 of
      true => 
	 let
	    val x_4336: unit = 
	       ()
	 in
	    x_4336
	 end
      false => 
	 let
	    val x_4333: Word8.word vector = 
	       "EmbedWord"
	    val x_4334: exn = 
	       Fail x_4333
	    val x_4335: unit = 
	       raise x_4334
	 in
	    x_4335
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4337: word * word = 
      (precision', precision')
   val x_4338: bool = 
      < x_4337
   val x_4339: unit = 
      case x_4338 of
      true => 
	 let
	    val x_4343: unit = 
	       ()
	 in
	    x_4343
	 end
      false => 
	 let
	    val x_4340: Word8.word vector = 
	       "EmbedWord"
	    val x_4341: exn = 
	       Fail x_4340
	    val x_4342: unit = 
	       raise x_4341
	 in
	    x_4342
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4344: word * word = 
      (precision', precision')
   val x_4345: bool = 
      < x_4344
   val x_4346: unit = 
      case x_4345 of
      true => 
	 let
	    val x_4350: unit = 
	       ()
	 in
	    x_4350
	 end
      false => 
	 let
	    val x_4347: Word8.word vector = 
	       "EmbedWord"
	    val x_4348: exn = 
	       Fail x_4347
	    val x_4349: unit = 
	       raise x_4348
	 in
	    x_4349
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4351: word * word = 
      (precision', precision')
   val x_4352: bool = 
      < x_4351
   val x_4353: unit = 
      case x_4352 of
      true => 
	 let
	    val x_4357: unit = 
	       ()
	 in
	    x_4357
	 end
      false => 
	 let
	    val x_4354: Word8.word vector = 
	       "EmbedWord"
	    val x_4355: exn = 
	       Fail x_4354
	    val x_4356: unit = 
	       raise x_4355
	 in
	    x_4356
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4358: word * word = 
      (precision', precision')
   val x_4359: bool = 
      < x_4358
   val x_4360: unit = 
      case x_4359 of
      true => 
	 let
	    val x_4364: unit = 
	       ()
	 in
	    x_4364
	 end
      false => 
	 let
	    val x_4361: Word8.word vector = 
	       "EmbedWord"
	    val x_4362: exn = 
	       Fail x_4361
	    val x_4363: unit = 
	       raise x_4362
	 in
	    x_4363
	 end
   val precision': word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4365: word * word = 
      (precision', precision')
   val x_4366: bool = 
      < x_4365
   val x_4367: unit = 
      case x_4366 of
      true => 
	 let
	    val x_4371: unit = 
	       ()
	 in
	    x_4371
	 end
      false => 
	 let
	    val x_4368: Word8.word vector = 
	       "EmbedWord"
	    val x_4369: exn = 
	       Fail x_4368
	    val x_4370: unit = 
	       raise x_4369
	 in
	    x_4370
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4372: word * word = 
      (wordSize, wordSize)
   val x_4373: bool = 
      < x_4372
   val x_4374: unit = 
      case x_4373 of
      true => 
	 let
	    val x_4378: unit = 
	       ()
	 in
	    x_4378
	 end
      false => 
	 let
	    val x_4375: Word8.word vector = 
	       "EmbedWord"
	    val x_4376: exn = 
	       Fail x_4375
	    val x_4377: unit = 
	       raise x_4376
	 in
	    x_4377
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4379: word * word = 
      (wordSize, wordSize)
   val x_4380: bool = 
      < x_4379
   val x_4381: unit = 
      case x_4380 of
      true => 
	 let
	    val x_4385: unit = 
	       ()
	 in
	    x_4385
	 end
      false => 
	 let
	    val x_4382: Word8.word vector = 
	       "EmbedWord"
	    val x_4383: exn = 
	       Fail x_4382
	    val x_4384: unit = 
	       raise x_4383
	 in
	    x_4384
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4386: word * word = 
      (wordSize, wordSize)
   val x_4387: bool = 
      < x_4386
   val x_4388: unit = 
      case x_4387 of
      true => 
	 let
	    val x_4392: unit = 
	       ()
	 in
	    x_4392
	 end
      false => 
	 let
	    val x_4389: Word8.word vector = 
	       "EmbedWord"
	    val x_4390: exn = 
	       Fail x_4389
	    val x_4391: unit = 
	       raise x_4390
	 in
	    x_4391
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4393: word * word = 
      (wordSize, wordSize)
   val x_4394: bool = 
      < x_4393
   val x_4395: unit = 
      case x_4394 of
      true => 
	 let
	    val x_4399: unit = 
	       ()
	 in
	    x_4399
	 end
      false => 
	 let
	    val x_4396: Word8.word vector = 
	       "EmbedWord"
	    val x_4397: exn = 
	       Fail x_4396
	    val x_4398: unit = 
	       raise x_4397
	 in
	    x_4398
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4400: word * word = 
      (wordSize, wordSize)
   val x_4401: bool = 
      < x_4400
   val x_4402: unit = 
      case x_4401 of
      true => 
	 let
	    val x_4406: unit = 
	       ()
	 in
	    x_4406
	 end
      false => 
	 let
	    val x_4403: Word8.word vector = 
	       "EmbedWord"
	    val x_4404: exn = 
	       Fail x_4403
	    val x_4405: unit = 
	       raise x_4404
	 in
	    x_4405
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4407: word * word = 
      (wordSize, wordSize)
   val x_4408: bool = 
      < x_4407
   val x_4409: unit = 
      case x_4408 of
      true => 
	 let
	    val x_4413: unit = 
	       ()
	 in
	    x_4413
	 end
      false => 
	 let
	    val x_4410: Word8.word vector = 
	       "EmbedWord"
	    val x_4411: exn = 
	       Fail x_4410
	    val x_4412: unit = 
	       raise x_4411
	 in
	    x_4412
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4414: word * word = 
      (wordSize, wordSize)
   val x_4415: bool = 
      < x_4414
   val x_4416: unit = 
      case x_4415 of
      true => 
	 let
	    val x_4420: unit = 
	       ()
	 in
	    x_4420
	 end
      false => 
	 let
	    val x_4417: Word8.word vector = 
	       "EmbedWord"
	    val x_4418: exn = 
	       Fail x_4417
	    val x_4419: unit = 
	       raise x_4418
	 in
	    x_4419
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4421: word * word = 
      (wordSize, wordSize)
   val x_4422: bool = 
      < x_4421
   val x_4423: unit = 
      case x_4422 of
      true => 
	 let
	    val x_4427: unit = 
	       ()
	 in
	    x_4427
	 end
      false => 
	 let
	    val x_4424: Word8.word vector = 
	       "EmbedWord"
	    val x_4425: exn = 
	       Fail x_4424
	    val x_4426: unit = 
	       raise x_4425
	 in
	    x_4426
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4428: word * word = 
      (wordSize, wordSize)
   val x_4429: bool = 
      < x_4428
   val x_4430: unit = 
      case x_4429 of
      true => 
	 let
	    val x_4434: unit = 
	       ()
	 in
	    x_4434
	 end
      false => 
	 let
	    val x_4431: Word8.word vector = 
	       "EmbedWord"
	    val x_4432: exn = 
	       Fail x_4431
	    val x_4433: unit = 
	       raise x_4432
	 in
	    x_4433
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4435: word * word = 
      (wordSize, wordSize)
   val x_4436: bool = 
      < x_4435
   val x_4437: unit = 
      case x_4436 of
      true => 
	 let
	    val x_4441: unit = 
	       ()
	 in
	    x_4441
	 end
      false => 
	 let
	    val x_4438: Word8.word vector = 
	       "EmbedWord"
	    val x_4439: exn = 
	       Fail x_4438
	    val x_4440: unit = 
	       raise x_4439
	 in
	    x_4440
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4442: word * word = 
      (wordSize, wordSize)
   val x_4443: bool = 
      < x_4442
   val x_4444: unit = 
      case x_4443 of
      true => 
	 let
	    val x_4448: unit = 
	       ()
	 in
	    x_4448
	 end
      false => 
	 let
	    val x_4445: Word8.word vector = 
	       "EmbedWord"
	    val x_4446: exn = 
	       Fail x_4445
	    val x_4447: unit = 
	       raise x_4446
	 in
	    x_4447
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4449: word * word = 
      (wordSize, wordSize)
   val x_4450: bool = 
      < x_4449
   val x_4451: unit = 
      case x_4450 of
      true => 
	 let
	    val x_4455: unit = 
	       ()
	 in
	    x_4455
	 end
      false => 
	 let
	    val x_4452: Word8.word vector = 
	       "EmbedWord"
	    val x_4453: exn = 
	       Fail x_4452
	    val x_4454: unit = 
	       raise x_4453
	 in
	    x_4454
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4456: word * word = 
      (wordSize, wordSize)
   val x_4457: bool = 
      < x_4456
   val x_4458: unit = 
      case x_4457 of
      true => 
	 let
	    val x_4462: unit = 
	       ()
	 in
	    x_4462
	 end
      false => 
	 let
	    val x_4459: Word8.word vector = 
	       "EmbedWord"
	    val x_4460: exn = 
	       Fail x_4459
	    val x_4461: unit = 
	       raise x_4460
	 in
	    x_4461
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4463: word * word = 
      (wordSize, wordSize)
   val x_4464: bool = 
      < x_4463
   val x_4465: unit = 
      case x_4464 of
      true => 
	 let
	    val x_4469: unit = 
	       ()
	 in
	    x_4469
	 end
      false => 
	 let
	    val x_4466: Word8.word vector = 
	       "EmbedWord"
	    val x_4467: exn = 
	       Fail x_4466
	    val x_4468: unit = 
	       raise x_4467
	 in
	    x_4468
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4470: word * word = 
      (wordSize, wordSize)
   val x_4471: bool = 
      < x_4470
   val x_4472: unit = 
      case x_4471 of
      true => 
	 let
	    val x_4476: unit = 
	       ()
	 in
	    x_4476
	 end
      false => 
	 let
	    val x_4473: Word8.word vector = 
	       "EmbedWord"
	    val x_4474: exn = 
	       Fail x_4473
	    val x_4475: unit = 
	       raise x_4474
	 in
	    x_4475
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4477: word * word = 
      (wordSize, wordSize)
   val x_4478: bool = 
      < x_4477
   val x_4479: unit = 
      case x_4478 of
      true => 
	 let
	    val x_4483: unit = 
	       ()
	 in
	    x_4483
	 end
      false => 
	 let
	    val x_4480: Word8.word vector = 
	       "EmbedWord"
	    val x_4481: exn = 
	       Fail x_4480
	    val x_4482: unit = 
	       raise x_4481
	 in
	    x_4482
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4484: word * word = 
      (wordSize, wordSize)
   val x_4485: bool = 
      < x_4484
   val x_4486: unit = 
      case x_4485 of
      true => 
	 let
	    val x_4490: unit = 
	       ()
	 in
	    x_4490
	 end
      false => 
	 let
	    val x_4487: Word8.word vector = 
	       "EmbedWord"
	    val x_4488: exn = 
	       Fail x_4487
	    val x_4489: unit = 
	       raise x_4488
	 in
	    x_4489
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4491: word * word = 
      (wordSize, wordSize)
   val x_4492: bool = 
      < x_4491
   val x_4493: unit = 
      case x_4492 of
      true => 
	 let
	    val x_4497: unit = 
	       ()
	 in
	    x_4497
	 end
      false => 
	 let
	    val x_4494: Word8.word vector = 
	       "EmbedWord"
	    val x_4495: exn = 
	       Fail x_4494
	    val x_4496: unit = 
	       raise x_4495
	 in
	    x_4496
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4498: word * word = 
      (wordSize, wordSize)
   val x_4499: bool = 
      < x_4498
   val x_4500: unit = 
      case x_4499 of
      true => 
	 let
	    val x_4504: unit = 
	       ()
	 in
	    x_4504
	 end
      false => 
	 let
	    val x_4501: Word8.word vector = 
	       "EmbedWord"
	    val x_4502: exn = 
	       Fail x_4501
	    val x_4503: unit = 
	       raise x_4502
	 in
	    x_4503
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4505: word * word = 
      (wordSize, wordSize)
   val x_4506: bool = 
      < x_4505
   val x_4507: unit = 
      case x_4506 of
      true => 
	 let
	    val x_4511: unit = 
	       ()
	 in
	    x_4511
	 end
      false => 
	 let
	    val x_4508: Word8.word vector = 
	       "EmbedWord"
	    val x_4509: exn = 
	       Fail x_4508
	    val x_4510: unit = 
	       raise x_4509
	 in
	    x_4510
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4512: word * word = 
      (wordSize, wordSize)
   val x_4513: bool = 
      < x_4512
   val x_4514: unit = 
      case x_4513 of
      true => 
	 let
	    val x_4518: unit = 
	       ()
	 in
	    x_4518
	 end
      false => 
	 let
	    val x_4515: Word8.word vector = 
	       "EmbedWord"
	    val x_4516: exn = 
	       Fail x_4515
	    val x_4517: unit = 
	       raise x_4516
	 in
	    x_4517
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4519: word * word = 
      (wordSize, wordSize)
   val x_4520: bool = 
      < x_4519
   val x_4521: unit = 
      case x_4520 of
      true => 
	 let
	    val x_4525: unit = 
	       ()
	 in
	    x_4525
	 end
      false => 
	 let
	    val x_4522: Word8.word vector = 
	       "EmbedWord"
	    val x_4523: exn = 
	       Fail x_4522
	    val x_4524: unit = 
	       raise x_4523
	 in
	    x_4524
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4526: word * word = 
      (wordSize, wordSize)
   val x_4527: bool = 
      < x_4526
   val x_4528: unit = 
      case x_4527 of
      true => 
	 let
	    val x_4532: unit = 
	       ()
	 in
	    x_4532
	 end
      false => 
	 let
	    val x_4529: Word8.word vector = 
	       "EmbedWord"
	    val x_4530: exn = 
	       Fail x_4529
	    val x_4531: unit = 
	       raise x_4530
	 in
	    x_4531
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4533: word * word = 
      (wordSize, wordSize)
   val x_4534: bool = 
      < x_4533
   val x_4535: unit = 
      case x_4534 of
      true => 
	 let
	    val x_4539: unit = 
	       ()
	 in
	    x_4539
	 end
      false => 
	 let
	    val x_4536: Word8.word vector = 
	       "EmbedWord"
	    val x_4537: exn = 
	       Fail x_4536
	    val x_4538: unit = 
	       raise x_4537
	 in
	    x_4538
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4540: word * word = 
      (wordSize, wordSize)
   val x_4541: bool = 
      < x_4540
   val x_4542: unit = 
      case x_4541 of
      true => 
	 let
	    val x_4546: unit = 
	       ()
	 in
	    x_4546
	 end
      false => 
	 let
	    val x_4543: Word8.word vector = 
	       "EmbedWord"
	    val x_4544: exn = 
	       Fail x_4543
	    val x_4545: unit = 
	       raise x_4544
	 in
	    x_4545
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4547: word * word = 
      (wordSize, wordSize)
   val x_4548: bool = 
      < x_4547
   val x_4549: unit = 
      case x_4548 of
      true => 
	 let
	    val x_4553: unit = 
	       ()
	 in
	    x_4553
	 end
      false => 
	 let
	    val x_4550: Word8.word vector = 
	       "EmbedWord"
	    val x_4551: exn = 
	       Fail x_4550
	    val x_4552: unit = 
	       raise x_4551
	 in
	    x_4552
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4554: word * word = 
      (wordSize, wordSize)
   val x_4555: bool = 
      < x_4554
   val x_4556: unit = 
      case x_4555 of
      true => 
	 let
	    val x_4560: unit = 
	       ()
	 in
	    x_4560
	 end
      false => 
	 let
	    val x_4557: Word8.word vector = 
	       "EmbedWord"
	    val x_4558: exn = 
	       Fail x_4557
	    val x_4559: unit = 
	       raise x_4558
	 in
	    x_4559
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4561: word * word = 
      (wordSize, wordSize)
   val x_4562: bool = 
      < x_4561
   val x_4563: unit = 
      case x_4562 of
      true => 
	 let
	    val x_4567: unit = 
	       ()
	 in
	    x_4567
	 end
      false => 
	 let
	    val x_4564: Word8.word vector = 
	       "EmbedWord"
	    val x_4565: exn = 
	       Fail x_4564
	    val x_4566: unit = 
	       raise x_4565
	 in
	    x_4566
	 end
   val wordSize: word = 
      sextdFromInt32ToInt32 sizeInBits
   val x_4568: word * word = 
      (wordSize, wordSize)
   val x_4569: bool = 
      < x_4568
   val x_4570: unit = 
      case x_4569 of
      true => 
	 let
	    val x_4574: unit = 
	       ()
	 in
	    x_4574
	 end
      false => 
	 let
	    val x_4571: Word8.word vector = 
	       "EmbedWord"
	    val x_4572: exn = 
	       Fail x_4571
	    val x_4573: unit = 
	       raise x_4572
	 in
	    x_4573
	 end
   val x_4575: word = 
      0x1
   val x_4576: word * word = 
      (x_3157, x_4575)
   val maxOrd: word = 
      -! x_4576
   val rec 'a_3275 
      make: ((Word8.word * Word8.word -> bool) -> 'a_3275) -> 'a_3275 = 
	 fn x_4577: (Word8.word * Word8.word -> bool) -> 'a_3275 => 
	 let
	    val x_4578: 'a_3275 = 
	       x_4577 = (Word8.word)
	 in
	    x_4578
	 end
   val isPrefix: Word8.word vector -> Word8.word vector -> bool = 
      make (Word8.word vector -> Word8.word vector -> bool) isPrefix_1 (Word8.word)
   val x_4579: word = 
      0x0
   val x_4580: word = 
      idFromInt32ToWord32 maxOrd
   val x_4581: word = 
      idFromInt32ToWord32 x_4579
   val x_4582: word * word = 
      (x_4580, x_4581)
   val x_4583: bool = 
      < x_4582
   val x_4584: Word8.word option = 
      case x_4583 of
      true => 
	 let
	    val x_4587: Word8.word option = 
	       NONE[Word8.word]
	 in
	    x_4587
	 end
      false => 
	 let
	    val x_4585: Word8.word = 
	       x_3154 x_4579
	    val x_4586: Word8.word option = 
	       SOME[Word8.word] x_4585
	 in
	    x_4586
	 end
   val x_4588: Word8.word = 
      case x_4584 of
      NONE[Word8.word] => 
	 let
	    val x_4590: exn = 
	       Chr
	    val x_4591: Word8.word = 
	       raise x_4590
	 in
	    x_4591
	 end
      SOME[Word8.word] x_4589: Word8.word => 
	 let
	 in
	    x_4589
	 end
   val x_4592: word = 
      0x1
   val x_4593: word * Word8.word = 
      (x_4592, x_4588)
   val x_4594: Word8.word vector = 
      vector_0 (Word8.word) x_4593
   val rec 
      nullTerm: Word8.word vector -> Word8.word vector = 
	 fn x_4595: Word8.word vector => 
	 let
	    val x_4596: Word8.word vector * Word8.word vector = 
	       (x_4595, x_4594)
	    val x_4597: Word8.word vector = 
	       append_1 (Word8.word) x_4596
	 in
	    x_4597
	 end
   val x_4598: exn -> Word8.word vector option = 
      fn x_4599: exn => 
      let
	 val x_4600: Word8.word vector option = 
	    case x_4599 of
	    Fail x_4601: Word8.word vector => 
	       let
		  val x_4602: Word8.word vector list = 
		     nil[Word8.word vector]
		  val x_4603: Word8.word vector * Word8.word vector list = 
		     (x_4601, x_4602)
		  val x_4604: Word8.word vector list = 
		     ::[Word8.word vector] x_4603
		  val x_4605: Word8.word vector = 
		     "Fail: "
		  val x_4606: Word8.word vector * Word8.word vector list = 
		     (x_4605, x_4604)
		  val x_4607: Word8.word vector list = 
		     ::[Word8.word vector] x_4606
		  val x_4608: Word8.word vector = 
		     concat_1 (Word8.word) x_4607
		  val x_4609: Word8.word vector option = 
		     SOME[Word8.word vector] x_4608
	       in
		  x_4609
	       end
	      _ => let
		      val x_4610: Word8.word vector option = 
			 NONE[Word8.word vector]
		   in
		      x_4610
		   end
      in
	 x_4600
      end
   val x_4611: unit = 
      addExnMessager x_4598
   val x_4612: (Word8.word vector -> Word8.word vector)
	       * (Word8.word vector -> Word8.word vector) = 
      (fromString, nullTerm)
   val nullTerm: Word8.word vector -> Word8.word vector = 
      o_1 (Word8.word vector, Word8.word vector, Word8.word vector) x_4612
   val rec ('a_3288, 'a_3287) 
      makeLength: ('a_3287 * word -> 'a_3288) * ('a_3288 -> bool)
		  -> 'a_3287 -> word = 
	 fn x_4613: ('a_3287 * word -> 'a_3288) * ('a_3288 -> bool) => 
	 let
	    val x_4614: 'a_3287 -> word = 
	       fn x_4615: 'a_3287 => 
	       let
		  val x_4616: 'a_3288 -> bool = 
		     #1 x_4613
		  val x_4617: 'a_3287 * word -> 'a_3288 = 
		     #0 x_4613
		  val rec 
		     loop: word -> word = 
			fn x_4618: word => 
			let
			   val x_4619: 'a_3287 * word = 
			      (x_4615, x_4618)
			   val x_4620: 'a_3288 = 
			      x_4617 x_4619
			   val x_4621: bool = 
			      x_4616 x_4620
			   val x_4622: word = 
			      case x_4621 of
			      true => 
				 let
				 in
				    x_4618
				 end
			      false => 
				 let
				    val x_4623: word = 
				       0x1
				    val x_4624: word * word = 
				       (x_4618, x_4623)
				    val x_4625: word = 
				       +? x_4624
				    val x_4626: word = 
				       loop x_4625
				 in
				    x_4626
				 end
			in
			   x_4622
			end
		  val x_4627: word = 
		     0x0
		  val x_4628: word = 
		     loop x_4627
	       in
		  x_4628
	       end
	 in
	    x_4614
	 end
   val rec ('b, 'a) 
      toArrayOfLength: 'a * ('a * word -> 'b) * word -> 'b array = 
	 fn x_4629: 'a * ('a * word -> 'b) * word => 
	 let
	    val n: word = 
	       #2 x_4629
	    val sub: 'a * word -> 'b = 
	       #1 x_4629
	    val s: 'a = 
	       #0 x_4629
	    val x_4630: unit = 
	       ()
	    val x_4631: word * unit -> 'b * unit = 
	       fn x_4632: word * unit => 
	       let
		  val x_4633: word = 
		     #0 x_4632
		  val x_4634: 'a * word = 
		     (s, x_4633)
		  val x_4635: 'b = 
		     sub x_4634
		  val x_4636: unit = 
		     ()
		  val x_4637: 'b * unit = 
		     (x_4635, x_4636)
	       in
		  x_4637
	       end
	    val x_4638: word * unit * (word * unit -> 'b * unit) = 
	       (n, x_4630, x_4631)
	    val x_4639: 'b array * unit = 
	       unfoldi_1 ('b, unit) x_4638
	    val x_4640: 'b array = 
	       #0 x_4639
	 in
	    x_4640
	 end
   val rec 
      sub: Word64.word * word -> Word8.word = 
	 fn x_4641: Word64.word * word => 
	 let
	    val i: word = 
	       #1 x_4641
	    val cs: Word64.word = 
	       #0 x_4641
	    val x_4642: MLton.Pointer.t = 
	       fromWord cs
	    val x_4643: Word64.word = 
	       sextdFromInt32ToInt64 i
	    val x_4644: Word8.word = 
	       CPointer_getWord8 (x_4642, x_4643)
	    val x_4645: Word8.word = 
	       idFromWord8 x_4644
	 in
	    x_4645
	 end
   val x_4646: Word8.word -> bool = 
      fn x_4647: Word8.word => 
      let
	 val x_4648: bool = 
	    case x_4647 of
	    0x0 => 
	       let
		  val x_4649: bool = 
		     true
	       in
		  x_4649
	       end
	      _ => let
		      val x_4650: bool = 
			 false
		   in
		      x_4650
		   end
      in
	 x_4648
      end
   val x_4651: (Word64.word * word -> Word8.word) * (Word8.word -> bool) = 
      (sub, x_4646)
   val length: Word64.word -> word = 
      makeLength (Word8.word, Word64.word) x_4651
   val rec 
      new: unit -> (unit -> unit) list ref = 
	 fn x_4652: unit => 
	 let
	    val x_4653: (unit -> unit) list = 
	       nil[unit -> unit]
	    val x_4654: (unit -> unit) list ref = 
	       Ref_ref[(unit -> unit) list] (x_4653)
	 in
	    x_4654
	 end
   val rec 'a_3289 
      addNew: 'a_3289 list ref * 'a_3289 -> unit = 
	 fn x_4655: 'a_3289 list ref * 'a_3289 => 
	 let
	    val f: 'a_3289 = 
	       #1 x_4655
	    val cs: 'a_3289 list ref = 
	       #0 x_4655
	    val x_4656: 'a_3289 list = 
	       !_1 ('a_3289 list) cs
	    val x_4657: 'a_3289 * 'a_3289 list = 
	       (f, x_4656)
	    val x_4658: 'a_3289 list = 
	       ::['a_3289] x_4657
	    val x_4659: 'a_3289 list ref * 'a_3289 list = 
	       (cs, x_4658)
	    val x_4660: unit = 
	       :=_1 ('a_3289 list) x_4659
	 in
	    x_4660
	 end
   val x_4661: unit = 
      ()
   val atExit: (unit -> unit) list ref = 
      new x_4661
   val x_4662: unit = 
      ()
   val atLoadWorld: (unit -> unit) list ref = 
      new x_4662
   val fromRep: word -> word = 
      fn x_4663: word => 
      let
      in
	 x_4663
      end
   val toRep: word -> word = 
      fn x_4664: word => 
      let
      in
	 x_4664
      end
   val fromRep: word -> word = 
      fn x_4665: word => 
      let
      in
	 x_4665
      end
   val acces: word = 
      fromRep EACCES
   val addrinuse: word = 
      fromRep EADDRINUSE
   val addrnotavail: word = 
      fromRep EADDRNOTAVAIL
   val afnosupport: word = 
      fromRep EAFNOSUPPORT
   val again: word = 
      fromRep EAGAIN
   val already: word = 
      fromRep EALREADY
   val badf: word = 
      fromRep EBADF
   val badmsg: word = 
      fromRep EBADMSG
   val busy: word = 
      fromRep EBUSY
   val canceled: word = 
      fromRep ECANCELED
   val child: word = 
      fromRep ECHILD
   val connaborted: word = 
      fromRep ECONNABORTED
   val connrefused: word = 
      fromRep ECONNREFUSED
   val connreset: word = 
      fromRep ECONNRESET
   val deadlk: word = 
      fromRep EDEADLK
   val destaddrreq: word = 
      fromRep EDESTADDRREQ
   val dom: word = 
      fromRep EDOM
   val dquot: word = 
      fromRep EDQUOT
   val exist: word = 
      fromRep EEXIST
   val fault: word = 
      fromRep EFAULT
   val fbig: word = 
      fromRep EFBIG
   val hostunreach: word = 
      fromRep EHOSTUNREACH
   val idrm: word = 
      fromRep EIDRM
   val ilseq: word = 
      fromRep EILSEQ
   val inprogress: word = 
      fromRep EINPROGRESS
   val intr: word = 
      fromRep EINTR
   val inval: word = 
      fromRep EINVAL
   val io: word = 
      fromRep EIO
   val isconn: word = 
      fromRep EISCONN
   val isdir: word = 
      fromRep EISDIR
   val loop: word = 
      fromRep ELOOP
   val mfile: word = 
      fromRep EMFILE
   val mlink: word = 
      fromRep EMLINK
   val msgsize: word = 
      fromRep EMSGSIZE
   val multihop: word = 
      fromRep EMULTIHOP
   val nametoolong: word = 
      fromRep ENAMETOOLONG
   val netdown: word = 
      fromRep ENETDOWN
   val netreset: word = 
      fromRep ENETRESET
   val netunreach: word = 
      fromRep ENETUNREACH
   val nfile: word = 
      fromRep ENFILE
   val nobufs: word = 
      fromRep ENOBUFS
   val nodata: word = 
      fromRep ENODATA
   val nodev: word = 
      fromRep ENODEV
   val noent: word = 
      fromRep ENOENT
   val noexec: word = 
      fromRep ENOEXEC
   val nolck: word = 
      fromRep ENOLCK
   val nolink: word = 
      fromRep ENOLINK
   val nomem: word = 
      fromRep ENOMEM
   val nomsg: word = 
      fromRep ENOMSG
   val noprotoopt: word = 
      fromRep ENOPROTOOPT
   val nospc: word = 
      fromRep ENOSPC
   val nosr: word = 
      fromRep ENOSR
   val nostr: word = 
      fromRep ENOSTR
   val nosys: word = 
      fromRep ENOSYS
   val notconn: word = 
      fromRep ENOTCONN
   val notdir: word = 
      fromRep ENOTDIR
   val notempty: word = 
      fromRep ENOTEMPTY
   val notsock: word = 
      fromRep ENOTSOCK
   val notsup: word = 
      fromRep ENOTSUP
   val notty: word = 
      fromRep ENOTTY
   val nxio: word = 
      fromRep ENXIO
   val opnotsupp: word = 
      fromRep EOPNOTSUPP
   val overflow: word = 
      fromRep EOVERFLOW
   val perm: word = 
      fromRep EPERM
   val pipe: word = 
      fromRep EPIPE
   val proto: word = 
      fromRep EPROTO
   val protonosupport: word = 
      fromRep EPROTONOSUPPORT
   val prototype: word = 
      fromRep EPROTOTYPE
   val range: word = 
      fromRep ERANGE
   val rofs: word = 
      fromRep EROFS
   val spipe: word = 
      fromRep ESPIPE
   val srch: word = 
      fromRep ESRCH
   val stale: word = 
      fromRep ESTALE
   val time: word = 
      fromRep ETIME
   val timedout: word = 
      fromRep ETIMEDOUT
   val toobig: word = 
      fromRep E2BIG
   val txtbsy: word = 
      fromRep ETXTBSY
   val wouldblock: word = 
      fromRep EWOULDBLOCK
   val xdev: word = 
      fromRep EXDEV
   val rec 'a_3290 
      ::?: (word * 'a_3290) * (word * 'a_3290) list -> (word * 'a_3290) list = 
	 fn x_4666: (word * 'a_3290) * (word * 'a_3290) list => 
	 let
	    val x_4667: (word * 'a_3290) list = 
	       #1 x_4666
	    val x_4668: word * 'a_3290 = 
	       #0 x_4666
	    val x_4669: 'a_3290 = 
	       #1 x_4668
	    val x_4670: word = 
	       #0 x_4668
	    val x_4671: word = 
	       0xFFFFFFFF
	    val x_4672: word = 
	       fromRep x_4671
	    val x_4673: word * word = 
	       (x_4670, x_4672)
	    val x_4674: bool = 
	       = (word) x_4673
	    val x_4675: (word * 'a_3290) list = 
	       case x_4674 of
	       true => 
		  let
		  in
		     x_4667
		  end
	       false => 
		  let
		     val x_4676: word * 'a_3290 = 
			(x_4670, x_4669)
		     val x_4677: (word * 'a_3290) * (word * 'a_3290) list = 
			(x_4676, x_4667)
		     val x_4678: (word * 'a_3290) list = 
			::[word * 'a_3290] x_4677
		  in
		     x_4678
		  end
	 in
	    x_4675
	 end
   val x_4679: Word8.word vector = 
      "acces"
   val x_4680: word * Word8.word vector = 
      (acces, x_4679)
   val x_4681: Word8.word vector = 
      "addrinuse"
   val x_4682: word * Word8.word vector = 
      (addrinuse, x_4681)
   val x_4683: Word8.word vector = 
      "addrnotavail"
   val x_4684: word * Word8.word vector = 
      (addrnotavail, x_4683)
   val x_4685: Word8.word vector = 
      "afnosupport"
   val x_4686: word * Word8.word vector = 
      (afnosupport, x_4685)
   val x_4687: Word8.word vector = 
      "again"
   val x_4688: word * Word8.word vector = 
      (again, x_4687)
   val x_4689: Word8.word vector = 
      "already"
   val x_4690: word * Word8.word vector = 
      (already, x_4689)
   val x_4691: Word8.word vector = 
      "badf"
   val x_4692: word * Word8.word vector = 
      (badf, x_4691)
   val x_4693: Word8.word vector = 
      "badmsg"
   val x_4694: word * Word8.word vector = 
      (badmsg, x_4693)
   val x_4695: Word8.word vector = 
      "busy"
   val x_4696: word * Word8.word vector = 
      (busy, x_4695)
   val x_4697: Word8.word vector = 
      "canceled"
   val x_4698: word * Word8.word vector = 
      (canceled, x_4697)
   val x_4699: Word8.word vector = 
      "child"
   val x_4700: word * Word8.word vector = 
      (child, x_4699)
   val x_4701: Word8.word vector = 
      "connaborted"
   val x_4702: word * Word8.word vector = 
      (connaborted, x_4701)
   val x_4703: Word8.word vector = 
      "connrefused"
   val x_4704: word * Word8.word vector = 
      (connrefused, x_4703)
   val x_4705: Word8.word vector = 
      "connreset"
   val x_4706: word * Word8.word vector = 
      (connreset, x_4705)
   val x_4707: Word8.word vector = 
      "deadlk"
   val x_4708: word * Word8.word vector = 
      (deadlk, x_4707)
   val x_4709: Word8.word vector = 
      "destaddrreq"
   val x_4710: word * Word8.word vector = 
      (destaddrreq, x_4709)
   val x_4711: Word8.word vector = 
      "dom"
   val x_4712: word * Word8.word vector = 
      (dom, x_4711)
   val x_4713: Word8.word vector = 
      "dquot"
   val x_4714: word * Word8.word vector = 
      (dquot, x_4713)
   val x_4715: Word8.word vector = 
      "exist"
   val x_4716: word * Word8.word vector = 
      (exist, x_4715)
   val x_4717: Word8.word vector = 
      "fault"
   val x_4718: word * Word8.word vector = 
      (fault, x_4717)
   val x_4719: Word8.word vector = 
      "fbig"
   val x_4720: word * Word8.word vector = 
      (fbig, x_4719)
   val x_4721: Word8.word vector = 
      "hostunreach"
   val x_4722: word * Word8.word vector = 
      (hostunreach, x_4721)
   val x_4723: Word8.word vector = 
      "idrm"
   val x_4724: word * Word8.word vector = 
      (idrm, x_4723)
   val x_4725: Word8.word vector = 
      "ilseq"
   val x_4726: word * Word8.word vector = 
      (ilseq, x_4725)
   val x_4727: Word8.word vector = 
      "inprogress"
   val x_4728: word * Word8.word vector = 
      (inprogress, x_4727)
   val x_4729: Word8.word vector = 
      "intr"
   val x_4730: word * Word8.word vector = 
      (intr, x_4729)
   val x_4731: Word8.word vector = 
      "inval"
   val x_4732: word * Word8.word vector = 
      (inval, x_4731)
   val x_4733: Word8.word vector = 
      "io"
   val x_4734: word * Word8.word vector = 
      (io, x_4733)
   val x_4735: Word8.word vector = 
      "isconn"
   val x_4736: word * Word8.word vector = 
      (isconn, x_4735)
   val x_4737: Word8.word vector = 
      "isdir"
   val x_4738: word * Word8.word vector = 
      (isdir, x_4737)
   val x_4739: Word8.word vector = 
      "loop"
   val x_4740: word * Word8.word vector = 
      (loop, x_4739)
   val x_4741: Word8.word vector = 
      "mfile"
   val x_4742: word * Word8.word vector = 
      (mfile, x_4741)
   val x_4743: Word8.word vector = 
      "mlink"
   val x_4744: word * Word8.word vector = 
      (mlink, x_4743)
   val x_4745: Word8.word vector = 
      "msgsize"
   val x_4746: word * Word8.word vector = 
      (msgsize, x_4745)
   val x_4747: Word8.word vector = 
      "multihop"
   val x_4748: word * Word8.word vector = 
      (multihop, x_4747)
   val x_4749: Word8.word vector = 
      "nametoolong"
   val x_4750: word * Word8.word vector = 
      (nametoolong, x_4749)
   val x_4751: Word8.word vector = 
      "netdown"
   val x_4752: word * Word8.word vector = 
      (netdown, x_4751)
   val x_4753: Word8.word vector = 
      "netreset"
   val x_4754: word * Word8.word vector = 
      (netreset, x_4753)
   val x_4755: Word8.word vector = 
      "netunreach"
   val x_4756: word * Word8.word vector = 
      (netunreach, x_4755)
   val x_4757: Word8.word vector = 
      "nfile"
   val x_4758: word * Word8.word vector = 
      (nfile, x_4757)
   val x_4759: Word8.word vector = 
      "nobufs"
   val x_4760: word * Word8.word vector = 
      (nobufs, x_4759)
   val x_4761: Word8.word vector = 
      "nodata"
   val x_4762: word * Word8.word vector = 
      (nodata, x_4761)
   val x_4763: Word8.word vector = 
      "nodev"
   val x_4764: word * Word8.word vector = 
      (nodev, x_4763)
   val x_4765: Word8.word vector = 
      "noent"
   val x_4766: word * Word8.word vector = 
      (noent, x_4765)
   val x_4767: Word8.word vector = 
      "noexec"
   val x_4768: word * Word8.word vector = 
      (noexec, x_4767)
   val x_4769: Word8.word vector = 
      "nolck"
   val x_4770: word * Word8.word vector = 
      (nolck, x_4769)
   val x_4771: Word8.word vector = 
      "nolink"
   val x_4772: word * Word8.word vector = 
      (nolink, x_4771)
   val x_4773: Word8.word vector = 
      "nomem"
   val x_4774: word * Word8.word vector = 
      (nomem, x_4773)
   val x_4775: Word8.word vector = 
      "nomsg"
   val x_4776: word * Word8.word vector = 
      (nomsg, x_4775)
   val x_4777: Word8.word vector = 
      "noprotoopt"
   val x_4778: word * Word8.word vector = 
      (noprotoopt, x_4777)
   val x_4779: Word8.word vector = 
      "nospc"
   val x_4780: word * Word8.word vector = 
      (nospc, x_4779)
   val x_4781: Word8.word vector = 
      "nosr"
   val x_4782: word * Word8.word vector = 
      (nosr, x_4781)
   val x_4783: Word8.word vector = 
      "nostr"
   val x_4784: word * Word8.word vector = 
      (nostr, x_4783)
   val x_4785: Word8.word vector = 
      "nosys"
   val x_4786: word * Word8.word vector = 
      (nosys, x_4785)
   val x_4787: Word8.word vector = 
      "notconn"
   val x_4788: word * Word8.word vector = 
      (notconn, x_4787)
   val x_4789: Word8.word vector = 
      "notdir"
   val x_4790: word * Word8.word vector = 
      (notdir, x_4789)
   val x_4791: Word8.word vector = 
      "notempty"
   val x_4792: word * Word8.word vector = 
      (notempty, x_4791)
   val x_4793: Word8.word vector = 
      "notsock"
   val x_4794: word * Word8.word vector = 
      (notsock, x_4793)
   val x_4795: Word8.word vector = 
      "notsup"
   val x_4796: word * Word8.word vector = 
      (notsup, x_4795)
   val x_4797: Word8.word vector = 
      "notty"
   val x_4798: word * Word8.word vector = 
      (notty, x_4797)
   val x_4799: Word8.word vector = 
      "nxio"
   val x_4800: word * Word8.word vector = 
      (nxio, x_4799)
   val x_4801: Word8.word vector = 
      "opnotsupp"
   val x_4802: word * Word8.word vector = 
      (opnotsupp, x_4801)
   val x_4803: Word8.word vector = 
      "overflow"
   val x_4804: word * Word8.word vector = 
      (overflow, x_4803)
   val x_4805: Word8.word vector = 
      "perm"
   val x_4806: word * Word8.word vector = 
      (perm, x_4805)
   val x_4807: Word8.word vector = 
      "pipe"
   val x_4808: word * Word8.word vector = 
      (pipe, x_4807)
   val x_4809: Word8.word vector = 
      "proto"
   val x_4810: word * Word8.word vector = 
      (proto, x_4809)
   val x_4811: Word8.word vector = 
      "protonosupport"
   val x_4812: word * Word8.word vector = 
      (protonosupport, x_4811)
   val x_4813: Word8.word vector = 
      "prototype"
   val x_4814: word * Word8.word vector = 
      (prototype, x_4813)
   val x_4815: Word8.word vector = 
      "range"
   val x_4816: word * Word8.word vector = 
      (range, x_4815)
   val x_4817: Word8.word vector = 
      "rofs"
   val x_4818: word * Word8.word vector = 
      (rofs, x_4817)
   val x_4819: Word8.word vector = 
      "spipe"
   val x_4820: word * Word8.word vector = 
      (spipe, x_4819)
   val x_4821: Word8.word vector = 
      "srch"
   val x_4822: word * Word8.word vector = 
      (srch, x_4821)
   val x_4823: Word8.word vector = 
      "stale"
   val x_4824: word * Word8.word vector = 
      (stale, x_4823)
   val x_4825: Word8.word vector = 
      "time"
   val x_4826: word * Word8.word vector = 
      (time, x_4825)
   val x_4827: Word8.word vector = 
      "timedout"
   val x_4828: word * Word8.word vector = 
      (timedout, x_4827)
   val x_4829: Word8.word vector = 
      "toobig"
   val x_4830: word * Word8.word vector = 
      (toobig, x_4829)
   val x_4831: Word8.word vector = 
      "txtbsy"
   val x_4832: word * Word8.word vector = 
      (txtbsy, x_4831)
   val x_4833: Word8.word vector = 
      "wouldblock"
   val x_4834: word * Word8.word vector = 
      (wouldblock, x_4833)
   val x_4835: Word8.word vector = 
      "xdev"
   val x_4836: word * Word8.word vector = 
      (xdev, x_4835)
   val x_4837: (word * Word8.word vector) list = 
      nil[word * Word8.word vector]
   val x_4838: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4836, x_4837)
   val x_4839: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4838
   val x_4840: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4834, x_4839)
   val x_4841: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4840
   val x_4842: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4832, x_4841)
   val x_4843: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4842
   val x_4844: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4830, x_4843)
   val x_4845: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4844
   val x_4846: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4828, x_4845)
   val x_4847: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4846
   val x_4848: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4826, x_4847)
   val x_4849: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4848
   val x_4850: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4824, x_4849)
   val x_4851: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4850
   val x_4852: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4822, x_4851)
   val x_4853: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4852
   val x_4854: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4820, x_4853)
   val x_4855: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4854
   val x_4856: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4818, x_4855)
   val x_4857: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4856
   val x_4858: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4816, x_4857)
   val x_4859: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4858
   val x_4860: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4814, x_4859)
   val x_4861: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4860
   val x_4862: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4812, x_4861)
   val x_4863: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4862
   val x_4864: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4810, x_4863)
   val x_4865: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4864
   val x_4866: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4808, x_4865)
   val x_4867: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4866
   val x_4868: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4806, x_4867)
   val x_4869: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4868
   val x_4870: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4804, x_4869)
   val x_4871: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4870
   val x_4872: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4802, x_4871)
   val x_4873: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4872
   val x_4874: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4800, x_4873)
   val x_4875: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4874
   val x_4876: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4798, x_4875)
   val x_4877: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4876
   val x_4878: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4796, x_4877)
   val x_4879: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4878
   val x_4880: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4794, x_4879)
   val x_4881: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4880
   val x_4882: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4792, x_4881)
   val x_4883: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4882
   val x_4884: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4790, x_4883)
   val x_4885: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4884
   val x_4886: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4788, x_4885)
   val x_4887: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4886
   val x_4888: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4786, x_4887)
   val x_4889: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4888
   val x_4890: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4784, x_4889)
   val x_4891: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4890
   val x_4892: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4782, x_4891)
   val x_4893: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4892
   val x_4894: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4780, x_4893)
   val x_4895: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4894
   val x_4896: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4778, x_4895)
   val x_4897: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4896
   val x_4898: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4776, x_4897)
   val x_4899: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4898
   val x_4900: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4774, x_4899)
   val x_4901: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4900
   val x_4902: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4772, x_4901)
   val x_4903: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4902
   val x_4904: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4770, x_4903)
   val x_4905: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4904
   val x_4906: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4768, x_4905)
   val x_4907: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4906
   val x_4908: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4766, x_4907)
   val x_4909: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4908
   val x_4910: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4764, x_4909)
   val x_4911: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4910
   val x_4912: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4762, x_4911)
   val x_4913: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4912
   val x_4914: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4760, x_4913)
   val x_4915: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4914
   val x_4916: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4758, x_4915)
   val x_4917: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4916
   val x_4918: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4756, x_4917)
   val x_4919: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4918
   val x_4920: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4754, x_4919)
   val x_4921: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4920
   val x_4922: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4752, x_4921)
   val x_4923: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4922
   val x_4924: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4750, x_4923)
   val x_4925: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4924
   val x_4926: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4748, x_4925)
   val x_4927: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4926
   val x_4928: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4746, x_4927)
   val x_4929: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4928
   val x_4930: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4744, x_4929)
   val x_4931: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4930
   val x_4932: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4742, x_4931)
   val x_4933: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4932
   val x_4934: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4740, x_4933)
   val x_4935: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4934
   val x_4936: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4738, x_4935)
   val x_4937: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4936
   val x_4938: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4736, x_4937)
   val x_4939: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4938
   val x_4940: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4734, x_4939)
   val x_4941: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4940
   val x_4942: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4732, x_4941)
   val x_4943: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4942
   val x_4944: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4730, x_4943)
   val x_4945: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4944
   val x_4946: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4728, x_4945)
   val x_4947: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4946
   val x_4948: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4726, x_4947)
   val x_4949: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4948
   val x_4950: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4724, x_4949)
   val x_4951: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4950
   val x_4952: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4722, x_4951)
   val x_4953: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4952
   val x_4954: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4720, x_4953)
   val x_4955: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4954
   val x_4956: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4718, x_4955)
   val x_4957: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4956
   val x_4958: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4716, x_4957)
   val x_4959: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4958
   val x_4960: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4714, x_4959)
   val x_4961: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4960
   val x_4962: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4712, x_4961)
   val x_4963: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4962
   val x_4964: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4710, x_4963)
   val x_4965: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4964
   val x_4966: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4708, x_4965)
   val x_4967: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4966
   val x_4968: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4706, x_4967)
   val x_4969: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4968
   val x_4970: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4704, x_4969)
   val x_4971: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4970
   val x_4972: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4702, x_4971)
   val x_4973: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4972
   val x_4974: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4700, x_4973)
   val x_4975: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4974
   val x_4976: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4698, x_4975)
   val x_4977: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4976
   val x_4978: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4696, x_4977)
   val x_4979: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4978
   val x_4980: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4694, x_4979)
   val x_4981: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4980
   val x_4982: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4692, x_4981)
   val x_4983: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4982
   val x_4984: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4690, x_4983)
   val x_4985: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4984
   val x_4986: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4688, x_4985)
   val x_4987: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4986
   val x_4988: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4686, x_4987)
   val x_4989: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4988
   val x_4990: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4684, x_4989)
   val x_4991: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4990
   val x_4992: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4682, x_4991)
   val x_4993: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4992
   val x_4994: (word * Word8.word vector) * (word * Word8.word vector) list = 
      (x_4680, x_4993)
   val errorNames: (word * Word8.word vector) list = 
      ::? (Word8.word vector) x_4994
   exception SysErr of Word8.word vector * word option
   val x_4995: exn -> Word8.word vector option = 
      fn x_4996: exn => 
      let
	 val x_4997: Word8.word vector option = 
	    case x_4996 of
	    SysErr x_4998: Word8.word vector * word option => 
	       let
		  val x_4999: word option = 
		     #1 x_4998
		  val x_5000: Word8.word vector = 
		     #0 x_4998
		  val x_5001: Word8.word vector list = 
		     nil[Word8.word vector]
		  val x_5002: Word8.word vector = 
		     case x_4999 of
		     NONE[word] => 
			let
			   val x_5025: Word8.word vector = 
			      ""
			in
			   x_5025
			end
		     SOME[word] x_5003: word => 
			let
			   val x_5004: Word8.word vector list = 
			      nil[Word8.word vector]
			   val x_5005: Word8.word vector = 
			      "]"
			   val x_5006: Word8.word vector
				       * Word8.word vector list = 
			      (x_5005, x_5004)
			   val x_5007: Word8.word vector list = 
			      ::[Word8.word vector] x_5006
			   val x_5008: word * Word8.word vector -> bool = 
			      fn x_5009: word * Word8.word vector => 
			      let
				 val x_5010: word = 
				    #0 x_5009
				 val x_5011: word * word = 
				    (x_5003, x_5010)
				 val x_5012: bool = 
				    = (word) x_5011
			      in
				 x_5012
			      end
			   val x_5013: (word * Word8.word vector) list
				       -> (word * Word8.word vector) option = 
			      find_0 (word * Word8.word vector) x_5008
			   val x_5014: (word * Word8.word vector) option = 
			      x_5013 errorNames
			   val x_5015: Word8.word vector = 
			      case x_5014 of
			      NONE[word * Word8.word vector] => 
				 let
				    val x_5018: Word8.word vector = 
				       "<UNKNOWN>"
				 in
				    x_5018
				 end
			      SOME[word * Word8.word vector] x_5016: word
								     * Word8.word vector => 
				 let
				    val x_5017: Word8.word vector = 
				       #1 x_5016
				 in
				    x_5017
				 end
			   val x_5019: Word8.word vector
				       * Word8.word vector list = 
			      (x_5015, x_5007)
			   val x_5020: Word8.word vector list = 
			      ::[Word8.word vector] x_5019
			   val x_5021: Word8.word vector = 
			      " ["
			   val x_5022: Word8.word vector
				       * Word8.word vector list = 
			      (x_5021, x_5020)
			   val x_5023: Word8.word vector list = 
			      ::[Word8.word vector] x_5022
			   val x_5024: Word8.word vector = 
			      concat_1 (Word8.word) x_5023
			in
			   x_5024
			end
		  val x_5026: Word8.word vector * Word8.word vector list = 
		     (x_5002, x_5001)
		  val x_5027: Word8.word vector list = 
		     ::[Word8.word vector] x_5026
		  val x_5028: Word8.word vector * Word8.word vector list = 
		     (x_5000, x_5027)
		  val x_5029: Word8.word vector list = 
		     ::[Word8.word vector] x_5028
		  val x_5030: Word8.word vector = 
		     "SysErr: "
		  val x_5031: Word8.word vector * Word8.word vector list = 
		     (x_5030, x_5029)
		  val x_5032: Word8.word vector list = 
		     ::[Word8.word vector] x_5031
		  val x_5033: Word8.word vector = 
		     concat_1 (Word8.word) x_5032
		  val x_5034: Word8.word vector option = 
		     SOME[Word8.word vector] x_5033
	       in
		  x_5034
	       end
	      _ => let
		      val x_5035: Word8.word vector option = 
			 NONE[Word8.word vector]
		   in
		      x_5035
		   end
      in
	 x_4997
      end
   val x_5036: unit = 
      addExnMessager x_4995
   val rec 'a_3291 
      raiseSys: word -> 'a_3291 = 
	 fn x_5037: word => 
	 let
	    val x_5038: Word64.word = 
	       Posix_Error_strError (x_5037)
	    val x_5039: MLton.Pointer.t = 
	       fromWord x_5038
	    val x_5040: MLton.Pointer.t * MLton.Pointer.t = 
	       (x_5039, null)
	    val x_5041: bool = 
	       = (MLton.Pointer.t) x_5040
	    val x_5042: Word8.word vector = 
	       case x_5041 of
	       true => 
		  let
		     val x_5048: Word8.word vector = 
			"Unknown error"
		  in
		     x_5048
		  end
	       false => 
		  let
		     val x_5043: word = 
			length x_5038
		     val x_5044: Word64.word
				 * (Word64.word * word -> Word8.word)
				 * word = 
			(x_5038, sub, x_5043)
		     val x_5045: Word8.word array = 
			toArrayOfLength (Word8.word, Word64.word) x_5044
		     val x_5046: Word8.word array = 
			fromPoly (Word8.word array) x_5045
		     val x_5047: Word8.word vector = 
			unsafeFromArray_0 (Word8.word) x_5046
		  in
		     x_5047
		  end
	    val x_5049: word option = 
	       SOME[word] x_5037
	    val x_5050: Word8.word vector * word option = 
	       (x_5042, x_5049)
	    val x_5051: exn = 
	       SysErr x_5050
	    val x_5052: 'a_3291 = 
	       raise x_5051
	 in
	    x_5052
	 end
   val 'a raiseSys_0: word -> 'a = 
      let
      in
	 raiseSys ('a)
      end
   exception Unordered
   val rec 
      fromInt: word -> IEEEReal.rounding_mode = 
	 fn x_5053: word => 
	 let
	    val x_5054: word * word = 
	       (x_5053, FE_TONEAREST)
	    val x_5055: bool = 
	       = (word) x_5054
	    val x_5056: IEEEReal.rounding_mode = 
	       case x_5055 of
	       true => 
		  let
		     val x_5072: IEEEReal.rounding_mode = 
			TO_NEAREST
		  in
		     x_5072
		  end
	       false => 
		  let
		     val x_5057: word * word = 
			(x_5053, FE_DOWNWARD)
		     val x_5058: bool = 
			= (word) x_5057
		     val x_5059: IEEEReal.rounding_mode = 
			case x_5058 of
			true => 
			   let
			      val x_5071: IEEEReal.rounding_mode = 
				 TO_NEGINF
			   in
			      x_5071
			   end
			false => 
			   let
			      val x_5060: word * word = 
				 (x_5053, FE_UPWARD)
			      val x_5061: bool = 
				 = (word) x_5060
			      val x_5062: IEEEReal.rounding_mode = 
				 case x_5061 of
				 true => 
				    let
				       val x_5070: IEEEReal.rounding_mode = 
					  TO_POSINF
				    in
				       x_5070
				    end
				 false => 
				    let
				       val x_5063: word * word = 
					  (x_5053, FE_TOWARDZERO)
				       val x_5064: bool = 
					  = (word) x_5063
				       val x_5065: IEEEReal.rounding_mode = 
					  case x_5064 of
					  true => 
					     let
						val x_5069: IEEEReal.rounding_mode = 
						   TO_ZERO
					     in
						x_5069
					     end
					  false => 
					     let
						val x_5066: Word8.word vector = 
						   "IEEEReal.RoundingMode.fromInt"
						val x_5067: exn = 
						   Fail x_5066
						val x_5068: IEEEReal.rounding_mode = 
						   raise x_5067
					     in
						x_5068
					     end
				    in
				       x_5065
				    end
			   in
			      x_5062
			   end
		  in
		     x_5059
		  end
	 in
	    x_5056
	 end
   val rec 
      setRoundingMode: IEEEReal.rounding_mode -> unit = 
	 fn x_5073: IEEEReal.rounding_mode => 
	 let
	    val x_5074: word = 
	       case x_5073 of
	       TO_NEAREST => 
		  let
		  in
		     FE_TONEAREST
		  end
	       TO_POSINF => 
		  let
		  in
		     FE_UPWARD
		  end
	       TO_ZERO => 
		  let
		  in
		     FE_TOWARDZERO
		  end
	       TO_NEGINF => 
		  let
		  in
		     FE_DOWNWARD
		  end
	    val x_5075: word * word = 
	       (x_5074, FE_NOSUPPORT)
	    val x_5076: bool = 
	       = (word) x_5075
	    val x_5077: word = 
	       case x_5076 of
	       true => 
		  let
		     val x_5078: Word8.word vector = 
			"IEEEReal rounding mode not supported"
		     val x_5079: exn = 
			Fail x_5078
		     val x_5080: word = 
			raise x_5079
		  in
		     x_5080
		  end
	       false => 
		  let
		  in
		     x_5074
		  end
	    val x_5081: word = 
	       IEEEReal_setRoundingMode (x_5077)
	    val x_5082: word = 
	       0x0
	    val x_5083: word * word = 
	       (x_5081, x_5082)
	    val x_5084: bool = 
	       = (word) x_5083
	    val x_5085: unit = 
	       case x_5084 of
	       true => 
		  let
		     val x_5088: unit = 
			()
		  in
		     x_5088
		  end
	       false => 
		  let
		     val x_5086: exn = 
			raiseSys_0 (exn) inval
		     val x_5087: unit = 
			raise x_5086
		  in
		     x_5087
		  end
	 in
	    x_5085
	 end
   val x_5089: (word -> IEEEReal.rounding_mode) * (unit -> word) = 
      (fromInt, getRoundingMode)
   val getRoundingMode: unit -> IEEEReal.rounding_mode = 
      o_1 (unit, IEEEReal.rounding_mode, word) x_5089
   val rec 'a 
      withRoundingMode: IEEEReal.rounding_mode * (unit -> 'a) -> 'a = 
	 fn x_5090: IEEEReal.rounding_mode * (unit -> 'a) => 
	 let
	    val th: unit -> 'a = 
	       #1 x_5090
	    val m: IEEEReal.rounding_mode = 
	       #0 x_5090
	    val x_5091: unit = 
	       ()
	    val m': IEEEReal.rounding_mode = 
	       getRoundingMode x_5091
	    val x_5092: unit = 
	       setRoundingMode m
	    val x_5093: unit = 
	       ()
	    val res: 'a = 
	       th x_5093
	    val x_5094: unit = 
	       setRoundingMode m'
	 in
	    res
	 end
   val 'a withRoundingMode_0: IEEEReal.rounding_mode * (unit -> 'a) -> 'a = 
      let
      in
	 withRoundingMode ('a)
      end
   val realSize: word = 
      sextdFromInt32ToInt32 realSize
   val exponentBias: word = 
      sextdFromInt32ToInt32 exponentBias
   val precision: word = 
      sextdFromInt32ToInt32 precision
   val x_5095: word = 
      sextdFromInt32ToWord32 realSize
   val x_5096: word * word = 
      (x_5095, one)
   val exponentSignificandBits: word = 
      - x_5096
   val x_5097: word = 
      sextdFromInt32ToWord32 precision
   val x_5098: word * word = 
      (x_5097, one)
   val significandBits: word = 
      - x_5098
   val x_5099: word * word = 
      (exponentSignificandBits, significandBits)
   val exponentBits: word = 
      - x_5099
   val mkMask: word -> word = 
      fn x_5100: word => 
      let
	 val x_5101: word = 
	    notb zero
	 val x_5102: word * word = 
	    (x_5101, x_5100)
	 val x_5103: word = 
	    << x_5102
	 val x_5104: word = 
	    notb x_5103
      in
	 x_5104
      end
   val x_5105: word = 
      mkMask one
   val x_5106: word * word = 
      (x_5105, exponentSignificandBits)
   val signMask: word = 
      << x_5106
   val x_5107: word = 
      mkMask exponentBits
   val x_5108: word * word = 
      (x_5107, significandBits)
   val exponentMask: word = 
      << x_5108
   val significandMask: word = 
      mkMask significandBits
   val class: Real32.real -> IEEEReal.float_class = 
      fn x_5109: Real32.real => 
      let
	 val w: word = 
	    castToWord x_5109
	 val x_5110: word * word = 
	    (w, exponentMask)
	 val x_5111: word = 
	    andb x_5110
	 val x_5112: word * word = 
	    (x_5111, exponentMask)
	 val x_5113: bool = 
	    = (word) x_5112
	 val x_5114: IEEEReal.float_class = 
	    case x_5113 of
	    true => 
	       let
		  val x_5128: word * word = 
		     (w, significandMask)
		  val x_5129: word = 
		     andb x_5128
		  val x_5130: word * word = 
		     (x_5129, zero)
		  val x_5131: bool = 
		     = (word) x_5130
		  val x_5132: IEEEReal.float_class = 
		     case x_5131 of
		     true => 
			let
			   val x_5134: IEEEReal.float_class = 
			      INF
			in
			   x_5134
			end
		     false => 
			let
			   val x_5133: IEEEReal.float_class = 
			      NAN
			in
			   x_5133
			end
	       in
		  x_5132
	       end
	    false => 
	       let
		  val x_5115: word * word = 
		     (w, exponentMask)
		  val x_5116: word = 
		     andb x_5115
		  val x_5117: word * word = 
		     (x_5116, zero)
		  val x_5118: bool = 
		     = (word) x_5117
		  val x_5119: IEEEReal.float_class = 
		     case x_5118 of
		     true => 
			let
			   val x_5121: word * word = 
			      (w, significandMask)
			   val x_5122: word = 
			      andb x_5121
			   val x_5123: word * word = 
			      (x_5122, zero)
			   val x_5124: bool = 
			      = (word) x_5123
			   val x_5125: IEEEReal.float_class = 
			      case x_5124 of
			      true => 
				 let
				    val x_5127: IEEEReal.float_class = 
				       ZERO
				 in
				    x_5127
				 end
			      false => 
				 let
				    val x_5126: IEEEReal.float_class = 
				       SUBNORMAL
				 in
				    x_5126
				 end
			in
			   x_5125
			end
		     false => 
			let
			   val x_5120: IEEEReal.float_class = 
			      NORMAL
			in
			   x_5120
			end
	       in
		  x_5119
	       end
      in
	 x_5114
      end
   val toBits: Real32.real -> word * bool * word = 
      fn x_5135: Real32.real => 
      let
	 val w: word = 
	    castToWord x_5135
	 val x_5136: word * word = 
	    (w, significandMask)
	 val significand: word = 
	    andb x_5136
	 val x_5137: word * word = 
	    (w, exponentMask)
	 val x_5138: word = 
	    andb x_5137
	 val x_5139: word * word = 
	    (x_5138, significandBits)
	 val exponent: word = 
	    >> x_5139
	 val x_5140: word * word = 
	    (w, signMask)
	 val x_5141: word = 
	    andb x_5140
	 val x_5142: word * word = 
	    (x_5141, signMask)
	 val sign: bool = 
	    = (word) x_5142
	 val x_5143: word * bool * word = 
	    (exponent, sign, significand)
      in
	 x_5143
      end
   val rec 'a 
      make: ('a -> Real32.real) * word * (Real32.real -> 'a)
	    -> (IEEEReal.rounding_mode -> 'a -> Real32.real)
	       * (Real32.real -> 'a) = 
	 fn x_5144: ('a -> Real32.real) * word * (Real32.real -> 'a) => 
	 let
	    val toRealUnsafe: Real32.real -> 'a = 
	       #2 x_5144
	    val other: word = 
	       #1 x_5144
	    val fromRealUnsafe: 'a -> Real32.real = 
	       #0 x_5144
	    val x_5145: word * word = 
	       (precision, other)
	    val x_5146: bool = 
	       = (word) x_5145
	    val x_5147: (IEEEReal.rounding_mode -> 'a -> Real32.real)
			* (Real32.real -> 'a) = 
	       case x_5146 of
	       true => 
		  let
		     val x_5158: IEEEReal.rounding_mode -> 'a -> Real32.real = 
			fn x_5159: IEEEReal.rounding_mode => 
			let
			in
			   fromRealUnsafe
			end
		     val x_5160: (IEEEReal.rounding_mode -> 'a -> Real32.real)
				 * (Real32.real -> 'a) = 
			(x_5158, toRealUnsafe)
		  in
		     x_5160
		  end
	       false => 
		  let
		     val x_5148: IEEEReal.rounding_mode -> 'a -> Real32.real = 
			fn x_5149: IEEEReal.rounding_mode => 
			let
			   val x_5150: 'a -> Real32.real = 
			      fn x_5151: 'a => 
			      let
				 val x_5152: unit -> Real32.real = 
				    fn x_5153: unit => 
				    let
				       val x_5154: Real32.real = 
					  fromRealUnsafe x_5151
				    in
				       x_5154
				    end
				 val x_5155: IEEEReal.rounding_mode
					     * (unit -> Real32.real) = 
				    (x_5149, x_5152)
				 val x_5156: Real32.real = 
				    withRoundingMode_0 (Real32.real) x_5155
			      in
				 x_5156
			      end
			in
			   x_5150
			end
		     val x_5157: (IEEEReal.rounding_mode -> 'a -> Real32.real)
				 * (Real32.real -> 'a) = 
			(x_5148, toRealUnsafe)
		  in
		     x_5157
		  end
	 in
	    x_5147
	 end
   val x_5161: (Real32.real -> Real32.real)
	       * word
	       * (Real32.real -> Real32.real) = 
      (fromReal32Unsafe, precision, toReal32Unsafe)
   val x_5162: (IEEEReal.rounding_mode -> Real32.real -> Real32.real)
	       * (Real32.real -> Real32.real) = 
      make (Real32.real) x_5161
   val zero: Real32.real = 
      castFromWord zero
   val x_5163: word = 
      sextdFromInt32ToWord32 exponentBias
   val x_5164: word * word = 
      (x_5163, one)
   val x_5165: word = 
      - x_5164
   val x_5166: word * word = 
      (x_5165, significandBits)
   val x_5167: word = 
      << x_5166
   val half: Real32.real = 
      castFromWord x_5167
   val x_5168: word = 
      sextdFromInt32ToWord32 exponentBias
   val x_5169: word * word = 
      (x_5168, significandBits)
   val x_5170: word = 
      << x_5169
   val one: Real32.real = 
      castFromWord x_5170
   val x_5171: word * bool * word -> bool = 
      fn x_5172: word * bool * word => 
      let
	 val x_5173: bool = 
	    #1 x_5172
      in
	 x_5173
      end
   val x_5174: (word * bool * word -> bool)
	       * (Real32.real -> word * bool * word) = 
      (x_5171, toBits)
   val signBit: Real32.real -> bool = 
      o_1 (Real32.real, bool, word * bool * word) x_5174
   exception Bad
   val x_5175: unit -> word ref = 
      fn x_5176: unit => 
      let
	 val x_5177: word = 
	    0x0
	 val x_5178: word ref = 
	    Ref_ref[word] (x_5177)
      in
	 x_5178
      end
   val one: word ref One.t = 
      make_0 (word ref) x_5175
   val rec 'a_3327 
      safeConvert: IEEEReal.rounding_mode
		   * (Real32.real -> 'a_3327)
		   * Real32.real
		   -> 'a_3327 = 
	 fn x_5179: IEEEReal.rounding_mode
		    * (Real32.real -> 'a_3327)
		    * Real32.real => 
	 let
	    val x: Real32.real = 
	       #2 x_5179
	    val cvt: Real32.real -> 'a_3327 = 
	       #1 x_5179
	    val m: IEEEReal.rounding_mode = 
	       #0 x_5179
	    val x_5180: 'a_3327 = 
	       case m of
	       TO_POSINF => 
		  let
		     val x_5192: Real32.real = 
			Real32_realCeil (x)
		     val x_5193: 'a_3327 = 
			cvt x_5192
		  in
		     x_5193
		  end
	       TO_NEAREST => 
		  let
		     val x_5185: IEEEReal.rounding_mode = 
			TO_NEAREST
		     val x_5186: unit -> Real32.real = 
			fn x_5187: unit => 
			let
			   val x_5188: Real32.real = 
			      round x
			in
			   x_5188
			end
		     val x_5189: IEEEReal.rounding_mode * (unit -> Real32.real) = 
			(x_5185, x_5186)
		     val x_5190: Real32.real = 
			withRoundingMode_0 (Real32.real) x_5189
		     val x_5191: 'a_3327 = 
			cvt x_5190
		  in
		     x_5191
		  end
	       TO_ZERO => 
		  let
		     val x_5183: Real32.real = 
			Real32_realTrunc (x)
		     val x_5184: 'a_3327 = 
			cvt x_5183
		  in
		     x_5184
		  end
	       TO_NEGINF => 
		  let
		     val x_5181: Real32.real = 
			Real32_realFloor (x)
		     val x_5182: 'a_3327 = 
			cvt x_5181
		  in
		     x_5182
		  end
	 in
	    x_5180
	 end
   val rec 'a 
      make: ('a -> Real32.real)
	    * ((word -> 'a) * 'a * word)
	    * (Real32.real -> 'a)
	    -> ('a -> Real32.real)
	       * (IEEEReal.rounding_mode -> Real32.real -> 'a) = 
	 fn x_5194: ('a -> Real32.real)
		    * ((word -> 'a) * 'a * word)
		    * (Real32.real -> 'a) => 
	 let
	    val toIntUnsafe: Real32.real -> 'a = 
	       #2 x_5194
	    val other: (word -> 'a) * 'a * word = 
	       #1 x_5194
	    val fromIntUnsafe: 'a -> Real32.real = 
	       #0 x_5194
	    val x_5195: word = 
	       #2 other
	    val x_5196: word * word = 
	       (precision, x_5195)
	    val x_5197: bool = 
	       < x_5196
	    val x_5198: IEEEReal.rounding_mode -> Real32.real -> 'a = 
	       case x_5197 of
	       true => 
		  let
		     val x_5254: word = 
			#2 other
		     val x_5255: word * word = 
			(x_5254, precision)
		     val x_5256: word = 
			-! x_5255
		     val x_5257: word = 
			0x1
		     val x_5258: word * word = 
			(x_5256, x_5257)
		     val trim: word = 
			-! x_5258
		     val x_5259: word -> 'a = 
			#0 other
		     val x_5260: word = 
			sextdFromInt32ToWord32 trim
		     val maxInt': 'a = 
			x_5259 x_5260
		     val x_5261: 'a = 
			#1 other
		     val maxInt: Real32.real = 
			fromIntUnsafe maxInt'
		     val minInt: Real32.real = 
			fromIntUnsafe x_5261
		     val x_5262: IEEEReal.rounding_mode -> Real32.real -> 'a = 
			fn x_5263: IEEEReal.rounding_mode => 
			let
			   val x_5264: Real32.real -> 'a = 
			      fn x_5265: Real32.real => 
			      let
				 val x_5266: Real32.real * Real32.real = 
				    (minInt, x_5265)
				 val x_5267: bool = 
				    <= x_5266
				 val x_5268: 'a = 
				    case x_5267 of
				    true => 
				       let
					  val x_5276: Real32.real * Real32.real = 
					     (x_5265, maxInt)
					  val x_5277: bool = 
					     <= x_5276
					  val x_5278: 'a = 
					     case x_5277 of
					     true => 
						let
						   val x_5281: IEEEReal.rounding_mode
							       * (Real32.real
								  -> 'a)
							       * Real32.real = 
						      (x_5263,
						       toIntUnsafe,
						       x_5265)
						   val x_5282: 'a = 
						      safeConvert ('a) x_5281
						in
						   x_5282
						end
					     false => 
						let
						   val x_5279: exn = 
						      Overflow
						   val x_5280: 'a = 
						      raise x_5279
						in
						   x_5280
						end
				       in
					  x_5278
				       end
				    false => 
				       let
					  val x_5269: Real32.real * Real32.real = 
					     (x_5265, minInt)
					  val x_5270: bool = 
					     < x_5269
					  val x_5271: 'a = 
					     case x_5270 of
					     true => 
						let
						   val x_5274: exn = 
						      Overflow
						   val x_5275: 'a = 
						      raise x_5274
						in
						   x_5275
						end
					     false => 
						let
						   val x_5272: exn = 
						      Domain
						   val x_5273: 'a = 
						      raise x_5272
						in
						   x_5273
						end
				       in
					  x_5271
				       end
			      in
				 x_5268
			      end
			in
			   x_5264
			end
		  in
		     x_5262
		  end
	       false => 
		  let
		     val x_5199: word -> 'a = 
			#0 other
		     val x_5200: word = 
			0x0
		     val maxInt': 'a = 
			x_5199 x_5200
		     val x_5201: 'a = 
			#1 other
		     val maxInt: Real32.real = 
			fromIntUnsafe maxInt'
		     val minInt: Real32.real = 
			fromIntUnsafe x_5201
		     val x_5202: IEEEReal.rounding_mode -> Real32.real -> 'a = 
			fn x_5203: IEEEReal.rounding_mode => 
			let
			   val x_5204: Real32.real -> 'a = 
			      fn x_5205: Real32.real => 
			      let
				 val x_5206: Real32.real * Real32.real = 
				    (minInt, x_5205)
				 val x_5207: bool = 
				    <= x_5206
				 val x_5208: 'a = 
				    case x_5207 of
				    true => 
				       let
					  val x_5232: Real32.real * Real32.real = 
					     (x_5205, maxInt)
					  val x_5233: bool = 
					     <= x_5232
					  val x_5234: 'a = 
					     case x_5233 of
					     true => 
						let
						   val x_5252: IEEEReal.rounding_mode
							       * (Real32.real
								  -> 'a)
							       * Real32.real = 
						      (x_5203,
						       toIntUnsafe,
						       x_5205)
						   val x_5253: 'a = 
						      safeConvert ('a) x_5252
						in
						   x_5253
						end
					     false => 
						let
						   val x_5235: Real32.real
							       * Real32.real = 
						      (maxInt, one)
						   val x_5236: Real32.real = 
						      + x_5235
						   val x_5237: Real32.real
							       * Real32.real = 
						      (x_5205, x_5236)
						   val x_5238: bool = 
						      < x_5237
						   val x_5239: 'a = 
						      case x_5238 of
						      true => 
							 let
							    val x_5242: 'a = 
							       case x_5203 of
							       TO_NEGINF => 
								  let
								  in
								     maxInt'
								  end
							       TO_ZERO => 
								  let
								  in
								     maxInt'
								  end
							       TO_NEAREST => 
								  let
								     val x_5245: Real32.real
										 * Real32.real = 
									(x_5205,
									 maxInt)
								     val x_5246: Real32.real = 
									- x_5245
								     val x_5247: Real32.real
										 * Real32.real = 
									(x_5246,
									 half)
								     val x_5248: bool = 
									>= x_5247
								     val x_5249: 'a = 
									case x_5248 of
									true => 
									   let
									      val x_5250: exn = 
										 Overflow
									      val x_5251: 'a = 
										 raise x_5250
									   in
									      x_5251
									   end
									false => 
									   let
									   in
									      maxInt'
									   end
								  in
								     x_5249
								  end
							       TO_POSINF => 
								  let
								     val x_5243: exn = 
									Overflow
								     val x_5244: 'a = 
									raise x_5243
								  in
								     x_5244
								  end
							 in
							    x_5242
							 end
						      false => 
							 let
							    val x_5240: exn = 
							       Overflow
							    val x_5241: 'a = 
							       raise x_5240
							 in
							    x_5241
							 end
						in
						   x_5239
						end
				       in
					  x_5234
				       end
				    false => 
				       let
					  val x_5209: Real32.real * Real32.real = 
					     (x_5205, minInt)
					  val x_5210: bool = 
					     < x_5209
					  val x_5211: 'a = 
					     case x_5210 of
					     true => 
						let
						   val x_5214: Real32.real
							       * Real32.real = 
						      (minInt, one)
						   val x_5215: Real32.real = 
						      - x_5214
						   val x_5216: Real32.real
							       * Real32.real = 
						      (x_5215, x_5205)
						   val x_5217: bool = 
						      < x_5216
						   val x_5218: 'a = 
						      case x_5217 of
						      true => 
							 let
							    val x_5221: 'a = 
							       case x_5203 of
							       TO_NEGINF => 
								  let
								     val x_5230: exn = 
									Overflow
								     val x_5231: 'a = 
									raise x_5230
								  in
								     x_5231
								  end
							       TO_ZERO => 
								  let
								  in
								     x_5201
								  end
							       TO_NEAREST => 
								  let
								     val x_5222: Real32.real
										 * Real32.real = 
									(x_5205,
									 minInt)
								     val x_5223: Real32.real = 
									- x_5222
								     val x_5224: Real32.real = 
									~ half
								     val x_5225: Real32.real
										 * Real32.real = 
									(x_5223,
									 x_5224)
								     val x_5226: bool = 
									< x_5225
								     val x_5227: 'a = 
									case x_5226 of
									true => 
									   let
									      val x_5228: exn = 
										 Overflow
									      val x_5229: 'a = 
										 raise x_5228
									   in
									      x_5229
									   end
									false => 
									   let
									   in
									      x_5201
									   end
								  in
								     x_5227
								  end
							       TO_POSINF => 
								  let
								  in
								     x_5201
								  end
							 in
							    x_5221
							 end
						      false => 
							 let
							    val x_5219: exn = 
							       Overflow
							    val x_5220: 'a = 
							       raise x_5219
							 in
							    x_5220
							 end
						in
						   x_5218
						end
					     false => 
						let
						   val x_5212: exn = 
						      Domain
						   val x_5213: 'a = 
						      raise x_5212
						in
						   x_5213
						end
				       in
					  x_5211
				       end
			      in
				 x_5208
			      end
			in
			   x_5204
			end
		  in
		     x_5202
		  end
	    val x_5283: ('a -> Real32.real)
			* (IEEEReal.rounding_mode -> Real32.real -> 'a) = 
	       (fromIntUnsafe, x_5198)
	 in
	    x_5283
	 end
   val x_5284: word -> Word8.word = 
      fn x_5285: word => 
      let
	 val x_5286: Word8.word * word = 
	    (maxInt', x_5285)
	 val x_5287: Word8.word = 
	    >> x_5286
	 val x_5288: Word8.word * word = 
	    (x_5287, x_5285)
	 val x_5289: Word8.word = 
	    << x_5288
      in
	 x_5289
      end
   val x_5290: (word -> Word8.word) * Word8.word * word = 
      (x_5284, minInt', precision')
   val x_5291: (Word8.word -> Real32.real)
	       * ((word -> Word8.word) * Word8.word * word)
	       * (Real32.real -> Word8.word) = 
      (fromInt8Unsafe, x_5290, toInt8Unsafe)
   val x_5292: (Word8.word -> Real32.real)
	       * (IEEEReal.rounding_mode -> Real32.real -> Word8.word) = 
      make (Word8.word) x_5291
   val x_5293: word -> Word16.word = 
      fn x_5294: word => 
      let
	 val x_5295: Word16.word * word = 
	    (maxInt', x_5294)
	 val x_5296: Word16.word = 
	    >> x_5295
	 val x_5297: Word16.word * word = 
	    (x_5296, x_5294)
	 val x_5298: Word16.word = 
	    << x_5297
      in
	 x_5298
      end
   val x_5299: (word -> Word16.word) * Word16.word * word = 
      (x_5293, minInt', precision')
   val x_5300: (Word16.word -> Real32.real)
	       * ((word -> Word16.word) * Word16.word * word)
	       * (Real32.real -> Word16.word) = 
      (fromInt16Unsafe, x_5299, toInt16Unsafe)
   val x_5301: (Word16.word -> Real32.real)
	       * (IEEEReal.rounding_mode -> Real32.real -> Word16.word) = 
      make (Word16.word) x_5300
   val x_5302: word -> word = 
      fn x_5303: word => 
      let
	 val x_5304: word * word = 
	    (maxInt', x_5303)
	 val x_5305: word = 
	    >> x_5304
	 val x_5306: word * word = 
	    (x_5305, x_5303)
	 val x_5307: word = 
	    << x_5306
      in
	 x_5307
      end
   val x_5308: (word -> word) * word * word = 
      (x_5302, minInt', precision')
   val x_5309: (word -> Real32.real)
	       * ((word -> word) * word * word)
	       * (Real32.real -> word) = 
      (fromInt32Unsafe, x_5308, toInt32Unsafe)
   val x_5310: (word -> Real32.real)
	       * (IEEEReal.rounding_mode -> Real32.real -> word) = 
      make (word) x_5309
   val x_5311: word -> Word64.word = 
      fn x_5312: word => 
      let
	 val x_5313: Word64.word * word = 
	    (maxInt', x_5312)
	 val x_5314: Word64.word = 
	    >> x_5313
	 val x_5315: Word64.word * word = 
	    (x_5314, x_5312)
	 val x_5316: Word64.word = 
	    << x_5315
      in
	 x_5316
      end
   val x_5317: (word -> Word64.word) * Word64.word * word = 
      (x_5311, minInt', precision')
   val x_5318: (Word64.word -> Real32.real)
	       * ((word -> Word64.word) * Word64.word * word)
	       * (Real32.real -> Word64.word) = 
      (fromInt64Unsafe, x_5317, toInt64Unsafe)
   val x_5319: (Word64.word -> Real32.real)
	       * (IEEEReal.rounding_mode -> Real32.real -> Word64.word) = 
      make (Word64.word) x_5318
   val rec 'a 
      make: ('a -> Real32.real)
	    * ((word -> 'a) * word * 'a)
	    * (Real32.real -> 'a)
	    -> ('a -> Real32.real)
	       * (IEEEReal.rounding_mode -> Real32.real -> 'a) = 
	 fn x_5320: ('a -> Real32.real)
		    * ((word -> 'a) * word * 'a)
		    * (Real32.real -> 'a) => 
	 let
	    val toWordUnsafe: Real32.real -> 'a = 
	       #2 x_5320
	    val other: (word -> 'a) * word * 'a = 
	       #1 x_5320
	    val fromWordUnsafe: 'a -> Real32.real = 
	       #0 x_5320
	    val x_5321: word = 
	       #1 other
	    val x_5322: word * word = 
	       (precision, x_5321)
	    val x_5323: bool = 
	       <= x_5322
	    val x_5324: IEEEReal.rounding_mode -> Real32.real -> 'a = 
	       case x_5323 of
	       true => 
		  let
		     val x_5378: word = 
			#1 other
		     val x_5379: word * word = 
			(x_5378, precision)
		     val trim: word = 
			-! x_5379
		     val x_5380: word -> 'a = 
			#0 other
		     val x_5381: word = 
			sextdFromInt32ToWord32 trim
		     val maxWord': 'a = 
			x_5380 x_5381
		     val maxWord: Real32.real = 
			fromWordUnsafe maxWord'
		     val x_5382: 'a = 
			#2 other
		     val x_5383: IEEEReal.rounding_mode -> Real32.real -> 'a = 
			fn x_5384: IEEEReal.rounding_mode => 
			let
			   val x_5385: Real32.real -> 'a = 
			      fn x_5386: Real32.real => 
			      let
				 val x_5387: IEEEReal.float_class = 
				    class x_5386
				 val x_5388: 'a = 
				    case x_5387 of
				    INF => 
				       let
					  val x_5391: exn = 
					     Overflow
					  val x_5392: 'a = 
					     raise x_5391
				       in
					  x_5392
				       end
				    NAN => 
				       let
					  val x_5389: exn = 
					     Domain
					  val x_5390: 'a = 
					     raise x_5389
				       in
					  x_5390
				       end
				      _ => let
					      val x_5393: Real32.real
							  * Real32.real = 
						 (zero, x_5386)
					      val x_5394: bool = 
						 <= x_5393
					      val x_5395: 'a = 
						 case x_5394 of
						 true => 
						    let
						       val x_5411: Real32.real
								   * Real32.real = 
							  (x_5386, maxWord)
						       val x_5412: bool = 
							  <= x_5411
						       val x_5413: 'a = 
							  case x_5412 of
							  true => 
							     let
								val x_5416: IEEEReal.rounding_mode
									    * (Real32.real
									       -> 'a)
									    * Real32.real = 
								   (x_5384,
								    toWordUnsafe,
								    x_5386)
								val x_5417: 'a = 
								   safeConvert ('a) x_5416
							     in
								x_5417
							     end
							  false => 
							     let
								val x_5414: exn = 
								   Overflow
								val x_5415: 'a = 
								   raise x_5414
							     in
								x_5415
							     end
						    in
						       x_5413
						    end
						 false => 
						    let
						       val x_5396: Real32.real = 
							  ~ one
						       val x_5397: Real32.real
								   * Real32.real = 
							  (x_5386, x_5396)
						       val x_5398: bool = 
							  > x_5397
						       val x_5399: 'a = 
							  case x_5398 of
							  true => 
							     let
								val x_5402: 'a = 
								   case x_5384 of
								   TO_NEGINF => 
								      let
									 val x_5409: exn = 
									    Overflow
									 val x_5410: 'a = 
									    raise x_5409
								      in
									 x_5410
								      end
								   TO_ZERO => 
								      let
								      in
									 x_5382
								      end
								   TO_NEAREST => 
								      let
									 val x_5403: Real32.real = 
									    ~ half
									 val x_5404: Real32.real
										     * Real32.real = 
									    (x_5386,
									     x_5403)
									 val x_5405: bool = 
									    < x_5404
									 val x_5406: 'a = 
									    case x_5405 of
									    true => 
									       let
										  val x_5407: exn = 
										     Overflow
										  val x_5408: 'a = 
										     raise x_5407
									       in
										  x_5408
									       end
									    false => 
									       let
									       in
										  x_5382
									       end
								      in
									 x_5406
								      end
								   TO_POSINF => 
								      let
								      in
									 x_5382
								      end
							     in
								x_5402
							     end
							  false => 
							     let
								val x_5400: exn = 
								   Overflow
								val x_5401: 'a = 
								   raise x_5400
							     in
								x_5401
							     end
						    in
						       x_5399
						    end
					   in
					      x_5395
					   end
			      in
				 x_5388
			      end
			in
			   x_5385
			end
		  in
		     x_5383
		  end
	       false => 
		  let
		     val x_5325: word -> 'a = 
			#0 other
		     val x_5326: word = 
			0x0
		     val maxWord': 'a = 
			x_5325 x_5326
		     val maxWord: Real32.real = 
			fromWordUnsafe maxWord'
		     val x_5327: 'a = 
			#2 other
		     val x_5328: IEEEReal.rounding_mode -> Real32.real -> 'a = 
			fn x_5329: IEEEReal.rounding_mode => 
			let
			   val x_5330: Real32.real -> 'a = 
			      fn x_5331: Real32.real => 
			      let
				 val x_5332: IEEEReal.float_class = 
				    class x_5331
				 val x_5333: 'a = 
				    case x_5332 of
				    INF => 
				       let
					  val x_5336: exn = 
					     Overflow
					  val x_5337: 'a = 
					     raise x_5336
				       in
					  x_5337
				       end
				    NAN => 
				       let
					  val x_5334: exn = 
					     Domain
					  val x_5335: 'a = 
					     raise x_5334
				       in
					  x_5335
				       end
				      _ => let
					      val x_5338: Real32.real
							  * Real32.real = 
						 (zero, x_5331)
					      val x_5339: bool = 
						 <= x_5338
					      val x_5340: 'a = 
						 case x_5339 of
						 true => 
						    let
						       val x_5356: Real32.real
								   * Real32.real = 
							  (x_5331, maxWord)
						       val x_5357: bool = 
							  <= x_5356
						       val x_5358: 'a = 
							  case x_5357 of
							  true => 
							     let
								val x_5376: IEEEReal.rounding_mode
									    * (Real32.real
									       -> 'a)
									    * Real32.real = 
								   (x_5329,
								    toWordUnsafe,
								    x_5331)
								val x_5377: 'a = 
								   safeConvert ('a) x_5376
							     in
								x_5377
							     end
							  false => 
							     let
								val x_5359: Real32.real
									    * Real32.real = 
								   (maxWord, one)
								val x_5360: Real32.real = 
								   + x_5359
								val x_5361: Real32.real
									    * Real32.real = 
								   (x_5331,
								    x_5360)
								val x_5362: bool = 
								   < x_5361
								val x_5363: 'a = 
								   case x_5362 of
								   true => 
								      let
									 val x_5366: 'a = 
									    case x_5329 of
									    TO_NEGINF => 
									       let
									       in
										  maxWord'
									       end
									    TO_ZERO => 
									       let
									       in
										  maxWord'
									       end
									    TO_NEAREST => 
									       let
										  val x_5369: Real32.real
											      * Real32.real = 
										     (x_5331,
										      maxWord)
										  val x_5370: Real32.real = 
										     - x_5369
										  val x_5371: Real32.real
											      * Real32.real = 
										     (x_5370,
										      half)
										  val x_5372: bool = 
										     >= x_5371
										  val x_5373: 'a = 
										     case x_5372 of
										     true => 
											let
											   val x_5374: exn = 
											      Overflow
											   val x_5375: 'a = 
											      raise x_5374
											in
											   x_5375
											end
										     false => 
											let
											in
											   maxWord'
											end
									       in
										  x_5373
									       end
									    TO_POSINF => 
									       let
										  val x_5367: exn = 
										     Overflow
										  val x_5368: 'a = 
										     raise x_5367
									       in
										  x_5368
									       end
								      in
									 x_5366
								      end
								   false => 
								      let
									 val x_5364: exn = 
									    Overflow
									 val x_5365: 'a = 
									    raise x_5364
								      in
									 x_5365
								      end
							     in
								x_5363
							     end
						    in
						       x_5358
						    end
						 false => 
						    let
						       val x_5341: Real32.real = 
							  ~ one
						       val x_5342: Real32.real
								   * Real32.real = 
							  (x_5331, x_5341)
						       val x_5343: bool = 
							  > x_5342
						       val x_5344: 'a = 
							  case x_5343 of
							  true => 
							     let
								val x_5347: 'a = 
								   case x_5329 of
								   TO_NEGINF => 
								      let
									 val x_5354: exn = 
									    Overflow
									 val x_5355: 'a = 
									    raise x_5354
								      in
									 x_5355
								      end
								   TO_ZERO => 
								      let
								      in
									 x_5327
								      end
								   TO_NEAREST => 
								      let
									 val x_5348: Real32.real = 
									    ~ half
									 val x_5349: Real32.real
										     * Real32.real = 
									    (x_5331,
									     x_5348)
									 val x_5350: bool = 
									    < x_5349
									 val x_5351: 'a = 
									    case x_5350 of
									    true => 
									       let
										  val x_5352: exn = 
										     Overflow
										  val x_5353: 'a = 
										     raise x_5352
									       in
										  x_5353
									       end
									    false => 
									       let
									       in
										  x_5327
									       end
								      in
									 x_5351
								      end
								   TO_POSINF => 
								      let
								      in
									 x_5327
								      end
							     in
								x_5347
							     end
							  false => 
							     let
								val x_5345: exn = 
								   Overflow
								val x_5346: 'a = 
								   raise x_5345
							     in
								x_5346
							     end
						    in
						       x_5344
						    end
					   in
					      x_5340
					   end
			      in
				 x_5333
			      end
			in
			   x_5330
			end
		  in
		     x_5328
		  end
	    val x_5418: ('a -> Real32.real)
			* (IEEEReal.rounding_mode -> Real32.real -> 'a) = 
	       (fromWordUnsafe, x_5324)
	 in
	    x_5418
	 end
   val x_5419: word -> Word8.word = 
      fn x_5420: word => 
      let
	 val x_5421: Word8.word * word = 
	    (maxWord', x_5420)
	 val x_5422: Word8.word = 
	    >> x_5421
	 val x_5423: Word8.word * word = 
	    (x_5422, x_5420)
	 val x_5424: Word8.word = 
	    << x_5423
      in
	 x_5424
      end
   val x_5425: (word -> Word8.word) * word * Word8.word = 
      (x_5419, wordSize, zero)
   val x_5426: (Word8.word -> Real32.real)
	       * ((word -> Word8.word) * word * Word8.word)
	       * (Real32.real -> Word8.word) = 
      (fromWord8Unsafe, x_5425, toWord8Unsafe)
   val x_5427: (Word8.word -> Real32.real)
	       * (IEEEReal.rounding_mode -> Real32.real -> Word8.word) = 
      make (Word8.word) x_5426
   val x_5428: word -> Word16.word = 
      fn x_5429: word => 
      let
	 val x_5430: Word16.word * word = 
	    (maxWord', x_5429)
	 val x_5431: Word16.word = 
	    >> x_5430
	 val x_5432: Word16.word * word = 
	    (x_5431, x_5429)
	 val x_5433: Word16.word = 
	    << x_5432
      in
	 x_5433
      end
   val x_5434: (word -> Word16.word) * word * Word16.word = 
      (x_5428, wordSize, zero)
   val x_5435: (Word16.word -> Real32.real)
	       * ((word -> Word16.word) * word * Word16.word)
	       * (Real32.real -> Word16.word) = 
      (fromWord16Unsafe, x_5434, toWord16Unsafe)
   val x_5436: (Word16.word -> Real32.real)
	       * (IEEEReal.rounding_mode -> Real32.real -> Word16.word) = 
      make (Word16.word) x_5435
   val x_5437: word -> word = 
      fn x_5438: word => 
      let
	 val x_5439: word * word = 
	    (maxWord', x_5438)
	 val x_5440: word = 
	    >> x_5439
	 val x_5441: word * word = 
	    (x_5440, x_5438)
	 val x_5442: word = 
	    << x_5441
      in
	 x_5442
      end
   val x_5443: (word -> word) * word * word = 
      (x_5437, wordSize, zero)
   val x_5444: (word -> Real32.real)
	       * ((word -> word) * word * word)
	       * (Real32.real -> word) = 
      (fromWord32Unsafe, x_5443, toWord32Unsafe)
   val x_5445: (word -> Real32.real)
	       * (IEEEReal.rounding_mode -> Real32.real -> word) = 
      make (word) x_5444
   val x_5446: word -> Word64.word = 
      fn x_5447: word => 
      let
	 val x_5448: Word64.word * word = 
	    (maxWord', x_5447)
	 val x_5449: Word64.word = 
	    >> x_5448
	 val x_5450: Word64.word * word = 
	    (x_5449, x_5447)
	 val x_5451: Word64.word = 
	    << x_5450
      in
	 x_5451
      end
   val x_5452: (word -> Word64.word) * word * Word64.word = 
      (x_5446, wordSize, zero)
   val x_5453: (Word64.word -> Real32.real)
	       * ((word -> Word64.word) * word * Word64.word)
	       * (Real32.real -> Word64.word) = 
      (fromWord64Unsafe, x_5452, toWord64Unsafe)
   val x_5454: (Word64.word -> Real32.real)
	       * (IEEEReal.rounding_mode -> Real32.real -> Word64.word) = 
      make (Word64.word) x_5453
   val realSize: word = 
      sextdFromInt32ToInt32 realSize
   val exponentBias: word = 
      sextdFromInt32ToInt32 exponentBias
   val precision: word = 
      sextdFromInt32ToInt32 precision
   val x_5455: word = 
      sextdFromInt32ToWord32 realSize
   val x_5456: word * word = 
      (x_5455, one)
   val exponentSignificandBits: word = 
      - x_5456
   val x_5457: word = 
      sextdFromInt32ToWord32 precision
   val x_5458: word * word = 
      (x_5457, one)
   val significandBits: word = 
      - x_5458
   val x_5459: word * word = 
      (exponentSignificandBits, significandBits)
   val exponentBits: word = 
      - x_5459
   val mkMask: word -> Word64.word = 
      fn x_5460: word => 
      let
	 val x_5461: Word64.word = 
	    notb zero
	 val x_5462: Word64.word * word = 
	    (x_5461, x_5460)
	 val x_5463: Word64.word = 
	    << x_5462
	 val x_5464: Word64.word = 
	    notb x_5463
      in
	 x_5464
      end
   val x_5465: Word64.word = 
      mkMask one
   val x_5466: Word64.word * word = 
      (x_5465, exponentSignificandBits)
   val signMask: Word64.word = 
      << x_5466
   val x_5467: Word64.word = 
      mkMask exponentBits
   val x_5468: Word64.word * word = 
      (x_5467, significandBits)
   val exponentMask: Word64.word = 
      << x_5468
   val significandMask: Word64.word = 
      mkMask significandBits
   val class: real -> IEEEReal.float_class = 
      fn x_5469: real => 
      let
	 val w: Word64.word = 
	    castToWord x_5469
	 val x_5470: Word64.word * Word64.word = 
	    (w, exponentMask)
	 val x_5471: Word64.word = 
	    andb x_5470
	 val x_5472: Word64.word * Word64.word = 
	    (x_5471, exponentMask)
	 val x_5473: bool = 
	    = (Word64.word) x_5472
	 val x_5474: IEEEReal.float_class = 
	    case x_5473 of
	    true => 
	       let
		  val x_5488: Word64.word * Word64.word = 
		     (w, significandMask)
		  val x_5489: Word64.word = 
		     andb x_5488
		  val x_5490: Word64.word * Word64.word = 
		     (x_5489, zero)
		  val x_5491: bool = 
		     = (Word64.word) x_5490
		  val x_5492: IEEEReal.float_class = 
		     case x_5491 of
		     true => 
			let
			   val x_5494: IEEEReal.float_class = 
			      INF
			in
			   x_5494
			end
		     false => 
			let
			   val x_5493: IEEEReal.float_class = 
			      NAN
			in
			   x_5493
			end
	       in
		  x_5492
	       end
	    false => 
	       let
		  val x_5475: Word64.word * Word64.word = 
		     (w, exponentMask)
		  val x_5476: Word64.word = 
		     andb x_5475
		  val x_5477: Word64.word * Word64.word = 
		     (x_5476, zero)
		  val x_5478: bool = 
		     = (Word64.word) x_5477
		  val x_5479: IEEEReal.float_class = 
		     case x_5478 of
		     true => 
			let
			   val x_5481: Word64.word * Word64.word = 
			      (w, significandMask)
			   val x_5482: Word64.word = 
			      andb x_5481
			   val x_5483: Word64.word * Word64.word = 
			      (x_5482, zero)
			   val x_5484: bool = 
			      = (Word64.word) x_5483
			   val x_5485: IEEEReal.float_class = 
			      case x_5484 of
			      true => 
				 let
				    val x_5487: IEEEReal.float_class = 
				       ZERO
				 in
				    x_5487
				 end
			      false => 
				 let
				    val x_5486: IEEEReal.float_class = 
				       SUBNORMAL
				 in
				    x_5486
				 end
			in
			   x_5485
			end
		     false => 
			let
			   val x_5480: IEEEReal.float_class = 
			      NORMAL
			in
			   x_5480
			end
	       in
		  x_5479
	       end
      in
	 x_5474
      end
   val toBits: real -> Word64.word * bool * Word64.word = 
      fn x_5495: real => 
      let
	 val w: Word64.word = 
	    castToWord x_5495
	 val x_5496: Word64.word * Word64.word = 
	    (w, significandMask)
	 val significand: Word64.word = 
	    andb x_5496
	 val x_5497: Word64.word * Word64.word = 
	    (w, exponentMask)
	 val x_5498: Word64.word = 
	    andb x_5497
	 val x_5499: Word64.word * word = 
	    (x_5498, significandBits)
	 val exponent: Word64.word = 
	    >> x_5499
	 val x_5500: Word64.word * Word64.word = 
	    (w, signMask)
	 val x_5501: Word64.word = 
	    andb x_5500
	 val x_5502: Word64.word * Word64.word = 
	    (x_5501, signMask)
	 val sign: bool = 
	    = (Word64.word) x_5502
	 val x_5503: Word64.word * bool * Word64.word = 
	    (exponent, sign, significand)
      in
	 x_5503
      end
   val rec 'a 
      make: ('a -> real) * word * (real -> 'a)
	    -> (IEEEReal.rounding_mode -> 'a -> real) * (real -> 'a) = 
	 fn x_5504: ('a -> real) * word * (real -> 'a) => 
	 let
	    val toRealUnsafe: real -> 'a = 
	       #2 x_5504
	    val other: word = 
	       #1 x_5504
	    val fromRealUnsafe: 'a -> real = 
	       #0 x_5504
	    val x_5505: word * word = 
	       (precision, other)
	    val x_5506: bool = 
	       = (word) x_5505
	    val x_5507: (IEEEReal.rounding_mode -> 'a -> real) * (real -> 'a) = 
	       case x_5506 of
	       true => 
		  let
		     val x_5518: IEEEReal.rounding_mode -> 'a -> real = 
			fn x_5519: IEEEReal.rounding_mode => 
			let
			in
			   fromRealUnsafe
			end
		     val x_5520: (IEEEReal.rounding_mode -> 'a -> real)
				 * (real -> 'a) = 
			(x_5518, toRealUnsafe)
		  in
		     x_5520
		  end
	       false => 
		  let
		     val x_5508: IEEEReal.rounding_mode -> 'a -> real = 
			fn x_5509: IEEEReal.rounding_mode => 
			let
			   val x_5510: 'a -> real = 
			      fn x_5511: 'a => 
			      let
				 val x_5512: unit -> real = 
				    fn x_5513: unit => 
				    let
				       val x_5514: real = 
					  fromRealUnsafe x_5511
				    in
				       x_5514
				    end
				 val x_5515: IEEEReal.rounding_mode
					     * (unit -> real) = 
				    (x_5509, x_5512)
				 val x_5516: real = 
				    withRoundingMode_0 (real) x_5515
			      in
				 x_5516
			      end
			in
			   x_5510
			end
		     val x_5517: (IEEEReal.rounding_mode -> 'a -> real)
				 * (real -> 'a) = 
			(x_5508, toRealUnsafe)
		  in
		     x_5517
		  end
	 in
	    x_5507
	 end
   val x_5521: (Real32.real -> real) * word * (real -> Real32.real) = 
      (fromReal32Unsafe, precision, toReal32Unsafe)
   val x_5522: (IEEEReal.rounding_mode -> Real32.real -> real)
	       * (real -> Real32.real) = 
      make (Real32.real) x_5521
   val zero: real = 
      castFromWord zero
   val x_5523: Word64.word = 
      sextdFromInt32ToWord64 exponentBias
   val x_5524: Word64.word * Word64.word = 
      (x_5523, one)
   val x_5525: Word64.word = 
      - x_5524
   val x_5526: Word64.word * word = 
      (x_5525, significandBits)
   val x_5527: Word64.word = 
      << x_5526
   val half: real = 
      castFromWord x_5527
   val x_5528: Word64.word = 
      sextdFromInt32ToWord64 exponentBias
   val x_5529: Word64.word * word = 
      (x_5528, significandBits)
   val x_5530: Word64.word = 
      << x_5529
   val one: real = 
      castFromWord x_5530
   val x_5531: Word64.word * bool * Word64.word -> bool = 
      fn x_5532: Word64.word * bool * Word64.word => 
      let
	 val x_5533: bool = 
	    #1 x_5532
      in
	 x_5533
      end
   val x_5534: (Word64.word * bool * Word64.word -> bool)
	       * (real -> Word64.word * bool * Word64.word) = 
      (x_5531, toBits)
   val signBit: real -> bool = 
      o_1 (real, bool, Word64.word * bool * Word64.word) x_5534
   exception Bad
   val x_5535: unit -> word ref = 
      fn x_5536: unit => 
      let
	 val x_5537: word = 
	    0x0
	 val x_5538: word ref = 
	    Ref_ref[word] (x_5537)
      in
	 x_5538
      end
   val one: word ref One.t = 
      make_0 (word ref) x_5535
   val rec 'a_3349 
      safeConvert: IEEEReal.rounding_mode * (real -> 'a_3349) * real -> 'a_3349 = 
	 fn x_5539: IEEEReal.rounding_mode * (real -> 'a_3349) * real => 
	 let
	    val x: real = 
	       #2 x_5539
	    val cvt: real -> 'a_3349 = 
	       #1 x_5539
	    val m: IEEEReal.rounding_mode = 
	       #0 x_5539
	    val x_5540: 'a_3349 = 
	       case m of
	       TO_POSINF => 
		  let
		     val x_5552: real = 
			Real64_realCeil (x)
		     val x_5553: 'a_3349 = 
			cvt x_5552
		  in
		     x_5553
		  end
	       TO_NEAREST => 
		  let
		     val x_5545: IEEEReal.rounding_mode = 
			TO_NEAREST
		     val x_5546: unit -> real = 
			fn x_5547: unit => 
			let
			   val x_5548: real = 
			      round x
			in
			   x_5548
			end
		     val x_5549: IEEEReal.rounding_mode * (unit -> real) = 
			(x_5545, x_5546)
		     val x_5550: real = 
			withRoundingMode_0 (real) x_5549
		     val x_5551: 'a_3349 = 
			cvt x_5550
		  in
		     x_5551
		  end
	       TO_ZERO => 
		  let
		     val x_5543: real = 
			Real64_realTrunc (x)
		     val x_5544: 'a_3349 = 
			cvt x_5543
		  in
		     x_5544
		  end
	       TO_NEGINF => 
		  let
		     val x_5541: real = 
			Real64_realFloor (x)
		     val x_5542: 'a_3349 = 
			cvt x_5541
		  in
		     x_5542
		  end
	 in
	    x_5540
	 end
   val rec 'a 
      make: ('a -> real) * ((word -> 'a) * 'a * word) * (real -> 'a)
	    -> ('a -> real) * (IEEEReal.rounding_mode -> real -> 'a) = 
	 fn x_5554: ('a -> real) * ((word -> 'a) * 'a * word) * (real -> 'a) => 
	 let
	    val toIntUnsafe: real -> 'a = 
	       #2 x_5554
	    val other: (word -> 'a) * 'a * word = 
	       #1 x_5554
	    val fromIntUnsafe: 'a -> real = 
	       #0 x_5554
	    val x_5555: word = 
	       #2 other
	    val x_5556: word * word = 
	       (precision, x_5555)
	    val x_5557: bool = 
	       < x_5556
	    val x_5558: IEEEReal.rounding_mode -> real -> 'a = 
	       case x_5557 of
	       true => 
		  let
		     val x_5614: word = 
			#2 other
		     val x_5615: word * word = 
			(x_5614, precision)
		     val x_5616: word = 
			-! x_5615
		     val x_5617: word = 
			0x1
		     val x_5618: word * word = 
			(x_5616, x_5617)
		     val trim: word = 
			-! x_5618
		     val x_5619: word -> 'a = 
			#0 other
		     val x_5620: word = 
			sextdFromInt32ToWord32 trim
		     val maxInt': 'a = 
			x_5619 x_5620
		     val x_5621: 'a = 
			#1 other
		     val maxInt: real = 
			fromIntUnsafe maxInt'
		     val minInt: real = 
			fromIntUnsafe x_5621
		     val x_5622: IEEEReal.rounding_mode -> real -> 'a = 
			fn x_5623: IEEEReal.rounding_mode => 
			let
			   val x_5624: real -> 'a = 
			      fn x_5625: real => 
			      let
				 val x_5626: real * real = 
				    (minInt, x_5625)
				 val x_5627: bool = 
				    <= x_5626
				 val x_5628: 'a = 
				    case x_5627 of
				    true => 
				       let
					  val x_5636: real * real = 
					     (x_5625, maxInt)
					  val x_5637: bool = 
					     <= x_5636
					  val x_5638: 'a = 
					     case x_5637 of
					     true => 
						let
						   val x_5641: IEEEReal.rounding_mode
							       * (real -> 'a)
							       * real = 
						      (x_5623,
						       toIntUnsafe,
						       x_5625)
						   val x_5642: 'a = 
						      safeConvert ('a) x_5641
						in
						   x_5642
						end
					     false => 
						let
						   val x_5639: exn = 
						      Overflow
						   val x_5640: 'a = 
						      raise x_5639
						in
						   x_5640
						end
				       in
					  x_5638
				       end
				    false => 
				       let
					  val x_5629: real * real = 
					     (x_5625, minInt)
					  val x_5630: bool = 
					     < x_5629
					  val x_5631: 'a = 
					     case x_5630 of
					     true => 
						let
						   val x_5634: exn = 
						      Overflow
						   val x_5635: 'a = 
						      raise x_5634
						in
						   x_5635
						end
					     false => 
						let
						   val x_5632: exn = 
						      Domain
						   val x_5633: 'a = 
						      raise x_5632
						in
						   x_5633
						end
				       in
					  x_5631
				       end
			      in
				 x_5628
			      end
			in
			   x_5624
			end
		  in
		     x_5622
		  end
	       false => 
		  let
		     val x_5559: word -> 'a = 
			#0 other
		     val x_5560: word = 
			0x0
		     val maxInt': 'a = 
			x_5559 x_5560
		     val x_5561: 'a = 
			#1 other
		     val maxInt: real = 
			fromIntUnsafe maxInt'
		     val minInt: real = 
			fromIntUnsafe x_5561
		     val x_5562: IEEEReal.rounding_mode -> real -> 'a = 
			fn x_5563: IEEEReal.rounding_mode => 
			let
			   val x_5564: real -> 'a = 
			      fn x_5565: real => 
			      let
				 val x_5566: real * real = 
				    (minInt, x_5565)
				 val x_5567: bool = 
				    <= x_5566
				 val x_5568: 'a = 
				    case x_5567 of
				    true => 
				       let
					  val x_5592: real * real = 
					     (x_5565, maxInt)
					  val x_5593: bool = 
					     <= x_5592
					  val x_5594: 'a = 
					     case x_5593 of
					     true => 
						let
						   val x_5612: IEEEReal.rounding_mode
							       * (real -> 'a)
							       * real = 
						      (x_5563,
						       toIntUnsafe,
						       x_5565)
						   val x_5613: 'a = 
						      safeConvert ('a) x_5612
						in
						   x_5613
						end
					     false => 
						let
						   val x_5595: real * real = 
						      (maxInt, one)
						   val x_5596: real = 
						      + x_5595
						   val x_5597: real * real = 
						      (x_5565, x_5596)
						   val x_5598: bool = 
						      < x_5597
						   val x_5599: 'a = 
						      case x_5598 of
						      true => 
							 let
							    val x_5602: 'a = 
							       case x_5563 of
							       TO_NEGINF => 
								  let
								  in
								     maxInt'
								  end
							       TO_ZERO => 
								  let
								  in
								     maxInt'
								  end
							       TO_NEAREST => 
								  let
								     val x_5605: real
										 * real = 
									(x_5565,
									 maxInt)
								     val x_5606: real = 
									- x_5605
								     val x_5607: real
										 * real = 
									(x_5606,
									 half)
								     val x_5608: bool = 
									>= x_5607
								     val x_5609: 'a = 
									case x_5608 of
									true => 
									   let
									      val x_5610: exn = 
										 Overflow
									      val x_5611: 'a = 
										 raise x_5610
									   in
									      x_5611
									   end
									false => 
									   let
									   in
									      maxInt'
									   end
								  in
								     x_5609
								  end
							       TO_POSINF => 
								  let
								     val x_5603: exn = 
									Overflow
								     val x_5604: 'a = 
									raise x_5603
								  in
								     x_5604
								  end
							 in
							    x_5602
							 end
						      false => 
							 let
							    val x_5600: exn = 
							       Overflow
							    val x_5601: 'a = 
							       raise x_5600
							 in
							    x_5601
							 end
						in
						   x_5599
						end
				       in
					  x_5594
				       end
				    false => 
				       let
					  val x_5569: real * real = 
					     (x_5565, minInt)
					  val x_5570: bool = 
					     < x_5569
					  val x_5571: 'a = 
					     case x_5570 of
					     true => 
						let
						   val x_5574: real * real = 
						      (minInt, one)
						   val x_5575: real = 
						      - x_5574
						   val x_5576: real * real = 
						      (x_5575, x_5565)
						   val x_5577: bool = 
						      < x_5576
						   val x_5578: 'a = 
						      case x_5577 of
						      true => 
							 let
							    val x_5581: 'a = 
							       case x_5563 of
							       TO_NEGINF => 
								  let
								     val x_5590: exn = 
									Overflow
								     val x_5591: 'a = 
									raise x_5590
								  in
								     x_5591
								  end
							       TO_ZERO => 
								  let
								  in
								     x_5561
								  end
							       TO_NEAREST => 
								  let
								     val x_5582: real
										 * real = 
									(x_5565,
									 minInt)
								     val x_5583: real = 
									- x_5582
								     val x_5584: real = 
									~ half
								     val x_5585: real
										 * real = 
									(x_5583,
									 x_5584)
								     val x_5586: bool = 
									< x_5585
								     val x_5587: 'a = 
									case x_5586 of
									true => 
									   let
									      val x_5588: exn = 
										 Overflow
									      val x_5589: 'a = 
										 raise x_5588
									   in
									      x_5589
									   end
									false => 
									   let
									   in
									      x_5561
									   end
								  in
								     x_5587
								  end
							       TO_POSINF => 
								  let
								  in
								     x_5561
								  end
							 in
							    x_5581
							 end
						      false => 
							 let
							    val x_5579: exn = 
							       Overflow
							    val x_5580: 'a = 
							       raise x_5579
							 in
							    x_5580
							 end
						in
						   x_5578
						end
					     false => 
						let
						   val x_5572: exn = 
						      Domain
						   val x_5573: 'a = 
						      raise x_5572
						in
						   x_5573
						end
				       in
					  x_5571
				       end
			      in
				 x_5568
			      end
			in
			   x_5564
			end
		  in
		     x_5562
		  end
	    val x_5643: ('a -> real) * (IEEEReal.rounding_mode -> real -> 'a) = 
	       (fromIntUnsafe, x_5558)
	 in
	    x_5643
	 end
   val x_5644: word -> Word8.word = 
      fn x_5645: word => 
      let
	 val x_5646: Word8.word * word = 
	    (maxInt', x_5645)
	 val x_5647: Word8.word = 
	    >> x_5646
	 val x_5648: Word8.word * word = 
	    (x_5647, x_5645)
	 val x_5649: Word8.word = 
	    << x_5648
      in
	 x_5649
      end
   val x_5650: (word -> Word8.word) * Word8.word * word = 
      (x_5644, minInt', precision')
   val x_5651: (Word8.word -> real)
	       * ((word -> Word8.word) * Word8.word * word)
	       * (real -> Word8.word) = 
      (fromInt8Unsafe, x_5650, toInt8Unsafe)
   val x_5652: (Word8.word -> real)
	       * (IEEEReal.rounding_mode -> real -> Word8.word) = 
      make (Word8.word) x_5651
   val x_5653: word -> Word16.word = 
      fn x_5654: word => 
      let
	 val x_5655: Word16.word * word = 
	    (maxInt', x_5654)
	 val x_5656: Word16.word = 
	    >> x_5655
	 val x_5657: Word16.word * word = 
	    (x_5656, x_5654)
	 val x_5658: Word16.word = 
	    << x_5657
      in
	 x_5658
      end
   val x_5659: (word -> Word16.word) * Word16.word * word = 
      (x_5653, minInt', precision')
   val x_5660: (Word16.word -> real)
	       * ((word -> Word16.word) * Word16.word * word)
	       * (real -> Word16.word) = 
      (fromInt16Unsafe, x_5659, toInt16Unsafe)
   val x_5661: (Word16.word -> real)
	       * (IEEEReal.rounding_mode -> real -> Word16.word) = 
      make (Word16.word) x_5660
   val x_5662: word -> word = 
      fn x_5663: word => 
      let
	 val x_5664: word * word = 
	    (maxInt', x_5663)
	 val x_5665: word = 
	    >> x_5664
	 val x_5666: word * word = 
	    (x_5665, x_5663)
	 val x_5667: word = 
	    << x_5666
      in
	 x_5667
      end
   val x_5668: (word -> word) * word * word = 
      (x_5662, minInt', precision')
   val x_5669: (word -> real) * ((word -> word) * word * word) * (real -> word) = 
      (fromInt32Unsafe, x_5668, toInt32Unsafe)
   val x_5670: (word -> real) * (IEEEReal.rounding_mode -> real -> word) = 
      make (word) x_5669
   val x_5671: word -> Word64.word = 
      fn x_5672: word => 
      let
	 val x_5673: Word64.word * word = 
	    (maxInt', x_5672)
	 val x_5674: Word64.word = 
	    >> x_5673
	 val x_5675: Word64.word * word = 
	    (x_5674, x_5672)
	 val x_5676: Word64.word = 
	    << x_5675
      in
	 x_5676
      end
   val x_5677: (word -> Word64.word) * Word64.word * word = 
      (x_5671, minInt', precision')
   val x_5678: (Word64.word -> real)
	       * ((word -> Word64.word) * Word64.word * word)
	       * (real -> Word64.word) = 
      (fromInt64Unsafe, x_5677, toInt64Unsafe)
   val x_5679: (Word64.word -> real)
	       * (IEEEReal.rounding_mode -> real -> Word64.word) = 
      make (Word64.word) x_5678
   val rec 'a 
      make: ('a -> real) * ((word -> 'a) * word * 'a) * (real -> 'a)
	    -> ('a -> real) * (IEEEReal.rounding_mode -> real -> 'a) = 
	 fn x_5680: ('a -> real) * ((word -> 'a) * word * 'a) * (real -> 'a) => 
	 let
	    val toWordUnsafe: real -> 'a = 
	       #2 x_5680
	    val other: (word -> 'a) * word * 'a = 
	       #1 x_5680
	    val fromWordUnsafe: 'a -> real = 
	       #0 x_5680
	    val x_5681: word = 
	       #1 other
	    val x_5682: word * word = 
	       (precision, x_5681)
	    val x_5683: bool = 
	       <= x_5682
	    val x_5684: IEEEReal.rounding_mode -> real -> 'a = 
	       case x_5683 of
	       true => 
		  let
		     val x_5738: word = 
			#1 other
		     val x_5739: word * word = 
			(x_5738, precision)
		     val trim: word = 
			-! x_5739
		     val x_5740: word -> 'a = 
			#0 other
		     val x_5741: word = 
			sextdFromInt32ToWord32 trim
		     val maxWord': 'a = 
			x_5740 x_5741
		     val maxWord: real = 
			fromWordUnsafe maxWord'
		     val x_5742: 'a = 
			#2 other
		     val x_5743: IEEEReal.rounding_mode -> real -> 'a = 
			fn x_5744: IEEEReal.rounding_mode => 
			let
			   val x_5745: real -> 'a = 
			      fn x_5746: real => 
			      let
				 val x_5747: IEEEReal.float_class = 
				    class x_5746
				 val x_5748: 'a = 
				    case x_5747 of
				    INF => 
				       let
					  val x_5751: exn = 
					     Overflow
					  val x_5752: 'a = 
					     raise x_5751
				       in
					  x_5752
				       end
				    NAN => 
				       let
					  val x_5749: exn = 
					     Domain
					  val x_5750: 'a = 
					     raise x_5749
				       in
					  x_5750
				       end
				      _ => let
					      val x_5753: real * real = 
						 (zero, x_5746)
					      val x_5754: bool = 
						 <= x_5753
					      val x_5755: 'a = 
						 case x_5754 of
						 true => 
						    let
						       val x_5771: real * real = 
							  (x_5746, maxWord)
						       val x_5772: bool = 
							  <= x_5771
						       val x_5773: 'a = 
							  case x_5772 of
							  true => 
							     let
								val x_5776: IEEEReal.rounding_mode
									    * (real
									       -> 'a)
									    * real = 
								   (x_5744,
								    toWordUnsafe,
								    x_5746)
								val x_5777: 'a = 
								   safeConvert ('a) x_5776
							     in
								x_5777
							     end
							  false => 
							     let
								val x_5774: exn = 
								   Overflow
								val x_5775: 'a = 
								   raise x_5774
							     in
								x_5775
							     end
						    in
						       x_5773
						    end
						 false => 
						    let
						       val x_5756: real = 
							  ~ one
						       val x_5757: real * real = 
							  (x_5746, x_5756)
						       val x_5758: bool = 
							  > x_5757
						       val x_5759: 'a = 
							  case x_5758 of
							  true => 
							     let
								val x_5762: 'a = 
								   case x_5744 of
								   TO_NEGINF => 
								      let
									 val x_5769: exn = 
									    Overflow
									 val x_5770: 'a = 
									    raise x_5769
								      in
									 x_5770
								      end
								   TO_ZERO => 
								      let
								      in
									 x_5742
								      end
								   TO_NEAREST => 
								      let
									 val x_5763: real = 
									    ~ half
									 val x_5764: real
										     * real = 
									    (x_5746,
									     x_5763)
									 val x_5765: bool = 
									    < x_5764
									 val x_5766: 'a = 
									    case x_5765 of
									    true => 
									       let
										  val x_5767: exn = 
										     Overflow
										  val x_5768: 'a = 
										     raise x_5767
									       in
										  x_5768
									       end
									    false => 
									       let
									       in
										  x_5742
									       end
								      in
									 x_5766
								      end
								   TO_POSINF => 
								      let
								      in
									 x_5742
								      end
							     in
								x_5762
							     end
							  false => 
							     let
								val x_5760: exn = 
								   Overflow
								val x_5761: 'a = 
								   raise x_5760
							     in
								x_5761
							     end
						    in
						       x_5759
						    end
					   in
					      x_5755
					   end
			      in
				 x_5748
			      end
			in
			   x_5745
			end
		  in
		     x_5743
		  end
	       false => 
		  let
		     val x_5685: word -> 'a = 
			#0 other
		     val x_5686: word = 
			0x0
		     val maxWord': 'a = 
			x_5685 x_5686
		     val maxWord: real = 
			fromWordUnsafe maxWord'
		     val x_5687: 'a = 
			#2 other
		     val x_5688: IEEEReal.rounding_mode -> real -> 'a = 
			fn x_5689: IEEEReal.rounding_mode => 
			let
			   val x_5690: real -> 'a = 
			      fn x_5691: real => 
			      let
				 val x_5692: IEEEReal.float_class = 
				    class x_5691
				 val x_5693: 'a = 
				    case x_5692 of
				    INF => 
				       let
					  val x_5696: exn = 
					     Overflow
					  val x_5697: 'a = 
					     raise x_5696
				       in
					  x_5697
				       end
				    NAN => 
				       let
					  val x_5694: exn = 
					     Domain
					  val x_5695: 'a = 
					     raise x_5694
				       in
					  x_5695
				       end
				      _ => let
					      val x_5698: real * real = 
						 (zero, x_5691)
					      val x_5699: bool = 
						 <= x_5698
					      val x_5700: 'a = 
						 case x_5699 of
						 true => 
						    let
						       val x_5716: real * real = 
							  (x_5691, maxWord)
						       val x_5717: bool = 
							  <= x_5716
						       val x_5718: 'a = 
							  case x_5717 of
							  true => 
							     let
								val x_5736: IEEEReal.rounding_mode
									    * (real
									       -> 'a)
									    * real = 
								   (x_5689,
								    toWordUnsafe,
								    x_5691)
								val x_5737: 'a = 
								   safeConvert ('a) x_5736
							     in
								x_5737
							     end
							  false => 
							     let
								val x_5719: real
									    * real = 
								   (maxWord, one)
								val x_5720: real = 
								   + x_5719
								val x_5721: real
									    * real = 
								   (x_5691,
								    x_5720)
								val x_5722: bool = 
								   < x_5721
								val x_5723: 'a = 
								   case x_5722 of
								   true => 
								      let
									 val x_5726: 'a = 
									    case x_5689 of
									    TO_NEGINF => 
									       let
									       in
										  maxWord'
									       end
									    TO_ZERO => 
									       let
									       in
										  maxWord'
									       end
									    TO_NEAREST => 
									       let
										  val x_5729: real
											      * real = 
										     (x_5691,
										      maxWord)
										  val x_5730: real = 
										     - x_5729
										  val x_5731: real
											      * real = 
										     (x_5730,
										      half)
										  val x_5732: bool = 
										     >= x_5731
										  val x_5733: 'a = 
										     case x_5732 of
										     true => 
											let
											   val x_5734: exn = 
											      Overflow
											   val x_5735: 'a = 
											      raise x_5734
											in
											   x_5735
											end
										     false => 
											let
											in
											   maxWord'
											end
									       in
										  x_5733
									       end
									    TO_POSINF => 
									       let
										  val x_5727: exn = 
										     Overflow
										  val x_5728: 'a = 
										     raise x_5727
									       in
										  x_5728
									       end
								      in
									 x_5726
								      end
								   false => 
								      let
									 val x_5724: exn = 
									    Overflow
									 val x_5725: 'a = 
									    raise x_5724
								      in
									 x_5725
								      end
							     in
								x_5723
							     end
						    in
						       x_5718
						    end
						 false => 
						    let
						       val x_5701: real = 
							  ~ one
						       val x_5702: real * real = 
							  (x_5691, x_5701)
						       val x_5703: bool = 
							  > x_5702
						       val x_5704: 'a = 
							  case x_5703 of
							  true => 
							     let
								val x_5707: 'a = 
								   case x_5689 of
								   TO_NEGINF => 
								      let
									 val x_5714: exn = 
									    Overflow
									 val x_5715: 'a = 
									    raise x_5714
								      in
									 x_5715
								      end
								   TO_ZERO => 
								      let
								      in
									 x_5687
								      end
								   TO_NEAREST => 
								      let
									 val x_5708: real = 
									    ~ half
									 val x_5709: real
										     * real = 
									    (x_5691,
									     x_5708)
									 val x_5710: bool = 
									    < x_5709
									 val x_5711: 'a = 
									    case x_5710 of
									    true => 
									       let
										  val x_5712: exn = 
										     Overflow
										  val x_5713: 'a = 
										     raise x_5712
									       in
										  x_5713
									       end
									    false => 
									       let
									       in
										  x_5687
									       end
								      in
									 x_5711
								      end
								   TO_POSINF => 
								      let
								      in
									 x_5687
								      end
							     in
								x_5707
							     end
							  false => 
							     let
								val x_5705: exn = 
								   Overflow
								val x_5706: 'a = 
								   raise x_5705
							     in
								x_5706
							     end
						    in
						       x_5704
						    end
					   in
					      x_5700
					   end
			      in
				 x_5693
			      end
			in
			   x_5690
			end
		  in
		     x_5688
		  end
	    val x_5778: ('a -> real) * (IEEEReal.rounding_mode -> real -> 'a) = 
	       (fromWordUnsafe, x_5684)
	 in
	    x_5778
	 end
   val x_5779: word -> Word8.word = 
      fn x_5780: word => 
      let
	 val x_5781: Word8.word * word = 
	    (maxWord', x_5780)
	 val x_5782: Word8.word = 
	    >> x_5781
	 val x_5783: Word8.word * word = 
	    (x_5782, x_5780)
	 val x_5784: Word8.word = 
	    << x_5783
      in
	 x_5784
      end
   val x_5785: (word -> Word8.word) * word * Word8.word = 
      (x_5779, wordSize, zero)
   val x_5786: (Word8.word -> real)
	       * ((word -> Word8.word) * word * Word8.word)
	       * (real -> Word8.word) = 
      (fromWord8Unsafe, x_5785, toWord8Unsafe)
   val x_5787: (Word8.word -> real)
	       * (IEEEReal.rounding_mode -> real -> Word8.word) = 
      make (Word8.word) x_5786
   val x_5788: word -> Word16.word = 
      fn x_5789: word => 
      let
	 val x_5790: Word16.word * word = 
	    (maxWord', x_5789)
	 val x_5791: Word16.word = 
	    >> x_5790
	 val x_5792: Word16.word * word = 
	    (x_5791, x_5789)
	 val x_5793: Word16.word = 
	    << x_5792
      in
	 x_5793
      end
   val x_5794: (word -> Word16.word) * word * Word16.word = 
      (x_5788, wordSize, zero)
   val x_5795: (Word16.word -> real)
	       * ((word -> Word16.word) * word * Word16.word)
	       * (real -> Word16.word) = 
      (fromWord16Unsafe, x_5794, toWord16Unsafe)
   val x_5796: (Word16.word -> real)
	       * (IEEEReal.rounding_mode -> real -> Word16.word) = 
      make (Word16.word) x_5795
   val x_5797: word -> word = 
      fn x_5798: word => 
      let
	 val x_5799: word * word = 
	    (maxWord', x_5798)
	 val x_5800: word = 
	    >> x_5799
	 val x_5801: word * word = 
	    (x_5800, x_5798)
	 val x_5802: word = 
	    << x_5801
      in
	 x_5802
      end
   val x_5803: (word -> word) * word * word = 
      (x_5797, wordSize, zero)
   val x_5804: (word -> real) * ((word -> word) * word * word) * (real -> word) = 
      (fromWord32Unsafe, x_5803, toWord32Unsafe)
   val x_5805: (word -> real) * (IEEEReal.rounding_mode -> real -> word) = 
      make (word) x_5804
   val x_5806: word -> Word64.word = 
      fn x_5807: word => 
      let
	 val x_5808: Word64.word * word = 
	    (maxWord', x_5807)
	 val x_5809: Word64.word = 
	    >> x_5808
	 val x_5810: Word64.word * word = 
	    (x_5809, x_5807)
	 val x_5811: Word64.word = 
	    << x_5810
      in
	 x_5811
      end
   val x_5812: (word -> Word64.word) * word * Word64.word = 
      (x_5806, wordSize, zero)
   val x_5813: (Word64.word -> real)
	       * ((word -> Word64.word) * word * Word64.word)
	       * (real -> Word64.word) = 
      (fromWord64Unsafe, x_5812, toWord64Unsafe)
   val x_5814: (Word64.word -> real)
	       * (IEEEReal.rounding_mode -> real -> Word64.word) = 
      make (Word64.word) x_5813
   val x_5815: (word -> Real32.real) * (word -> word) = 
      (castFromWord, bswap)
   val x_5816: word -> Real32.real = 
      o_1 (word, Real32.real, word) x_5815
   val x_5817: (word -> Real32.real) * (Word8.word array * Word64.word -> word) = 
      (x_5816, subArr)
   val subArrRev: Word8.word array * Word64.word -> Real32.real = 
      o_1 (Word8.word array * Word64.word, Real32.real, word) x_5817
   val x_5818: (word -> Real32.real) * (word -> word) = 
      (castFromWord, bswap)
   val x_5819: word -> Real32.real = 
      o_1 (word, Real32.real, word) x_5818
   val x_5820: (word -> Real32.real) * (Word8.word vector * Word64.word -> word) = 
      (x_5819, subVec)
   val subVecRev: Word8.word vector * Word64.word -> Real32.real = 
      o_1 (Word8.word vector * Word64.word, Real32.real, word) x_5820
   val x_5821: (word -> Real32.real) * (Word8.word array * Word64.word -> word) = 
      (castFromWord, subArr)
   val subArr: Word8.word array * Word64.word -> Real32.real = 
      o_1 (Word8.word array * Word64.word, Real32.real, word) x_5821
   val x_5822: (word -> Real32.real) * (Word8.word vector * Word64.word -> word) = 
      (castFromWord, subVec)
   val subVec: Word8.word vector * Word64.word -> Real32.real = 
      o_1 (Word8.word vector * Word64.word, Real32.real, word) x_5822
   exception Time
   exception Date
   exception BlockingNotSupported
   exception ClosedStream
   exception Io of exn * Word8.word vector * Word8.word vector
   val x_5823: exn -> Word8.word vector option = 
      fn x_5824: exn => 
      let
	 val x_5825: Word8.word vector option = 
	    case x_5824 of
	    Io x_5826: exn * Word8.word vector * Word8.word vector => 
	       let
		  val x_5827: Word8.word vector = 
		     #2 x_5826
		  val x_5828: Word8.word vector = 
		     #1 x_5826
		  val x_5829: exn = 
		     #0 x_5826
		  val x_5830: Word8.word vector list = 
		     nil[Word8.word vector]
		  val x_5831: Word8.word vector = 
		     exnMessage x_5829
		  val x_5832: Word8.word vector * Word8.word vector list = 
		     (x_5831, x_5830)
		  val x_5833: Word8.word vector list = 
		     ::[Word8.word vector] x_5832
		  val x_5834: Word8.word vector = 
		     "" failed with "
		  val x_5835: Word8.word vector * Word8.word vector list = 
		     (x_5834, x_5833)
		  val x_5836: Word8.word vector list = 
		     ::[Word8.word vector] x_5835
		  val x_5837: Word8.word vector * Word8.word vector list = 
		     (x_5827, x_5836)
		  val x_5838: Word8.word vector list = 
		     ::[Word8.word vector] x_5837
		  val x_5839: Word8.word vector = 
		     " ""
		  val x_5840: Word8.word vector * Word8.word vector list = 
		     (x_5839, x_5838)
		  val x_5841: Word8.word vector list = 
		     ::[Word8.word vector] x_5840
		  val x_5842: Word8.word vector * Word8.word vector list = 
		     (x_5828, x_5841)
		  val x_5843: Word8.word vector list = 
		     ::[Word8.word vector] x_5842
		  val x_5844: Word8.word vector = 
		     "Io: "
		  val x_5845: Word8.word vector * Word8.word vector list = 
		     (x_5844, x_5843)
		  val x_5846: Word8.word vector list = 
		     ::[Word8.word vector] x_5845
		  val x_5847: Word8.word vector = 
		     concat_1 (Word8.word) x_5846
		  val x_5848: Word8.word vector option = 
		     SOME[Word8.word vector] x_5847
	       in
		  x_5848
	       end
	      _ => let
		      val x_5849: Word8.word vector option = 
			 NONE[Word8.word vector]
		   in
		      x_5849
		   end
      in
	 x_5825
      end
   val x_5850: unit = 
      addExnMessager x_5823
   exception NonblockingNotSupported
   exception RandomAccessNotSupported
   exception Path
   exception InvalidArc
   exception Sqrt
   exception Ln
   exception Ord
   exception Io of Word8.word vector
   exception Interrupt
   val rec ('a_3803, 'a_3802) 
      wrap: ('a_3803 * Word64.word -> 'a_3802) -> 'a_3803 * word -> 'a_3802 = 
	 fn x_5851: 'a_3803 * Word64.word -> 'a_3802 => 
	 let
	    val x_5852: 'a_3803 * word -> 'a_3802 = 
	       fn x_5853: 'a_3803 * word => 
	       let
		  val x_5854: word = 
		     #1 x_5853
		  val x_5855: 'a_3803 = 
		     #0 x_5853
		  val x_5856: Word64.word = 
		     sextdFromInt32ToInt64 x_5854
		  val x_5857: 'a_3803 * Word64.word = 
		     (x_5855, x_5856)
		  val x_5858: 'a_3802 = 
		     x_5851 x_5857
	       in
		  x_5858
	       end
	 in
	    x_5852
	 end
   val getInt32: MLton.Pointer.t * word -> word = 
      wrap (MLton.Pointer.t, word) getInt32
   val getReal32: MLton.Pointer.t * word -> Real32.real = 
      wrap (MLton.Pointer.t, Real32.real) getReal32
   val getWord32: MLton.Pointer.t * word -> word = 
      wrap (MLton.Pointer.t, word) getWord32
   val x_5859: (word -> word) * (word -> word) = 
      (fromRep, sextdFromInt32ToInt32)
   val fromInt: word -> word = 
      o_1 (word, word, word) x_5859
   val x_5860: (word -> word) * (word -> word) = 
      (sextdFromInt32ToInt32, toRep)
   val toInt: word -> word = 
      o_1 (word, word, word) x_5860
   val x_5861: word = 
      0x1
   val failure: word = 
      fromInt x_5861
   val x_5862: word = 
      0x0
   val success: word = 
      fromInt x_5862
   val x_5863: bool = 
      false
   val exiting: bool ref = 
      Ref_ref[bool] (x_5863)
   val rec 
      halt: word -> unit = 
	 fn x_5864: word => 
	 let
	    val x_5865: word = 
	       toRep x_5864
	    val x_5866: unit = 
	       halt x_5865
	 in
	    x_5866
	 end
   val rec 'a 
      exit: word -> 'a = 
	 fn x_5867: word => 
	 let
	    val x_5868: bool = 
	       !_1 (bool) exiting
	    val x_5869: 'a = 
	       case x_5868 of
	       true => 
		  let
		     val x_5967: Word8.word vector = 
			"MLton.Exit.exit"
		     val x_5968: exn = 
			Fail x_5967
		     val x_5969: 'a = 
			raise x_5968
		  in
		     x_5969
		  end
	       false => 
		  let
		     val x_5870: bool = 
			true
		     val x_5871: bool ref * bool = 
			(exiting, x_5870)
		     val x_5872: unit = 
			:=_1 (bool) x_5871
		     val i: word = 
			toInt x_5867
		     val x_5873: word = 
			0x0
		     val x_5874: word * word = 
			(x_5873, i)
		     val x_5875: bool = 
			<= x_5874
		     val x_5876: bool = 
			case x_5875 of
			true => 
			   let
			      val x_5878: word = 
				 0x100
			      val x_5879: word * word = 
				 (i, x_5878)
			      val x_5880: bool = 
				 < x_5879
			   in
			      x_5880
			   end
			false => 
			   let
			      val x_5877: bool = 
				 false
			   in
			      x_5877
			   end
		     val x_5881: 'a = 
			case x_5876 of
			true => 
			   let
			      val x_5953: (unit -> unit) -> unit = 
				 fn x_5954: unit -> unit => 
				 let
				    val x_5955: unit = 
				       let
					  val x_5956: unit = 
					     ()
					  val x_5957: unit = 
					     x_5954 x_5956
				       in
					  x_5957
				       end
				       handle x_5958 => let
							   val x_5959: unit = 
							      ()
							in
							   x_5959
							end
				 in
				    x_5955
				 end
			      val x_5960: (unit -> unit) list -> unit = 
				 app_1 (unit -> unit) x_5953
			      val x_5961: (unit -> unit) list = 
				 !_1 ((unit -> unit) list) atExit
			      val x_5962: unit = 
				 x_5960 x_5961
			      val x_5963: unit = 
				 halt x_5867
			      val x_5964: Word8.word vector = 
				 "MLton.Exit.exit"
			      val x_5965: exn = 
				 Fail x_5964
			      val x_5966: 'a = 
				 raise x_5965
			   in
			      x_5966
			   end
			false => 
			   let
			      val x_5882: Word8.word vector list = 
				 nil[Word8.word vector]
			      val x_5883: Word8.word vector = 
				 "exit must have 0 <= status < 256"
			      val x_5884: Word8.word vector
					  * Word8.word vector list = 
				 (x_5883, x_5882)
			      val x_5885: Word8.word vector list = 
				 ::[Word8.word vector] x_5884
			      val x_5886: Word8.word vector = 
				 "): "
			      val x_5887: Word8.word vector
					  * Word8.word vector list = 
				 (x_5886, x_5885)
			      val x_5888: Word8.word vector list = 
				 ::[Word8.word vector] x_5887
			      val x_5889: Word8.word array -> Word8.word vector = 
				 fn x_5890: Word8.word array => 
				 let
				    val x_5891: word = 
				       radixToInt x_3482
				    val radix: word = 
				       sextdFromInt32ToInt32 x_5891
				    val rec 
				       loop: word * word -> Word8.word vector = 
					  fn x_5892: word * word => 
					  let
					     val i: word = 
						#1 x_5892
					     val q: word = 
						#0 x_5892
					     val x_5893: word * word = 
						(radix, zero)
					     val x_5894: bool = 
						= (word) x_5893
					     val x_5895: word = 
						case x_5894 of
						true => 
						   let
						      val x_5906: exn = 
							 Div
						      val x_5907: word = 
							 raise x_5906
						   in
						      x_5907
						   end
						false => 
						   let
						      val x_5896: word * word = 
							 (q, minInt')
						      val x_5897: bool = 
							 = (word) x_5896
						      val x_5898: bool = 
							 case x_5897 of
							 true => 
							    let
							       val x_5900: word = 
								  ~! one
							       val x_5901: word
									   * word = 
								  (radix, x_5900)
							       val x_5902: bool = 
								  = (word) x_5901
							    in
							       x_5902
							    end
							 false => 
							    let
							       val x_5899: bool = 
								  false
							    in
							       x_5899
							    end
						      val x_5903: word = 
							 case x_5898 of
							 true => 
							    let
							    in
							       zero
							    end
							 false => 
							    let
							       val x_5904: word
									   * word = 
								  (q, radix)
							       val x_5905: word = 
								  remUnsafe x_5904
							    in
							       x_5905
							    end
						   in
						      x_5903
						   end
					     val x_5908: word = 
						~? x_5895
					     val x_5909: word = 
						sextdFromInt32ToInt32 x_5908
					     val x_5910: Word8.word = 
						digitToChar x_5909
					     val x_5911: Word8.word array
							 * word
							 * Word8.word = 
						(x_5890, i, x_5910)
					     val x_5912: unit = 
						update_0 (Word8.word) x_5911
					     val x_5913: word * word = 
						(q, radix)
					     val q: word = 
						quot x_5913
					     val x_5914: word * word = 
						(q, zero)
					     val x_5915: bool = 
						= (word) x_5914
					     val x_5916: Word8.word vector = 
						case x_5915 of
						true => 
						   let
						      val x_5922: word * word = 
							 (i, zero)
						      val x_5923: bool = 
							 < x_5922
						      val x_5924: word = 
							 case x_5923 of
							 true => 
							    let
							       val x_5925: word = 
								  0x1
							       val x_5926: word
									   * word = 
								  (i, x_5925)
							       val i: word = 
								  -! x_5926
							       val x_5927: Word8.word = 
								  0x7E
							       val x_5928: Word8.word array
									   * word
									   * Word8.word = 
								  (x_5890,
								   i,
								   x_5927)
							       val x_5929: unit = 
								  update_0 (Word8.word) x_5928
							    in
							       i
							    end
							 false => 
							    let
							    in
							       i
							    end
						      val x_5930: word option = 
							 NONE[word]
						      val x_5931: Word8.word array
								  * word
								  * word option = 
							 (x_5890, x_5924, x_5930)
						      val x_5932: Word8.word ArraySlice.slice = 
							 slice_3 (Word8.word) x_5931
						      val x_5933: Word8.word vector = 
							 vector_2 (Word8.word) x_5932
						   in
						      x_5933
						   end
						false => 
						   let
						      val x_5917: word = 
							 0x1
						      val x_5918: word * word = 
							 (i, x_5917)
						      val x_5919: word = 
							 -! x_5918
						      val x_5920: word * word = 
							 (q, x_5919)
						      val x_5921: Word8.word vector = 
							 loop x_5920
						   in
						      x_5921
						   end
					  in
					     x_5916
					  end
				    val x_5934: word * word = 
				       (i, zero)
				    val x_5935: bool = 
				       < x_5934
				    val x_5936: word = 
				       case x_5935 of
				       true => 
					  let
					  in
					     i
					  end
				       false => 
					  let
					     val x_5937: word = 
						~? i
					  in
					     x_5937
					  end
				    val x_5938: word = 
				       0x1
				    val x_5939: word * word = 
				       (maxNumDigits, x_5938)
				    val x_5940: word = 
				       -! x_5939
				    val x_5941: word * word = 
				       (x_5936, x_5940)
				    val x_5942: Word8.word vector = 
				       loop x_5941
				 in
				    x_5942
				 end
			      val x_5943: Word8.word array One.t
					  * (Word8.word array
					     -> Word8.word vector) = 
				 (oneBuf, x_5889)
			      val x_5944: Word8.word vector = 
				 use_0 (Word8.word vector, Word8.word array) x_5943
			      val x_5945: Word8.word vector
					  * Word8.word vector list = 
				 (x_5944, x_5888)
			      val x_5946: Word8.word vector list = 
				 ::[Word8.word vector] x_5945
			      val x_5947: Word8.word vector = 
				 "MLton.Exit.exit("
			      val x_5948: Word8.word vector
					  * Word8.word vector list = 
				 (x_5947, x_5946)
			      val x_5949: Word8.word vector list = 
				 ::[Word8.word vector] x_5948
			      val x_5950: Word8.word vector = 
				 concat_1 (Word8.word) x_5949
			      val x_5951: exn = 
				 Fail x_5950
			      val x_5952: 'a = 
				 raise x_5951
			   in
			      x_5952
			   end
		  in
		     x_5881
		  end
	 in
	    x_5869
	 end
   val rec 'a 
      wrapSuffix: (unit -> unit) -> unit -> 'a = 
	 fn x_5970: unit -> unit => 
	 let
	    val x_5971: unit -> 'a = 
	       fn x_5972: unit => 
	       let
		  val x_5973: 'a = 
		     let
			val x_5974: unit = 
			   ()
			val x_5975: unit = 
			   x_5970 x_5974
			val x_5976: Word8.word vector = 
			   "Top-level suffix returned.
"
			val x_5977: unit = 
			   print x_5976
			val x_5978: 'a = 
			   exit ('a) failure
		     in
			x_5978
		     end
		     handle x_5979 => let
					 val x_5980: Word8.word vector = 
					    "Top-level suffix raised exception.
"
					 val x_5981: unit = 
					    print x_5980
					 val x_5982: unit = 
					    halt failure
					 val x_5983: Word8.word vector = 
					    "MLton.Exit.wrapSuffix"
					 val x_5984: exn = 
					    Fail x_5983
					 val x_5985: 'a = 
					    raise x_5984
				      in
					 x_5985
				      end
	       in
		  x_5973
	       end
	 in
	    x_5971
	 end
   val rec 'a_3809 
      suffixExecutable: unit -> 'a_3809 = 
	 fn x_5986: unit => 
	 let
	    val x_5987: 'a_3809 = 
	       exit ('a_3809) success
	 in
	    x_5987
	 end
   val rec 'a 
      defaultTopLevelSuffix: unit -> 'a = 
	 fn x_5988: unit => 
	 let
	    val x_5989: unit -> 'a = 
	       wrapSuffix ('a) suffixExecutable (unit)
	    val x_5990: unit = 
	       ()
	    val x_5991: 'a = 
	       x_5989 x_5990
	 in
	    x_5991
	 end
   val rec 'a 
      wrapHandler: (exn -> unit) -> exn -> 'a = 
	 fn x_5992: exn -> unit => 
	 let
	    val x_5993: exn -> 'a = 
	       fn x_5994: exn => 
	       let
		  val x_5995: 'a = 
		     let
			val x_5996: unit = 
			   x_5992 x_5994
			val x_5997: Word8.word vector = 
			   "Top-level handler returned.
"
			val x_5998: unit = 
			   print x_5997
			val x_5999: 'a = 
			   exit ('a) failure
		     in
			x_5999
		     end
		     handle x_6000 => let
					 val x_6001: Word8.word vector = 
					    "Top-level handler raised exception.
"
					 val x_6002: unit = 
					    print x_6001
					 val x_6003: unit = 
					    halt failure
					 val x_6004: Word8.word vector = 
					    "MLton.Exn.wrapHandler"
					 val x_6005: exn = 
					    Fail x_6004
					 val x_6006: 'a = 
					    raise x_6005
				      in
					 x_6006
				      end
	       in
		  x_5995
	       end
	 in
	    x_5993
	 end
   val 'a_3810 defaultHandler: exn -> 'a_3810 = 
      let
	 val x_6007: exn -> 'a_3810 = 
	    fn x_6008: exn => 
	    let
	       val x_6009: Word8.word vector list = 
		  nil[Word8.word vector]
	       val x_6010: Word8.word vector = 
		  "
"
	       val x_6011: Word8.word vector * Word8.word vector list = 
		  (x_6010, x_6009)
	       val x_6012: Word8.word vector list = 
		  ::[Word8.word vector] x_6011
	       val x_6013: Word8.word vector = 
		  exnMessage x_6008
	       val x_6014: Word8.word vector * Word8.word vector list = 
		  (x_6013, x_6012)
	       val x_6015: Word8.word vector list = 
		  ::[Word8.word vector] x_6014
	       val x_6016: Word8.word vector = 
		  "unhandled exception: "
	       val x_6017: Word8.word vector * Word8.word vector list = 
		  (x_6016, x_6015)
	       val x_6018: Word8.word vector list = 
		  ::[Word8.word vector] x_6017
	       val x_6019: Word8.word vector = 
		  concat_1 (Word8.word) x_6018
	       val x_6020: unit = 
		  print x_6019
	       val x_6021: Word8.word vector list = 
		  nil[Word8.word vector]
	       val x_6022: unit = 
		  ()
	       val x_6023: 'a_3810 = 
		  exit ('a_3810) failure
	    in
	       x_6023
	    end
      in
	 x_6007
      end
   val rec 'a 
      defaultTopLevelHandler: exn -> 'a = 
	 fn x_6024: exn => 
	 let
	    val x_6025: exn -> 'a = 
	       wrapHandler ('a) defaultHandler (unit)
	    val x_6026: 'a = 
	       x_6025 x_6024
	 in
	    x_6026
	 end
   exception MisuseOfForget
   exception DoublyRedirected
   exception Poll
   val x_6027: (Word16.word -> Word16.word) * (Word16.word -> Word16.word) = 
      (idFromWord16ToInt16, htons)
   val x_6028: Word16.word -> Word16.word = 
      o_1 (Word16.word, Word16.word, Word16.word) x_6027
   val x_6029: (Word16.word -> Word16.word) * (Word16.word -> Word16.word) = 
      (x_6028, idFromInt16ToWord16)
   val hton: Word16.word -> Word16.word = 
      o_1 (Word16.word, Word16.word, Word16.word) x_6029
   val x_6030: (Word16.word -> Word16.word) * (Word16.word -> Word16.word) = 
      (idFromWord16ToInt16, ntohs)
   val x_6031: Word16.word -> Word16.word = 
      o_1 (Word16.word, Word16.word, Word16.word) x_6030
   val x_6032: (Word16.word -> Word16.word) * (Word16.word -> Word16.word) = 
      (x_6031, idFromInt16ToWord16)
   val ntoh: Word16.word -> Word16.word = 
      o_1 (Word16.word, Word16.word, Word16.word) x_6032
   val ('a_3956, 'a_3955) fInt8: 'a_3956 -> 'a_3955 = 
      let
	 val x_6033: 'a_3956 -> 'a_3955 = 
	    fn x_6034: 'a_3956 => 
	    let
	       val x_6035: Word8.word vector = 
		  "Net.C_Int.hton: fInt8"
	       val x_6036: exn = 
		  Fail x_6035
	       val x_6037: 'a_3955 = 
		  raise x_6036
	    in
	       x_6037
	    end
      in
	 x_6033
      end
   val ('a_3958, 'a_3957) fInt64: 'a_3958 -> 'a_3957 = 
      let
	 val x_6038: 'a_3958 -> 'a_3957 = 
	    fn x_6039: 'a_3958 => 
	    let
	       val x_6040: Word8.word vector = 
		  "Net.C_Int.hton: fInt64"
	       val x_6041: exn = 
		  Fail x_6040
	       val x_6042: 'a_3957 = 
		  raise x_6041
	    in
	       x_6042
	    end
      in
	 x_6038
      end
   val ('a_3962, 'a_3961) fInt8: 'a_3962 -> 'a_3961 = 
      let
	 val x_6043: 'a_3962 -> 'a_3961 = 
	    fn x_6044: 'a_3962 => 
	    let
	       val x_6045: Word8.word vector = 
		  "Net.C_Int.ntoh: fInt8"
	       val x_6046: exn = 
		  Fail x_6045
	       val x_6047: 'a_3961 = 
		  raise x_6046
	    in
	       x_6047
	    end
      in
	 x_6043
      end
   val ('a_3964, 'a_3963) fInt64: 'a_3964 -> 'a_3963 = 
      let
	 val x_6048: 'a_3964 -> 'a_3963 = 
	    fn x_6049: 'a_3964 => 
	    let
	       val x_6050: Word8.word vector = 
		  "Net.C_Int.ntoh: fInt64"
	       val x_6051: exn = 
		  Fail x_6050
	       val x_6052: 'a_3963 = 
		  raise x_6051
	    in
	       x_6052
	    end
      in
	 x_6048
      end
   val x_6053: MLtonProfile.Data.t list = 
      nil[MLtonProfile.Data.t]
   val all: MLtonProfile.Data.t list ref = 
      Ref_ref[MLtonProfile.Data.t list] (x_6053)
   val rec 'a_4045 
      make: (bool ref * bool ref * MLton.Pointer.t -> 'a_4045)
	    -> MLtonProfile.Data.t -> 'a_4045 = 
	 fn x_6054: bool ref * bool ref * MLton.Pointer.t -> 'a_4045 => 
	 let
	    val x_6055: MLtonProfile.Data.t -> 'a_4045 = 
	       fn x_6056: MLtonProfile.Data.t => 
	       let
		  val x_6057: 'a_4045 = 
		     case x_6056 of
		     T x_6058: bool ref * bool ref * MLton.Pointer.t => 
			let
			   val x_6059: 'a_4045 = 
			      x_6054 x_6058
			in
			   x_6059
			end
	       in
		  x_6057
	       end
	 in
	    x_6055
	 end
   val x_6060: bool ref * bool ref * MLton.Pointer.t -> MLton.Pointer.t = 
      fn x_6061: bool ref * bool ref * MLton.Pointer.t => 
      let
	 val x_6062: MLton.Pointer.t = 
	    #2 x_6061
      in
	 x_6062
      end
   val raw: MLtonProfile.Data.t -> MLton.Pointer.t = 
      make (MLton.Pointer.t) x_6060
   val rec 
      make: MLton.Pointer.t -> MLtonProfile.Data.t = 
	 fn x_6063: MLton.Pointer.t => 
	 let
	    val x_6064: bool = 
	       false
	    val x_6065: bool ref = 
	       Ref_ref[bool] (x_6064)
	    val x_6066: bool = 
	       false
	    val x_6067: bool ref = 
	       Ref_ref[bool] (x_6066)
	    val x_6068: bool ref * bool ref * MLton.Pointer.t = 
	       (x_6065, x_6067, x_6063)
	    val x_6069: MLtonProfile.Data.t = 
	       T x_6068
	 in
	    x_6069
	 end
   val x_6070: MLtonProfile.Data.t = 
      make null
   val r: MLtonProfile.Data.t ref = 
      Ref_ref[MLtonProfile.Data.t] (x_6070)
   val rec 
      current: unit -> MLtonProfile.Data.t = 
	 fn x_6071: unit => 
	 let
	    val x_6072: MLtonProfile.Data.t = 
	       !_1 (MLtonProfile.Data.t) r
	 in
	    x_6072
	 end
   val rec 
      init: unit -> unit = 
	 fn x_6073: unit => 
	 let
	    val x_6074: MLton.Pointer.t = 
	       GC_getProfileCurrent (x_826)
	    val x_6075: MLtonProfile.Data.t = 
	       make x_6074
	    val x_6076: unit = 
	       case x_6075 of
	       T x_6077: bool ref * bool ref * MLton.Pointer.t => 
		  let
		     val x_6078: MLton.Pointer.t = 
			#2 x_6077
		     val x_6079: bool ref = 
			#1 x_6077
		     val x_6080: bool ref = 
			#0 x_6077
		     val x_6081: bool = 
			not isOn
		     val x_6082: unit = 
			case x_6081 of
			true => 
			   let
			      val x_6103: unit = 
				 ()
			   in
			      x_6103
			   end
			false => 
			   let
			      val x_6083: bool = 
				 !_1 (bool) x_6079
			      val x_6084: unit = 
				 case x_6083 of
				 true => 
				    let
				       val x_6100: Word8.word vector = 
					  "setCurrent of freed profile data"
				       val x_6101: exn = 
					  Fail x_6100
				       val x_6102: unit = 
					  raise x_6101
				    in
				       x_6102
				    end
				 false => 
				    let
				       val x_6085: unit = 
					  ()
				       val x_6086: MLtonProfile.Data.t = 
					  current x_6085
				       val x_6087: unit = 
					  case x_6086 of
					  T x_6088: bool ref
						    * bool ref
						    * MLton.Pointer.t => 
					     let
						val x_6089: bool ref = 
						   #0 x_6088
						val x_6090: bool = 
						   false
						val x_6091: bool ref * bool = 
						   (x_6089, x_6090)
						val x_6092: unit = 
						   :=_1 (bool) x_6091
						val x_6093: bool = 
						   true
						val x_6094: bool ref * bool = 
						   (x_6080, x_6093)
						val x_6095: unit = 
						   :=_1 (bool) x_6094
						val x_6096: MLtonProfile.Data.t ref
							    * MLtonProfile.Data.t = 
						   (r, x_6075)
						val x_6097: unit = 
						   :=_1 (MLtonProfile.Data.t) x_6096
						val x_6098: unit = 
						   GC_setProfileCurrent (x_826,
									 x_6078)
						val x_6099: unit = 
						   ()
					     in
						x_6099
					     end
				    in
				       x_6087
				    end
			   in
			      x_6084
			   end
		  in
		     x_6082
		  end
	 in
	    x_6076
	 end
   val x_6104: bool = 
      not isOn
   val x_6105: unit = 
      case x_6104 of
      true => 
	 let
	    val x_6147: unit = 
	       ()
	 in
	    x_6147
	 end
      false => 
	 let
	    val x_6106: unit -> unit = 
	       fn x_6107: unit => 
	       let
		  val x_6108: unit = 
		     GC_profileDone (x_826)
		  val x_6109: unit = 
		     ()
		  val x_6110: MLtonProfile.Data.t = 
		     current x_6109
		  val x_6111: Word8.word vector = 
		     "mlmon.out"
		  val x_6112: unit = 
		     case x_6110 of
		     T x_6113: bool ref * bool ref * MLton.Pointer.t => 
			let
			   val x_6114: MLton.Pointer.t = 
			      #2 x_6113
			   val x_6115: bool ref = 
			      #1 x_6113
			   val x_6116: bool = 
			      not isOn
			   val x_6117: unit = 
			      case x_6116 of
			      true => 
				 let
				    val x_6126: unit = 
				       ()
				 in
				    x_6126
				 end
			      false => 
				 let
				    val x_6118: bool = 
				       !_1 (bool) x_6115
				    val x_6119: unit = 
				       case x_6118 of
				       true => 
					  let
					     val x_6123: Word8.word vector = 
						"write of freed profile data"
					     val x_6124: exn = 
						Fail x_6123
					     val x_6125: unit = 
						raise x_6124
					  in
					     x_6125
					  end
				       false => 
					  let
					     val x_6120: Word8.word vector = 
						nullTerm x_6111
					     val x_6121: Word8.word vector = 
						fromString x_6120
					     val x_6122: unit = 
						GC_profileWrite (x_826,
								 x_6114,
								 x_6121)
					  in
					     x_6122
					  end
				 in
				    x_6119
				 end
			in
			   x_6117
			end
		  val x_6127: MLtonProfile.Data.t -> unit = 
		     fn x_6128: MLtonProfile.Data.t => 
		     let
			val x_6129: MLton.Pointer.t = 
			   raw x_6128
			val x_6130: unit = 
			   GC_profileFree (x_826, x_6129)
		     in
			x_6130
		     end
		  val x_6131: MLtonProfile.Data.t list -> unit = 
		     app_0 (MLtonProfile.Data.t) x_6127
		  val x_6132: MLtonProfile.Data.t list = 
		     !_1 (MLtonProfile.Data.t list) all
		  val x_6133: unit = 
		     x_6131 x_6132
	       in
		  x_6133
	       end
	    val x_6134: (unit -> unit) list ref * (unit -> unit) = 
	       (atExit, x_6106)
	    val x_6135: unit = 
	       addNew (unit -> unit) x_6134
	    val x_6136: unit -> unit = 
	       fn x_6137: unit => 
	       let
		  val x_6138: MLtonProfile.Data.t list = 
		     nil[MLtonProfile.Data.t]
		  val x_6139: MLtonProfile.Data.t list ref
			      * MLtonProfile.Data.t list = 
		     (all, x_6138)
		  val x_6140: unit = 
		     :=_1 (MLtonProfile.Data.t list) x_6139
		  val x_6141: unit = 
		     ()
		  val x_6142: unit = 
		     init x_6141
	       in
		  x_6142
	       end
	    val x_6143: (unit -> unit) list ref * (unit -> unit) = 
	       (atLoadWorld, x_6136)
	    val x_6144: unit = 
	       addNew (unit -> unit) x_6143
	    val x_6145: unit = 
	       ()
	    val x_6146: unit = 
	       init x_6145
	 in
	    x_6146
	 end
   val x_6148: unit = 
      setHandler defaultTopLevelHandler (unit)
   val x_6149: unit = 
      setSuffix defaultTopLevelSuffix (unit)
   exception UNKNOWN
   val 'a :=_2: 'a ref * 'a -> unit = 
      let
      in
	 :=_1 ('a)
      end
   val 'a fromList_2: 'a list -> 'a vector = 
      let
      in
	 fromList_1 ('a)
      end
   val 'a :=_3: 'a ref * 'a -> unit = 
      let
      in
	 :=_2 ('a)
      end
   val 'a fromList_3: 'a list -> 'a vector = 
      let
      in
	 fromList_2 ('a)
      end
   exception unimplemented
   val 'a_4259 pack: 'a_4259 -> 'a_4259 = 
      let
	 val x_6150: 'a_4259 -> 'a_4259 = 
	    fn x_6151: 'a_4259 => 
	    let
	    in
	       x_6151
	    end
      in
	 x_6150
      end
   val x_6152: unit = 
      ()
in
   x_6152
end
